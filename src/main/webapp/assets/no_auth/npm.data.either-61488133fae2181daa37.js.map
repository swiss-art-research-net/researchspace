{"version":3,"sources":["webpack:///./node_modules/data.either/lib/index.js","webpack:///./node_modules/data.either/lib/either.js"],"names":["module","exports","Either","clone","Object","create","unimplemented","Error","noop","this","Left","a","value","Right","prototype","fromNullable","fromValidation","fold","try","f","apply","arguments","e","isLeft","isRight","of","ap","b","map","chain","toString","isEqual","get","TypeError","getOrElse","_","orElse","merge","g","cata","pattern","swap","bimap","leftMap"],"mappings":"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","file":"npm.data.either-61488133fae2181daa37.js","sourcesContent":["// Copyright (c) 2013-2014 Quildreen Motta <quildreen@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = require('./either')","// Copyright (c) 2013-2014 Quildreen Motta <quildreen@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module lib/either\n */\nmodule.exports = Either\n\n// -- Aliases ----------------------------------------------------------\nvar clone         = Object.create\nvar unimplemented = function(){ throw new Error('Not implemented.') }\nvar noop          = function(){ return this                         }\n\n\n// -- Implementation ---------------------------------------------------\n\n/**\n * The `Either(a, b)` structure represents the logical disjunction between `a`\n * and `b`. In other words, `Either` may contain either a value of type `a` or\n * a value of type `b`, at any given time. This particular implementation is\n * biased on the right value (`b`), thus projections will take the right value\n * over the left one.\n *\n * This class models two different cases: `Left a` and `Right b`, and can hold\n * one of the cases at any given time. The projections are, none the less,\n * biased for the `Right` case, thus a common use case for this structure is to\n * hold the results of computations that may fail, when you want to store\n * additional information on the failure (instead of throwing an exception).\n *\n * Furthermore, the values of `Either(a, b)` can be combined and manipulated by\n * using the expressive monadic operations. This allows safely sequencing\n * operations that may fail, and safely composing values that you don't know\n * whether they're present or not, failing early (returning a `Left a`) if any\n * of the operations fail.\n *\n * While this class can certainly model input validations, the [Validation][]\n * structure lends itself better to that use case, since it can naturally\n * aggregate failures — monads shortcut on the first failure.\n *\n * [Validation]: https://github.com/folktale/data.validation\n *\n *\n * @class\n * @summary\n * Either[α, β] <: Applicative[β]\n *               , Functor[β]\n *               , Chain[β]\n *               , Show\n *               , Eq\n */\nfunction Either() { }\n\nLeft.prototype = clone(Either.prototype)\nfunction Left(a) {\n  this.value = a\n}\n\nRight.prototype = clone(Either.prototype)\nfunction Right(a) {\n  this.value = a\n}\n\n// -- Constructors -----------------------------------------------------\n\n/**\n * Constructs a new `Either[α, β]` structure holding a `Left` value. This\n * usually represents a failure due to the right-bias of this structure.\n *\n * @summary a → Either[α, β]\n */\nEither.Left = function(a) {\n  return new Left(a)\n}\nEither.prototype.Left = Either.Left\n\n/**\n * Constructs a new `Either[α, β]` structure holding a `Right` value. This\n * usually represents a successful value due to the right bias of this\n * structure.\n *\n * @summary β → Either[α, β]\n */\nEither.Right = function(a) {\n  return new Right(a)\n}\nEither.prototype.Right = Either.Right\n\n\n// -- Conversions ------------------------------------------------------\n\n/**\n * Constructs a new `Either[α, β]` structure from a nullable type.\n *\n * Takes the `Left` case if the value is `null` or `undefined`. Takes the\n * `Right` case otherwise.\n *\n * @summary α → Either[α, α]\n */\nEither.fromNullable = function(a) {\n  return a != null?       new Right(a)\n  :      /* otherwise */  new Left(a)\n}\nEither.prototype.fromNullable = Either.fromNullable\n\n/**\n * Constructs a new `Either[α, β]` structure from a `Validation[α, β]` type.\n *\n * @summary Validation[α, β] → Either[α, β]\n */\nEither.fromValidation = function(a) {\n  return a.fold(Either.Left, Either.Right)\n}\n\n/**\n * Executes a synchronous computation that may throw and converts it to an\n * Either type.\n *\n * @summary (α₁, α₂, ..., αₙ -> β :: throws γ) -> (α₁, α₂, ..., αₙ -> Either[γ, β])\n */\nEither.try = function(f) {\n  return function() {\n    try {\n      return new Right(f.apply(null, arguments))\n    } catch(e) {\n      return new Left(e)\n    }\n  }\n}\n\n\n// -- Predicates -------------------------------------------------------\n\n/**\n * True if the `Either[α, β]` contains a `Left` value.\n *\n * @summary Boolean\n */\nEither.prototype.isLeft = false\nLeft.prototype.isLeft   = true\n\n/**\n * True if the `Either[α, β]` contains a `Right` value.\n *\n * @summary Boolean\n */\nEither.prototype.isRight = false\nRight.prototype.isRight  = true\n\n\n// -- Applicative ------------------------------------------------------\n\n/**\n * Creates a new `Either[α, β]` instance holding the `Right` value `b`.\n *\n * `b` can be any value, including `null`, `undefined` or another\n * `Either[α, β]` structure.\n *\n * @summary β → Either[α, β]\n */\nEither.of = function(a) {\n  return new Right(a)\n}\nEither.prototype.of = Either.of\n\n\n/**\n * Applies the function inside the `Right` case of the `Either[α, β]` structure\n * to another applicative type.\n *\n * The `Either[α, β]` should contain a function value, otherwise a `TypeError`\n * is thrown.\n *\n * @method\n * @summary (@Either[α, β → γ], f:Applicative[_]) => f[β] → f[γ]\n */\nEither.prototype.ap = unimplemented\n\nLeft.prototype.ap = function(b) {\n  return this\n}\n\nRight.prototype.ap = function(b) {\n  return b.map(this.value)\n}\n\n\n// -- Functor ----------------------------------------------------------\n\n/**\n * Transforms the `Right` value of the `Either[α, β]` structure using a regular\n * unary function.\n *\n * @method\n * @summary (@Either[α, β]) => (β → γ) → Either[α, γ]\n */\nEither.prototype.map = unimplemented\nLeft.prototype.map   = noop\n\nRight.prototype.map = function(f) {\n  return this.of(f(this.value))\n}\n\n\n// -- Chain ------------------------------------------------------------\n\n/**\n * Transforms the `Right` value of the `Either[α, β]` structure using an unary\n * function to monads.\n *\n * @method\n * @summary (@Either[α, β], m:Monad[_]) => (β → m[γ]) → m[γ]\n */\nEither.prototype.chain = unimplemented\nLeft.prototype.chain   = noop\n\nRight.prototype.chain = function(f) {\n  return f(this.value)\n}\n\n\n// -- Show -------------------------------------------------------------\n\n/**\n * Returns a textual representation of the `Either[α, β]` structure.\n *\n * @method\n * @summary (@Either[α, β]) => Void → String\n */\nEither.prototype.toString = unimplemented\n\nLeft.prototype.toString = function() {\n  return 'Either.Left(' + this.value + ')'\n}\n\nRight.prototype.toString = function() {\n  return 'Either.Right(' + this.value + ')'\n}\n\n\n// -- Eq ---------------------------------------------------------------\n\n/**\n * Tests if an `Either[α, β]` structure is equal to another `Either[α, β]`\n * structure.\n *\n * @method\n * @summary (@Either[α, β]) => Either[α, β] → Boolean\n */\nEither.prototype.isEqual = unimplemented\n\nLeft.prototype.isEqual = function(a) {\n  return a.isLeft && (a.value === this.value)\n}\n\nRight.prototype.isEqual = function(a) {\n  return a.isRight && (a.value === this.value)\n}\n\n\n// -- Extracting and recovering ----------------------------------------\n\n/**\n * Extracts the `Right` value out of the `Either[α, β]` structure, if it\n * exists. Otherwise throws a `TypeError`.\n *\n * @method\n * @summary (@Either[α, β]) => Void → β         :: partial, throws\n * @see {@link module:lib/either~Either#getOrElse} — A getter that can handle failures.\n * @see {@link module:lib/either~Either#merge} — The convergence of both values.\n * @throws {TypeError} if the structure has no `Right` value.\n */\nEither.prototype.get = unimplemented\n\nLeft.prototype.get = function() {\n  throw new TypeError(\"Can't extract the value of a Left(a).\")\n}\n\nRight.prototype.get = function() {\n  return this.value\n}\n\n\n/**\n * Extracts the `Right` value out of the `Either[α, β]` structure. If the\n * structure doesn't have a `Right` value, returns the given default.\n *\n * @method\n * @summary (@Either[α, β]) => β → β\n */\nEither.prototype.getOrElse = unimplemented\n\nLeft.prototype.getOrElse = function(a) {\n  return a\n}\n\nRight.prototype.getOrElse = function(_) {\n  return this.value\n}\n\n\n/**\n * Transforms a `Left` value into a new `Either[α, β]` structure. Does nothing\n * if the structure contain a `Right` value.\n *\n * @method\n * @summary (@Either[α, β]) => (α → Either[γ, β]) → Either[γ, β]\n */\nEither.prototype.orElse = unimplemented\nRight.prototype.orElse  = noop\n\nLeft.prototype.orElse = function(f) {\n  return f(this.value)\n}\n\n\n/**\n * Returns the value of whichever side of the disjunction that is present.\n *\n * @summary (@Either[α, α]) => Void → α\n */\nEither.prototype.merge = function() {\n  return this.value\n}\n\n\n// -- Folds and Extended Transformations -------------------------------\n\n/**\n * Applies a function to each case in this data structure.\n *\n * @method\n * @summary (@Either[α, β]) => (α → γ), (β → γ) → γ\n */\nEither.prototype.fold = unimplemented\n\nLeft.prototype.fold = function(f, _) {\n  return f(this.value)\n}\n\nRight.prototype.fold = function(_, g) {\n  return g(this.value)\n}\n\n/**\n * Catamorphism.\n * \n * @method\n * @summary (@Either[α, β]) => { Left: α → γ, Right: β → γ } → γ\n */\nEither.prototype.cata = unimplemented\n\nLeft.prototype.cata = function(pattern) {\n  return pattern.Left(this.value)\n}\n\nRight.prototype.cata = function(pattern) {\n  return pattern.Right(this.value)\n}\n\n\n/**\n * Swaps the disjunction values.\n *\n * @method\n * @summary (@Either[α, β]) => Void → Either[β, α]\n */\nEither.prototype.swap = unimplemented\n\nLeft.prototype.swap = function() {\n  return this.Right(this.value)\n}\n\nRight.prototype.swap = function() {\n  return this.Left(this.value)\n}\n\n\n/**\n * Maps both sides of the disjunction.\n *\n * @method\n * @summary (@Either[α, β]) => (α → γ), (β → δ) → Either[γ, δ]\n */\nEither.prototype.bimap = unimplemented\n\nLeft.prototype.bimap = function(f, _) {\n  return this.Left(f(this.value))\n}\n\nRight.prototype.bimap = function(_, g) {\n  return this.Right(g(this.value))\n}\n\n\n/**\n * Maps the left side of the disjunction.\n *\n * @method\n * @summary (@Either[α, β]) => (α → γ) → Either[γ, β]\n */\nEither.prototype.leftMap = unimplemented\nRight.prototype.leftMap  = noop\n\nLeft.prototype.leftMap = function(f) {\n  return this.Left(f(this.value))\n}\n"],"sourceRoot":""}