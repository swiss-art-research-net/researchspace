{"version":3,"sources":["webpack:///./src/main/web/components/forms/inputs/AutocompleteInput.tsx"],"names":["CLASS_NAME","props","context","tupleTemplate","onNestedFormSubmit","value","setState","nestedFormOpen","setAndValidate","toggleNestedForm","state","onChange","selected","FieldValue","fromLabeled","label","empty","compileTemplate","this","template","replace","render","nestedForm","tryExtractNestedForm","children","showCreateNewButton","Boolean","className","renderSelect","ValidationMessages","errors","getErrors","NestedModalForm","subject","isEmpty","definition","onSubmit","onCancel","rdfNode","asRdfNode","placeholder","createDefaultPlaceholder","isAtomic","Rdf","literal","undefined","AutoCompletionInput","key","id","autofocus","query","autosuggestionPattern","droppable","createDropAskQueryForField","styles","enabled","outline","enabledHover","disabled","templates","suggestion","actions","onSelected","minimumInput","Button","bsStyle","onClick","getPreferredLabel","toLocaleLowerCase","makeHandler","AtomicValueInput","makeAtomicHandler","AutocompleteInput","SingleValueInput","assertStatic"],"mappings":"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","file":"semantic-form-autocomplete-input-bcdd5458cc3d655394be.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport * as React from 'react';\nimport { Button } from 'react-bootstrap';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { AutoCompletionInput } from 'platform/components/ui/inputs';\n\nimport { FieldDefinition, getPreferredLabel } from '../FieldDefinition';\nimport { FieldValue, AtomicValue, EmptyValue } from '../FieldValues';\nimport { NestedModalForm, tryExtractNestedForm } from './NestedModalForm';\nimport {\n  SingleValueInput, AtomicValueInput, AtomicValueInputProps,\n} from './SingleValueInput';\nimport { createDropAskQueryForField } from '../ValidationHelpers';\nimport { ValidationMessages } from './Decorations';\n\nexport interface AutocompleteInputProps extends AtomicValueInputProps {\n  template?: string;\n  placeholder?: string;\n}\n\ninterface SelectValue {\n  value: Rdf.Node;\n  label: Rdf.Literal;\n}\n\ninterface State {\n  readonly nestedFormOpen?: boolean;\n}\n\nconst CLASS_NAME = 'autocomplete-text-field';\nconst MINIMUM_LIMIT = 3;\nconst DEFAULT_TEMPLATE = `<span title=\"{{label.value}}\">{{label.value}}</span>`;\n\nexport class AutocompleteInput extends AtomicValueInput<AutocompleteInputProps, State> {\n  private tupleTemplate: string = null;\n\n  constructor(props: AutocompleteInputProps, context: any) {\n    super(props, context);\n    this.state = { nestedFormOpen: false };\n    this.tupleTemplate = this.tupleTemplate || this.compileTemplate();\n  }\n\n  private compileTemplate() {\n    return this.props.template ? this.props.template.replace(/\\\\/g, '') : DEFAULT_TEMPLATE;\n  }\n\n  render() {\n    const nestedForm = tryExtractNestedForm(this.props.children);\n    const showCreateNewButton = Boolean(nestedForm);\n    return (\n      <div className={CLASS_NAME}>\n        {this.renderSelect(showCreateNewButton)}\n        <ValidationMessages errors={FieldValue.getErrors(this.props.value)} />\n        {this.state.nestedFormOpen ? (\n          <NestedModalForm\n            subject={\n              FieldValue.isEmpty(this.props.value) ? null : this.props.value.value as Rdf.Iri\n            }\n            definition={this.props.definition}\n            onSubmit={this.onNestedFormSubmit}\n            onCancel={() => this.setState({ nestedFormOpen: false })}\n          >\n            {nestedForm}\n          </NestedModalForm>\n        ) : null}\n      </div>\n    );\n  }\n\n  private onNestedFormSubmit = (value: AtomicValue) => {\n    this.setState({ nestedFormOpen: false });\n    this.setAndValidate(value);\n  };\n\n  private renderSelect(showCreateNewButton: boolean) {\n    const definition = this.props.definition;\n    const rdfNode = FieldValue.asRdfNode(this.props.value);\n    const placeholder =\n      typeof this.props.placeholder === 'undefined'\n        ? this.createDefaultPlaceholder(definition)\n        : this.props.placeholder;\n    const value = FieldValue.isAtomic(this.props.value)\n      ? {\n          value: rdfNode,\n          label: Rdf.literal(this.props.value.label || rdfNode.value),\n        }\n      : undefined;\n\n    return (\n      <div className={`${CLASS_NAME}__main-row`}>\n        <AutoCompletionInput\n          key={definition.id}\n          className={`${CLASS_NAME}__select`}\n          autofocus={false}\n          query={this.props.definition.autosuggestionPattern}\n          placeholder={placeholder}\n          droppable={{\n            // enable droppable for autocomplete input\n            query: createDropAskQueryForField(definition),\n            styles: {\n              enabled: {\n                outline: '2px dashed #1D0A6E'\n              },\n              enabledHover: {\n                outline: '4px dashed #1D0A6E'\n              },\n              disabled: {}\n            }\n          }}\n          value={value}\n          templates={{ suggestion: this.tupleTemplate }}\n          actions={{\n            // TODO due to the typing in AutocompleteInput, this accepts only a Dictionary<Rdf.Node>\n            // however, what will be passed in is a SelectValue\n            onSelected: this.onChange as (val: any) => void,\n          }}\n          minimumInput={MINIMUM_LIMIT}\n        />\n        {showCreateNewButton ? (\n          <Button className={`${CLASS_NAME}__create-button`} bsStyle=\"default\" onClick={this.toggleNestedForm}>\n            {value === undefined ? <span className=\"fa fa-plus\" /> : null}\n            {value === undefined ? <span> Create new</span> : <span>Edit</span>}\n          </Button>\n        ) : null}\n      </div>\n    );\n  }\n\n  private toggleNestedForm = () => {\n    this.setState((state): State => ({ nestedFormOpen: !state.nestedFormOpen }));\n  };\n\n  private onChange = (selected: SelectValue | null): void => {\n    let value: AtomicValue | EmptyValue;\n    if (selected) {\n      value = FieldValue.fromLabeled({\n        value: selected.value,\n        label: selected.label.value,\n      });\n    } else {\n      value = FieldValue.empty;\n    }\n    this.setState({ nestedFormOpen: false });\n    this.setAndValidate(value);\n  };\n\n  private createDefaultPlaceholder(definition: FieldDefinition): string {\n    const fieldName = (getPreferredLabel(definition.label) || 'entity').toLocaleLowerCase();\n    return `Search and select ${fieldName} here...`;\n  }\n\n  static makeHandler = AtomicValueInput.makeAtomicHandler;\n}\n\nSingleValueInput.assertStatic(AutocompleteInput);\n\nexport default AutocompleteInput;\n"],"sourceRoot":""}