{"version":3,"sources":["webpack:///./src/main/web/components/semantic/lazy-tree/LazyTree.tsx","webpack:///./src/main/web/components/semantic/lazy-tree/LazyTreeEvents.ts"],"names":["props","context","searchedPaths","Immutable","Set","cancellation","Cancellation","expandingCancellation","cancelled","onTreeMount","tree","onSearchBadgeClick","selection","target","path","getKeyPath","onExpandAndScrollToPath","onSearchSelectionChanged","previousPaths","TreeSelection","leafs","map","node","List","toSet","newlySelectedPaths","filter","has","size","first","toArray","fromKeyPath","onItemClick","item","trigger","eventType","ItemSelected","source","id","data","iri","value","isLeaf","model","children","length","hasMoreChildren","undefined","childrenOf","loading","hasMoreItems","requestMore","state","forest","loadingForest","forestChange","observe","changeForest","setState","onExpandedOrCollapsed","expanded","updateNode","TreeNode","set","componentDidMount","patterns","this","type","config","createDefaultTreeQueries","SparqlNodeModel","rootsQuery","SparqlUtil","parseQuery","childrenQuery","parentsQuery","sparqlOptions","semanticContext","limit","pageSize","loadMoreChildren","Node","readyToLoadRoot","onValue","expandingToScroll","KeyedForest","create","keyOf","render","renderTree","highlightedPath","highlightedNodes","highlightTarget","getNodePath","renderItem","renderTreeNodeRow","hideCheckboxes","isExpanded","selectionMode","SingleFullSubtree","className","styles","component","SemanticTreeInput","multipleSelection","onSelectionClick","onSelectionChanged","alignmentTreeContainer","renderExpandToScrollMessage","LazyTreeSelector","ref","alignmentTree","decoratorsClass","computeDecoratorsClass","alignmentNodeRow","Draggable","renderTreeNode","renderNodeInfoTemplate","title","getLabel","infoTemplate","TemplateItem","template","options","expandTarget","scrollNotification","scrollToName","label","Spinner","scrollSpinner","spinnerDelay","messageDelay","Infinity","classes","decoratedNodeBody","pathIndex","indexOf","isTarget","push","decorateHighlightLeaf","decorateHighlightParent","join","onExpandingStateChanged","scrollToPath","deriveAndCancel","loadPath","parent","expandPath","error","console","cancelExpandingToScroll","cancelAll","defaultProps","Component","LazyTree","event","EventMaker"],"mappings":"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","file":"semantic-lazy-tree-d192b727acdad97d08b8.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as React from 'react';\nimport * as Immutable from 'immutable';\n\nimport { Cancellation } from 'platform/api/async';\nimport { SparqlUtil } from 'platform/api/sparql';\nimport { trigger } from 'platform/api/events';\n\nimport { Component } from 'platform/api/components';\nimport { TemplateItem } from 'platform/components/ui/template';\nimport { Spinner } from 'platform/components/ui/spinner';\nimport { Draggable } from 'platform/components/dnd';\n\nimport {\n  KeyPath,\n  TreeSelection,\n  SelectionNode,\n  Node,\n  TreeNode,\n  LazyTreeSelector,\n  LazyTreeSelectorProps,\n  SemanticTreeInput,\n  ComplexTreePatterns,\n  LightwightTreePatterns,\n  SingleFullSubtree,\n  SparqlNodeModel,\n  createDefaultTreeQueries,\n  KeyedForest,\n  loadPath,\n  expandPath,\n  queryMoreChildren\n} from 'platform/components/semantic/lazy-tree';\n\nimport { ItemSelected } from './LazyTreeEvents';\n\nimport * as styles from './LazyTree.scss';\n\ninterface BaseLazyTreeProps {\n  /**\n   * ID for issuing component events.\n   */\n  id?: string;\n\n  /**\n   * How many items should be loaded for every scroll page.\n   *\n   * @default 50\n   */\n  pageSize?: number;\n\n  /**\n   * Template for node additional info.\n   */\n  infoTemplate?: string;\n}\n\nexport type LazyTreeProps =\n  { type: 'simple'; config: LightwightTreePatterns } & BaseLazyTreeProps |\n  { type: 'query', config: ComplexTreePatterns } & BaseLazyTreeProps;\n\ninterface State {\n  patterns?: ComplexTreePatterns;\n  model?: SparqlNodeModel;\n  forest?: KeyedForest<Node>;\n  expandingToScroll?: boolean;\n  expandTarget?: Node;\n  highlightedPath?: KeyPath;\n  loading: boolean;\n}\n\n/**\n *   <semantic-lazy-tree id='scheme-tree' info-template='{{> template}}' type='simple' config='{\"scheme\": \"[[this]]\"}'>\n *     <template id='template'>\n *      Some additional info or actions to show together with the node\n *    </template>\n *  </semantic-lazy-tree>\n */\nexport class LazyTree extends Component<LazyTreeProps, State> {\n  private tree: LazyTreeSelector;\n  private searchedPaths = Immutable.Set<Immutable.List<string>>();\n  private readonly cancellation = new Cancellation();\n  private expandingCancellation = Cancellation.cancelled;\n\n  static defaultProps = {\n    pageSize: 50\n  }\n\n  constructor(props: LazyTreeProps, context: any) {\n    super(props, context);\n    this.state = {\n      loading: true,\n    };\n  }\n\n  componentDidMount() {\n    const patterns =\n      this.props.type === 'query' ? this.props.config :\n      createDefaultTreeQueries(this.props.config);\n    const model = new SparqlNodeModel({\n      rootsQuery: SparqlUtil.parseQuery(patterns.rootsQuery),\n      childrenQuery: SparqlUtil.parseQuery(patterns.childrenQuery),\n      parentsQuery: SparqlUtil.parseQuery(patterns.parentsQuery),\n      sparqlOptions: () => ({ context: this.context.semanticContext }),\n      limit: this.props.pageSize,\n    });\n\n    model.loadMoreChildren(Node.readyToLoadRoot).onValue(\n      node => {\n        this.setState({\n          loading: false,\n          expandingToScroll: false,\n          forest: KeyedForest.create(Node.keyOf, node),\n          patterns, model\n        });\n      }\n    );\n  }\n\n  render() {\n    if (this.state.loading) {\n      return <div>Loading</div>;\n    } else {\n      return this.renderTree();\n    }\n  }\n\n  renderTree() {\n    const { patterns, forest, expandingToScroll, highlightedPath } = this.state;\n\n    let highlightedNodes: ReadonlyArray<Node> = [];\n    if (highlightedPath) {\n      const highlightTarget = forest.fromKeyPath(highlightedPath);\n      if (highlightTarget) {\n        highlightedNodes = forest.getNodePath(highlightTarget);\n      }\n    }\n    const props: LazyTreeSelectorProps<Node> = {\n      forest,\n      isLeaf: this.isLeaf,\n      childrenOf: this.childrenOf,\n      renderItem: (node) => this.renderTreeNodeRow(node, highlightedNodes),\n      requestMore: this.requestMore,\n      hideCheckboxes: true,\n      onExpandedOrCollapsed: this.onExpandedOrCollapsed,\n      isExpanded: (node) => node.expanded,\n      selectionMode: SingleFullSubtree<Node>(),\n      onItemClick: this.onItemClick,\n    };\n\n    return (\n      <div className={styles.component}>\n        <SemanticTreeInput\n          {...patterns}\n          multipleSelection={true}\n          onSelectionClick={this.onSearchBadgeClick}\n          onSelectionChanged={this.onSearchSelectionChanged}\n        />\n        <div className={styles.alignmentTreeContainer}>\n          {expandingToScroll ? this.renderExpandToScrollMessage() : null}\n          <LazyTreeSelector {...props} ref={this.onTreeMount} className={styles.alignmentTree} />\n        </div>\n      </div>\n    );\n  }\n\n  private renderTreeNodeRow(node: Node, highlightedNodes: ReadonlyArray<Node>) {\n    const decoratorsClass = this.computeDecoratorsClass(node, highlightedNodes);\n    return (\n      <span className={styles.alignmentNodeRow}>\n        <Draggable iri={node.iri.value}>\n          {this.renderTreeNode(node, decoratorsClass)}\n        </Draggable>\n        {this.renderNodeInfoTemplate(node)}\n      </span>\n    );\n  }\n\n  private renderTreeNode(node: Node, decoratorsClass: string) {\n    const title = node.iri.value;\n    return (\n      <span className={decoratorsClass} title={title}>\n        <span>{Node.getLabel(node)}</span>\n      </span>\n    );\n  }\n\n  private renderNodeInfoTemplate(node: Node) {\n    if (this.props.infoTemplate) {\n      return <TemplateItem template={{source: this.props.infoTemplate, options: {iri: node.iri.value}}} />;\n    } else {\n      return null;\n    }\n  }\n\n  private renderExpandToScrollMessage() {\n    const { expandTarget } = this.state;\n    return (\n      <div className={styles.scrollNotification}>\n        Scrolling to item <span className={styles.scrollToName}>{expandTarget.label.value}</span>\n        <Spinner className={styles.scrollSpinner} spinnerDelay={0} messageDelay={Infinity} />\n      </div>\n    );\n  }\n\n  private computeDecoratorsClass(item: Node, highlightedNodes: ReadonlyArray<Node>): string {\n    const classes: string[] = [styles.decoratedNodeBody];\n\n    const pathIndex = highlightedNodes.indexOf(item);\n    if (pathIndex >= 0) {\n      const isTarget = pathIndex === highlightedNodes.length - 1;\n      classes.push(isTarget ? styles.decorateHighlightLeaf : styles.decorateHighlightParent);\n    }\n    return classes.join(' ');\n  }\n\n  private onTreeMount = (tree: LazyTreeSelector) => {\n    this.tree = tree;\n  };\n\n  private onSearchBadgeClick = (selection: TreeSelection<Node>, target: SelectionNode<Node>) => {\n    const path = selection.getKeyPath(target);\n    this.onExpandAndScrollToPath(path, target);\n  };\n\n  /** Auto-scroll to newly selected single path in search input. */\n  private onSearchSelectionChanged = (selection: TreeSelection<Node>) => {\n    const previousPaths = this.searchedPaths;\n    this.searchedPaths = TreeSelection.leafs(selection)\n      .map((node) => Immutable.List(selection.getKeyPath(node) as string[]))\n      .toSet();\n\n    const newlySelectedPaths = this.searchedPaths.filter((path) => !previousPaths.has(path));\n    if (newlySelectedPaths.size === 1) {\n      const path = newlySelectedPaths.first().toArray() as KeyPath;\n      this.onExpandAndScrollToPath(path, selection.fromKeyPath(path));\n    }\n  };\n\n  private onItemClick = (item: Node) => {\n    trigger({ eventType: ItemSelected, source: this.props.id, data: { iri: item.iri.value}});\n  }\n\n  private isLeaf = (item: Node) => {\n    const { model } = this.state;\n    return item.children ? item.children.length === 0 && !model.hasMoreChildren(item) : undefined;\n  };\n\n  private childrenOf = (node: Node) => {\n    const { model } = this.state;\n    const { children, loading } = node;\n    return { children, loading, hasMoreItems: model.hasMoreChildren(node) };\n  };\n\n  private requestMore = (node: Node): void => {\n    const path = this.state.forest.getKeyPath(node);\n    const { model, forest } = this.state;\n    const [loadingForest, forestChange] = queryMoreChildren((parent) => model.loadMoreChildren(parent), forest, path);\n    this.cancellation.map(forestChange).observe({\n      value: (changeForest) => {\n        this.setState({\n          forest: changeForest(forest)\n        });\n      },\n    });\n    this.setState({\n      forest: loadingForest\n    });\n  };\n\n  private onExpandedOrCollapsed = (item: Node, expanded: boolean) => {\n    const path = this.state.forest.getKeyPath(item);\n    const forest = this.state.forest.updateNode(path, (node) => TreeNode.set(node, { expanded }));\n    this.setState({ forest });\n  };\n\n  onExpandAndScrollToPath(path: KeyPath, target: Node) {\n    const onExpandingStateChanged = () => {\n      const { expandingToScroll, highlightedPath } = this.state;\n      if (!expandingToScroll && highlightedPath) {\n        this.scrollToPath(highlightedPath);\n      }\n    };\n\n\n    this.setState({\n      expandingToScroll: true,\n      expandTarget: target,\n    }, () => {\n      this.expandingCancellation = this.cancellation.deriveAndCancel(this.expandingCancellation);\n      this.expandingCancellation\n          .map(\n            loadPath(\n              (parent) => this.state.model.hasMoreChildren(parent),\n              (parent) => this.state.model.loadMoreChildren(parent),\n              this.state.forest,\n              path\n            ).map((forest) => expandPath(forest, path))\n          )\n          .observe({\n            value: (forest) => {\n              this.setState({\n                forest,\n                expandingToScroll: false,\n                highlightedPath: path,\n              }, onExpandingStateChanged);\n            },\n            error: (error) => {\n              console.error(error);\n              this.setState({\n                expandingToScroll: false,\n                highlightedPath: undefined,\n              });\n            },\n          });\n    });\n  }\n\n  cancelExpandingToScroll() {\n    if (this.state.expandingToScroll) {\n      this.expandingCancellation.cancelAll();\n      this.setState({\n        expandingToScroll: false,\n        expandTarget: undefined,\n        highlightedPath: undefined,\n      });\n    }\n  }\n\n  scrollToPath(path: KeyPath) {\n    this.tree.scrollToPath(path);\n  }\n}\n\nexport default LazyTree;\n","/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { EventMaker } from 'platform/api/events';\n\nexport interface LazyTreeEventData {\n  'LazyTree.ItemSelected': {\n    iri: string\n  }\n}\n\nconst event: EventMaker<LazyTreeEventData> = EventMaker;\nexport const ItemSelected = event('LazyTree.ItemSelected');\n"],"sourceRoot":""}