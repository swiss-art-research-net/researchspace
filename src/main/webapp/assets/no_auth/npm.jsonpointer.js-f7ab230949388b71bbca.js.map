{"version":3,"sources":["webpack:///./node_modules/jsonpointer.js/src/jsonpointer.js"],"names":["SPECIAL_CHARACTERS","NON_EMPTY_POINTER_REGEXP","ErrorMessage","getValue","context","token","unescapeReferenceToken","rawReferenceToken","character","escapeSequence","pair","replaceRegExp","referenceToken","i","length","RegExp","replace","isArray","a","Array","Object","prototype","toString","call","getError","isNumber","n","isNaN","Number","isObject","message","Error","o","isString","s","String","isUndefined","v","jsonpointer","get","getPointedValue","target","opt_pointer","JSON","parse","e","evaluator","createPointerEvaluator","cache","pointer","isValidJSONPointer","test","hasOwnProperty","tokensList","parsePointer","tokens","split","reverse","pop","value","module","exports","window","this"],"mappings":"iFAQC,WACC,aASA,IAAIA,EAAqB,CACvB,CAAC,IAAK,MACN,CAAC,IAAK,OA0BJC,EAA2B,cAQ3BC,EAEE,wDAFFA,EAGgB,8BAHhBA,EAIqB,4CAJrBA,EAKe,wBALfA,EAOE,qDAPFA,EASE,2DAgLN,SAASC,SAASC,EAASC,GAQzB,GAJAA,EAlCF,SAASC,uBAAuBC,GAW9B,IARA,IACIC,EACAC,EACAC,EACAC,EAJAC,EAAiBL,EAQZM,EAAI,EAAGA,EAAIb,EAAmBc,OAAQD,IAE7CL,GADAE,EAAOV,EAAmBa,IACT,GACjBJ,EAAiBC,EAAK,GACtBC,EAAgB,IAAII,OAAON,EAAgB,KAC3CG,EAAiBA,EAAeI,QAAQL,EAAeH,GAGzD,OAAOI,EAeCN,CAAuBD,GAwDjC,SAASY,QAAQC,GACf,OAAIC,MAAMF,QACDE,MAAMF,QAAQC,GAEwB,mBAAtCE,OAAOC,UAAUC,SAASC,KAAKL,GAxDpCD,CAAQb,GAAU,CAIpB,GAAI,MAAQC,EAGV,MAAMmB,SAAStB,GAEjB,IAoDJ,SAASuB,SAASC,GAChB,OAAQC,MAAMC,OAAOF,IArDdD,CAASpB,GAEZ,MAAMmB,SAAStB,GAEjB,GAAIG,EAAMS,OAAS,GAAK,MAAQT,EAAM,GAEpC,MAAMmB,SAAStB,GAKjB,OAAOE,EAAQC,GAGjB,GAAIwB,SAASzB,GAGX,OAAOA,EAAQC,GAgBnB,SAASmB,SAASM,GAChB,OAAO,IAAIC,MA5Pc,iBA4PeD,GAI1C,SAASD,SAASG,GAChB,MAAO,iBAAoBA,GAAK,OAASA,EAkB3C,SAASC,SAASC,GAChB,MAAO,iBAAoBA,GAAKA,aAAaC,OAI/C,SAASC,YAAYC,GACnB,YAAO,IAAuBA,EAMhC,IAAIC,EAAc,CAChBC,IA1PF,SAASC,gBAAgBC,EAAQC,GAI/B,GAAIT,SAASQ,GAGX,IAEEA,EAASE,KAAKC,MAAMH,GAEtB,MAAOI,GAEL,MAAMrB,SAAStB,QAGd,IAAK2B,SAASY,GAEjB,MAAMjB,SAAStB,GAIjB,IAAI4C,EAqBN,SAASC,uBAAuBN,GAG9B,IAAIO,EAAQ,GAEZ,OAAO,SAASC,GAEd,IAqCJ,SAASC,mBAAmBD,GAG1B,IAAKhB,SAASgB,GAEZ,OAAO,EAGT,GAAI,KAAOA,EAET,OAAO,EAKT,OAAOhD,EAAyBkD,KAAKF,GApD9BC,CAAmBD,GAEtB,MAAMzB,SAAStB,GAIjB,GAAI8C,EAAMI,eAAeH,GAEvB,OAAOD,EAAMC,GAWf,IANA,IACI5C,EADAgD,EAiDR,SAASC,aAAaL,GAKpB,IAAIM,EAASN,EAAQO,MAnKA,KAmKwBC,UAO7C,OAHAF,EAAOG,MAGAH,EA7DYD,CAAaL,GAE1BU,EAAQlB,GAIJL,YAAYuB,KAAWvB,YAAY/B,EAAQgD,EAAWK,QAG5DC,EAAQxD,SAASwD,EAAOtD,GAK1B,OADA2C,EAAMC,GAAWU,EACVA,GAvDOZ,CAAuBN,GAEvC,OAAIL,YAAYM,GAEPI,EAIAA,EAAUJ,KAkOnBkB,EAAOC,QAAUvB,IAalBf,KAAK,WACN,aACA,MAA0B,oBAAXuC,OAAyBA,OAASC,KAF3C","file":"npm.jsonpointer.js-f7ab230949388b71bbca.js","sourcesContent":["/**\n * @author Alexey Kuzmin <alex.s.kuzmin@gmail.com>\n * @fileoverview JavaScript implementation of JSON Pointer.\n * @see http://tools.ietf.org/html/rfc6901\n */\n\n\n\n;(function() {\n  'use strict';\n\n  /**\n   * List of special characters and their escape sequences.\n   * Special characters will be unescaped in order they are listed.\n   * Section 3 of spec.\n   * @type {Array.<Array.<string>>}\n   * @const\n   */\n  var SPECIAL_CHARACTERS = [\n    ['/', '~1'],\n    ['~', '~0']\n  ];\n\n\n  /**\n   * Tokens' separator in JSON pointer string.\n   * Section 3 of spec.\n   * @type {string}\n   * @const\n   */\n  var TOKENS_SEPARATOR = '/';\n\n\n  /**\n   * Prefix for error messages.\n   * @type {string}\n   * @const\n   */\n  var ERROR_MESSAGE_PREFIX = 'JSON Pointer: ';\n\n\n  /**\n   * Validates non-empty pointer string.\n   * @type {RegExp}\n   * @const\n   */\n  var NON_EMPTY_POINTER_REGEXP = /(\\/[^\\/]*)+/;\n\n\n  /**\n   * List of error messages.\n   * Please keep it in alphabetical order.\n   * @enum {string}\n   */\n  var ErrorMessage = {\n    HYPHEN_IS_NOT_SUPPORTED_IN_ARRAY_CONTEXT:\n        'Implementation does not support \"-\" token for arrays.',\n    INVALID_DOCUMENT: 'JSON document is not valid.',\n    INVALID_DOCUMENT_TYPE: 'JSON document must be a string or object.',\n    INVALID_POINTER: 'Pointer is not valid.',\n    NON_NUMBER_TOKEN_IN_ARRAY_CONTEXT:\n        'Non-number tokens cannot be used in array context.',\n    TOKEN_WITH_LEADING_ZERO_IN_ARRAY_CONTEXT:\n        'Token with leading zero cannot be used in array context.'\n  };\n\n\n  /**\n   * Returns |target| object's value pointed by |opt_pointer|, returns undefined\n   * if |opt_pointer| points to non-existing value.\n   * If pointer is not provided, validates first argument and returns\n   * evaluator function that takes pointer as argument.\n   * @param {(string|Object|Array)} target Evaluation target.\n   * @param {string=} opt_pointer JSON Pointer string.\n   * @returns {*} Some value.\n   */\n  function getPointedValue(target, opt_pointer) {\n    // .get() method implementation.\n\n    // First argument must be either string or object.\n    if (isString(target)) {\n\n      // If string it must be valid JSON document.\n      try {\n        // Let's try to parse it as JSON.\n        target = JSON.parse(target);\n      }\n      catch (e) {\n        // If parsing failed, an exception will be thrown.\n        throw getError(ErrorMessage.INVALID_DOCUMENT);\n      }\n    }\n    else if (!isObject(target)) {\n      // If not object or string, an exception will be thrown.\n      throw getError(ErrorMessage.INVALID_DOCUMENT_TYPE);\n    }\n\n    // |target| is already parsed, let's create evaluator function for it.\n    var evaluator = createPointerEvaluator(target);\n\n    if (isUndefined(opt_pointer)) {\n      // If pointer was not provided, return evaluator function.\n      return evaluator;\n    }\n    else {\n      // If pointer is provided, return evaluation result.\n      return evaluator(opt_pointer);\n    }\n  }\n\n\n  /**\n   * Returns function that takes JSON Pointer as single argument\n   * and evaluates it in given |target| context.\n   * Returned function throws an exception if pointer is not valid\n   * or any error occurs during evaluation.\n   * @param {*} target Evaluation target.\n   * @returns {Function}\n   */\n  function createPointerEvaluator(target) {\n\n    // Use cache to store already received values.\n    var cache = {};\n\n    return function(pointer) {\n\n      if (!isValidJSONPointer(pointer)) {\n        // If it's not, an exception will be thrown.\n        throw getError(ErrorMessage.INVALID_POINTER);\n      }\n\n      // First, look up in the cache.\n      if (cache.hasOwnProperty(pointer)) {\n        // If cache entry exists, return it's value.\n        return cache[pointer];\n      }\n\n      // Now, when all arguments are valid, we can start evaluation.\n      // First of all, let's convert JSON pointer string to tokens list.\n      var tokensList = parsePointer(pointer);\n      var token;\n      var value = target;\n\n      // Evaluation will be continued till tokens list is not empty\n      // and returned value is not an undefined.\n      while (!isUndefined(value) && !isUndefined(token = tokensList.pop())) {\n        // Let's evaluate token in current context.\n        // `getValue()` might throw an exception, but we won't handle it.\n        value = getValue(value, token);\n      }\n\n      // Pointer evaluation is done, save value in the cache and return it.\n      cache[pointer] = value;\n      return value;\n    };\n  }\n\n\n  /**\n   * Returns true if given |pointer| is valid, returns false otherwise.\n   * @param {!string} pointer\n   * @returns {boolean} Whether pointer is valid.\n   */\n  function isValidJSONPointer(pointer) {\n    // Validates JSON pointer string.\n\n    if (!isString(pointer)) {\n      // If it's not a string, it obviously is not valid.\n      return false;\n    }\n\n    if ('' === pointer) {\n      // If it is string and is an empty string, it's valid.\n      return true;\n    }\n\n    // If it is non-empty string, it must match spec defined format.\n    // Check Section 3 of specification for concrete syntax.\n    return NON_EMPTY_POINTER_REGEXP.test(pointer);\n  }\n\n\n  /**\n   * Returns tokens list for given |pointer|. List is reversed, e.g.\n   *     '/simple/path' -> ['path', 'simple']\n   * @param {!string} pointer JSON pointer string.\n   * @returns {Array} List of tokens.\n   */\n  function parsePointer(pointer) {\n    // Converts JSON pointer string into tokens list.\n\n    // Let's split pointer string by tokens' separator character.\n    // Also we will reverse resulting array to simplify it's further usage.\n    var tokens = pointer.split(TOKENS_SEPARATOR).reverse();\n\n    // Last item in resulting array is always an empty string,\n    // we don't need it, let's remove it.\n    tokens.pop();\n\n    // Now tokens' array is ready to use, let's return it.\n    return tokens;\n  }\n\n\n  /**\n   * Decodes all escape sequences in given |rawReferenceToken|.\n   * @param {!string} rawReferenceToken\n   * @returns {string} Unescaped reference token.\n   */\n  function unescapeReferenceToken(rawReferenceToken) {\n    // Unescapes reference token. See Section 3 of specification.\n\n    var referenceToken = rawReferenceToken;\n    var character;\n    var escapeSequence;\n    var pair;\n    var replaceRegExp;\n\n    // Order of unescaping does matter.\n    // That's why an array is used here and not hash.\n    for (var i = 0; i < SPECIAL_CHARACTERS.length; i++) {\n      pair = SPECIAL_CHARACTERS[i];\n      character = pair[0];\n      escapeSequence = pair[1];\n      replaceRegExp = new RegExp(escapeSequence, 'g');\n      referenceToken = referenceToken.replace(replaceRegExp, character);\n    }\n\n    return referenceToken;\n  }\n\n\n  /**\n   * Returns value pointed by |token| in evaluation |context|.\n   * Throws an exception if any error occurs.\n   * @param {*} context Current evaluation context.\n   * @param {!string} token Unescaped reference token.\n   * @returns {*} Some value or undefined if value if not found.\n   */\n  function getValue(context, token) {\n    // Reference token evaluation. See Section 4 of spec.\n\n    // First of all we should unescape all special characters in token.\n    token = unescapeReferenceToken(token);\n\n    // Further actions depend of context of evaluation.\n\n    if (isArray(context)) {\n      // In array context there are more strict requirements\n      // for token value.\n\n      if ('-' === token) {\n        // Token cannot be a \"-\" character,\n        // it has no sense in current implementation.\n        throw getError(ErrorMessage.HYPHEN_IS_NOT_SUPPORTED_IN_ARRAY_CONTEXT);\n      }\n      if (!isNumber(token)) {\n        // Token cannot be non-number.\n        throw getError(ErrorMessage.NON_NUMBER_TOKEN_IN_ARRAY_CONTEXT);\n      }\n      if (token.length > 1 && '0' === token[0]) {\n        // Token cannot be non-zero number with leading zero.\n        throw getError(ErrorMessage.TOKEN_WITH_LEADING_ZERO_IN_ARRAY_CONTEXT);\n      }\n      // If all conditions are met, simply return element\n      // with token's value index.\n      // It might be undefined, but it's ok.\n      return context[token];\n    }\n\n    if (isObject(context)) {\n      // In object context we can simply return element w/ key equal to token.\n      // It might be undefined, but it's ok.\n      return context[token];\n    }\n\n    // If context is not an array or an object,\n    // token evaluation is not possible.\n    // This is the expected situation and so we won't throw an error,\n    // undefined value is perfectly suitable here.\n    return;\n  }\n\n\n  /**\n   * Returns Error instance for throwing.\n   * @param {string} message Error message.\n   * @returns {Error}\n   */\n  function getError(message) {\n    return new Error(ERROR_MESSAGE_PREFIX + message);\n  }\n\n\n  function isObject(o) {\n    return 'object' === typeof o && null !== o;\n  }\n\n\n  function isArray(a) {\n    if (Array.isArray) {\n      return Array.isArray(a);\n    } else {\n      return Object.prototype.toString.call(a) === '[object Array]';\n    }\n  }\n\n\n  function isNumber(n) {\n    return !isNaN(Number(n));\n  }\n\n\n  function isString(s) {\n    return 'string' === typeof s || s instanceof String;\n  }\n\n\n  function isUndefined(v) {\n    return 'undefined' === typeof v;\n  }\n\n\n  // Let's expose API to the world.\n\n  var jsonpointer = {\n    get: getPointedValue\n  };\n\n  if ('object' === typeof exports) {\n    // If `exports` is an object, we are in Node.js context.\n    // We are supposed to act as Node.js package.\n    module.exports = jsonpointer;\n  } else if ('function' === typeof define && define.amd) {\n    // If there is global function `define()` and `define.amd` is defined,\n    // we are supposed to act as AMD module.\n    define(function() {\n      return jsonpointer;\n    });\n  } else {\n    // Last resort.\n    // Let's create global `jsonpointer` object.\n    this.jsonpointer = jsonpointer;\n  }\n\n}).call((function() {\n  'use strict';\n  return (typeof window !== 'undefined' ? window : this);\n})());\n"],"sourceRoot":""}