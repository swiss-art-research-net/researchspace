{"version":3,"sources":["webpack:///./src/main/web/components/forms/inputs/CheckboxInput.tsx"],"names":["CheckboxState","CHECKBOX_CLASS","TRUE_VALUE","Rdf","literal","FALSE_VALUE","props","context","onValueChanged","event","createNewValues","target","checked","updateValues","handler","values","errors","newValue","value","newValues","Immutable","List","push","FieldValue","fromLabeled","validate","renderCheckbox","checkboxState","className","type","onChange","Checked","ref","input","indeterminate","Indeterminate","render","getCheckboxState","size","Unchecked","first","isAtomic","equals","isEmpty","classnames","this","makeHandler","CheckboxHandler","MultipleValuesInput","CheckboxInput","appendCheckboxErrors","filter","e","kind","ErrorKind","Configuration","toList","message","definition","minOccurs","isComposite","otherErrors","Input","finalize","owner","defaultValues","createDefaultValue","Kefir","constant","assertStatic"],"mappings":"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","file":"semantic-form-checkbox-input-e5ece74c5a53ba54e90a.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport * as React from 'react';\nimport * as Kefir from 'kefir';\nimport * as Immutable from 'immutable';\nimport * as classnames from 'classnames';\n\nimport { Rdf } from 'platform/api/rdf';\n\nimport { FieldDefinition } from '../FieldDefinition';\nimport { FieldValue, ErrorKind, LabeledValue, EmptyValue, CompositeValue, FieldError } from '../FieldValues';\nimport {\n  MultipleValuesInput,\n  MultipleValuesProps,\n  MultipleValuesHandler,\n  MultipleValuesHandlerProps,\n  ValuesWithErrors,\n} from './MultipleValuesInput';\n\nconst CHECKBOX_CLASS = 'semantic-form-checkbox-input';\n\nenum CheckboxState {\n  Unchecked = 0,\n  Checked,\n  Indeterminate,\n}\n\nexport interface CheckboxInputProps extends MultipleValuesProps {\n  /**\n   * Allow to add custom css-class of Checkbox.\n   */\n  className?: string;\n}\n\nconst TRUE_VALUE = Rdf.literal(true);\nconst FALSE_VALUE = Rdf.literal(false);\n\n/**\n * The component renders as a single checkbox with binary status, i.e. to exclusively handle\n * xsd:boolean values. If the checkbox is checked will persist true^^xsd:boolean\n * and if it is unchecked it will persist to false^^xsd:boolean.\n *\n * @example\n * // default using, set type='checkbox' by default\n * <semantic-form-checkbox-input for='field-name'></semantic-form-checkbox-input>\n *\n */\nexport class CheckboxInput extends MultipleValuesInput<CheckboxInputProps, {}> {\n  constructor(props: CheckboxInputProps, context: any) {\n    super(props, context);\n  }\n\n  private onValueChanged = (event: React.ChangeEvent<HTMLInputElement>) => {\n    this.createNewValues(event.target.checked);\n  };\n\n  private createNewValues = (checked: boolean) => {\n    const { updateValues, handler } = this.props;\n    updateValues(({ values, errors }) => {\n      const newValue: LabeledValue = { value: Rdf.literal(checked) };\n      let newValues = Immutable.List<FieldValue>();\n      newValues = newValues.push(FieldValue.fromLabeled(newValue));\n      const validated = handler.validate({ values: newValues, errors: errors });\n      return validated;\n    });\n  };\n\n  private renderCheckbox = (checkboxState: CheckboxState) => {\n    const labelClass = `${CHECKBOX_CLASS}__label`;\n    const inputClass = `${CHECKBOX_CLASS}__input`;\n    const textClass = `${CHECKBOX_CLASS}__checkbox`;\n    return (\n      <label className={labelClass}>\n        <input\n          type={'checkbox'}\n          className={inputClass}\n          onChange={this.onValueChanged}\n          checked={checkboxState === CheckboxState.Checked}\n          ref={(input) => {\n            if (input) {\n              input.indeterminate = checkboxState === CheckboxState.Indeterminate;\n            }\n          }}\n        />\n        <span className={textClass}></span>\n      </label>\n    );\n  };\n\n  render() {\n    const { className, values } = this.props;\n    const checkboxState = getCheckboxState(values);\n    return (\n      <div className={classnames(className, { [CHECKBOX_CLASS]: true })}>{this.renderCheckbox(checkboxState)}</div>\n    );\n  }\n\n  static makeHandler(props: MultipleValuesHandlerProps<CheckboxInputProps>) {\n    return new CheckboxHandler(props);\n  }\n}\n\nclass CheckboxHandler implements MultipleValuesHandler {\n  private definition: FieldDefinition;\n\n  constructor(props: MultipleValuesHandlerProps<CheckboxInputProps>) {\n    this.definition = props.definition;\n  }\n\n  validate({ values, errors }: ValuesWithErrors) {\n    const otherErrors = errors.filter((e) => e.kind !== ErrorKind.Input).toList();\n    const checkboxErrors = this.appendCheckboxErrors(values, otherErrors);\n    return {\n      values: values,\n      errors: checkboxErrors,\n    };\n  }\n\n  private appendCheckboxErrors = (\n    values: Immutable.List<FieldValue>,\n    errors: Immutable.List<FieldError>\n  ): Immutable.List<FieldError> => {\n    errors = errors.filter((e) => e.kind !== ErrorKind.Configuration).toList();\n    if (values.size > 1) {\n      errors = errors.push({\n        kind: ErrorKind.Configuration,\n        message: `Uncorrect data size = ${values.size}. Should be size = 1`,\n      });\n    }\n    if (this.definition.minOccurs > 1) {\n      errors = errors.push({\n        kind: ErrorKind.Configuration,\n        message: `Uncorrect cardinality (minOccurs = ${this.definition.minOccurs}) > 1.`,\n      });\n    }\n    const value = values.first();\n    if (value && FieldValue.isComposite(value)) {\n      errors = errors.push({\n        kind: ErrorKind.Configuration,\n        message: `Uncorrect field value type = ${value.type}. Should be \"atomic\"`,\n      });\n    }\n    if (value && FieldValue.isAtomic(value)) {\n      if (!value.value.equals(TRUE_VALUE) && !value.value.equals(FALSE_VALUE)) {\n        errors = errors.push({\n          kind: ErrorKind.Configuration,\n          message: `Uncorrect datatype. Should be \"boolean\"`,\n        });\n      }\n    }\n    return errors;\n  };\n\n  finalize(\n    values: Immutable.List<FieldValue>,\n    owner: EmptyValue | CompositeValue\n  ): Kefir.Property<Immutable.List<FieldValue>> {\n    const defaultValues = createDefaultValue(values);\n    if (defaultValues) {\n      return Kefir.constant(defaultValues);\n    }\n    return Kefir.constant(values);\n  }\n}\n\nfunction getCheckboxState(values: Immutable.List<FieldValue>): CheckboxState {\n  if (values.size === 0) {\n    return CheckboxState.Unchecked;\n  } else if (values.size > 1) {\n    return CheckboxState.Indeterminate;\n  }\n\n  const value = values.first();\n  if (FieldValue.isAtomic(value)) {\n    if (value.value.equals(TRUE_VALUE)) {\n      return CheckboxState.Checked;\n    } else if (value.value.equals(FALSE_VALUE)) {\n      return CheckboxState.Unchecked;\n    }\n  } else if (FieldValue.isEmpty(value)) {\n    return CheckboxState.Unchecked;\n  }\n  return CheckboxState.Indeterminate;\n}\n\nfunction createDefaultValue(values: Immutable.List<FieldValue>): Immutable.List<FieldValue> | undefined {\n  const isDefaultValue = values.size === 0 || (values.size === 1 && FieldValue.isEmpty(values.first()));\n  if (isDefaultValue) {\n    const newValue: LabeledValue = { value: Rdf.literal(false) };\n    let newValues = Immutable.List<FieldValue>();\n    return newValues.push(FieldValue.fromLabeled(newValue));\n  }\n  return undefined;\n}\n\nMultipleValuesInput.assertStatic(CheckboxInput);\n\nexport default CheckboxInput;\n"],"sourceRoot":""}