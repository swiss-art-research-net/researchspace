{"version":3,"sources":["webpack:///./src/main/web/components/forms/inputs/PlainTextInput.ts"],"names":["ReactSelect","createFactory","props","context","hasFocus","onTextChanged","event","text","target","value","language","state","setState","setAndValidate","createValue","reformatText","languages","getAvailableLanguages","componentDidMount","this","length","requireLanguage","componentWillReceiveProps","nextProps","render","D","div","className","renderElement","renderLanguageSelect","createElement","ValidationMessages","errors","FieldValue","getErrors","isMultiline","multiline","concat","nodeLanguage","getLanguageFromNode","asRdfNode","indexOf","push","rdfNode","selectedLanguage","undefined","onLanguageChanged","key","isEmpty","empty","datatype","definition","xsdDatatype","vocabularies","xsd","_string","XsdDataTypeValidation","sameXsdDatatype","rdf","langString","Rdf","langLiteral","anyURI","iri","literal","AtomicValue","set","getStyle","dataState","DataState","Verifying","size","some","FieldError","isPreventSubmit","placeholder","createDefaultPlaceholder","style","getTextAreaStyle","onChange","FormGroup","validationState","FormControl","type","onFocus","onBlur","title","toString","readOnly","canEdit","getOptionsForLanguageSelect","options","map","lang","label","unshift","selectedOption","find","option","disabled","clearable","getPreferredLabel","toLocaleLowerCase","makeHandler","AtomicValueInput","makeAtomicHandler","node","isLiteral","borderColor","PlainTextInput","SingleValueInput","assertStatic"],"mappings":"4IAmBA,OACA,QACA,QACA,QACA,UAEA,UACMA,EAAc,EAAAC,cAAc,WAElC,QAEA,UACA,UACA,UACA,UAqBA,cAIE,wBAAYC,EAA4BC,GAAxC,MACE,YAAMD,EAAOC,IAAQ,K,OAJf,EAAAC,UAAW,EA4DX,EAAAC,cAAgB,SAACC,GACvB,IAAMC,EAAQD,EAAME,OAAeC,MAC7BC,EAAW,EAAKC,MAAMD,SAC5B,EAAKE,SAAS,CAAEL,KAAI,EAAEG,SAAQ,IAC9B,EAAKG,eAAe,EAAKC,YAAYP,EAAMG,KA3D3C,EAAKC,MAAQ,EAAKI,aAAab,GAC/B,EAAKc,UAAY,EAAKC,wB,EAsL1B,OA7LoC,8BAUlC,yBAAAC,kBAAA,WACMC,KAAKH,UAAUI,OAAS,GAAKD,KAAKjB,MAAMmB,iBAC1CF,KAAKP,SAAS,CAAEF,SAAUS,KAAKH,UAAU,MAI7C,yBAAAM,0BAAA,SAA0BC,GACnBJ,KAAKf,UACRe,KAAKP,SAASO,KAAKJ,aAAaQ,KAIpC,yBAAAC,OAAA,WACE,OAAOC,EAAEC,IACP,CAAEC,UAAW,oBACbF,EAAEC,IAAI,CAAEC,UAAW,4BAA8BR,KAAKS,gBAAiBT,KAAKU,wBAC5E,EAAAC,cAAc,EAAAC,mBAAoB,CAAEC,OAAQ,EAAAC,WAAWC,UAAUf,KAAKjB,MAAMO,WAOxE,yBAAA0B,YAAR,WACE,OAAOhB,KAAKjB,MAAMkC,YAAa,GAGzB,yBAAAnB,sBAAR,WACE,IAAID,EAAsB,GACtBG,KAAKjB,MAAMc,YACbA,EAAYA,EAAUqB,OAAOlB,KAAKjB,MAAMc,YAG1C,IACMsB,EAAeC,oBADL,EAAAN,WAAWO,UAAUrB,KAAKjB,MAAMO,QAMhD,OAJI6B,GAAgBtB,EAAUyB,QAAQH,GAAgB,GACpDtB,EAAU0B,KAAKJ,GAGVtB,GAGD,yBAAAD,aAAR,SAAqBb,GACnB,IAAMyC,EAAU,EAAAV,WAAWO,UAAUtC,EAAMO,OACrCmC,EAAmBzB,KAAKR,MAAQQ,KAAKR,MAAMD,cAAWmC,EAC5D,MAAO,CACLtC,KAAMoC,EAAUA,EAAQlC,MAAQ,GAChCC,SAAUiC,EAAUJ,oBAAoBI,GAAWC,IAW/C,yBAAAE,kBAAR,SAA0BpC,GACxB,IAAMH,EAAOY,KAAKR,MAAMJ,KACxBY,KAAKP,SAAS,CAAEL,KAAI,EAAEG,SAAUA,EAASqC,MACpC,EAAAd,WAAWe,QAAQ7B,KAAKjB,MAAMO,QAEjCU,KAAKN,eAAeM,KAAKL,YAAYP,EAAMG,EAASqC,OAIhD,yBAAAjC,YAAR,SAAoBP,EAAcG,GAChC,GAAoB,IAAhBH,EAAKa,OACP,OAAO,EAAAa,WAAWgB,MAGpB,IAMIxC,EANAyC,EAAW/B,KAAKjB,MAAMiD,WAAWC,aAAe,EAAAC,aAAaC,IAAIC,QAerE,OAdK7C,GAAY,EAAA8C,sBAAsBC,gBAAgBP,EAAU,EAAAG,aAAaK,IAAIC,cAEhFT,EAAW,EAAAG,aAAaC,IAAIC,SAK5B9C,EADEC,EACM,EAAAkD,IAAIC,YAAYtD,EAAMG,GACrB,EAAA8C,sBAAsBC,gBAAgBP,EAAU,EAAAG,aAAaC,IAAIQ,QAClE,EAAAF,IAAIG,IAAIxD,GAER,EAAAqD,IAAII,QAAQzD,EAAM2C,GAGrB,EAAAe,YAAYC,IAAI/C,KAAKjB,MAAMO,MAAO,CAAEA,MAAK,KAG1C,yBAAA0D,SAAR,WACE,GAAIhD,KAAKjB,MAAMkE,YAAc,EAAAC,UAAUC,UAAvC,CAGA,IAAM7D,EAAQU,KAAKjB,MAAMO,MACnBuB,EAAS,EAAAC,WAAWC,UAAUzB,GACpC,OAAIuB,EAAOuC,KAAO,EACTvC,EAAOwC,KAAK,EAAAC,WAAWC,iBAAmB,QAAU,eAE3D,IAII,yBAAA9C,cAAR,sBACQuB,EAAahC,KAAKjB,MAAMiD,WACxBR,EAAU,EAAAV,WAAWO,UAAUrB,KAAKjB,MAAMO,OAE1CkE,OAC8B,IAA3BxD,KAAKjB,MAAMyE,YACdxD,KAAKyD,yBAAyBzB,GAC9BhC,KAAKjB,MAAMyE,YAEjB,OAAIxD,KAAKgB,cACA,EAAAL,cAAc,UAAkB,CACrCH,UAAW,yBACXkD,MAAOC,iBAAiB3D,KAAKgD,YAC7B1D,MAAOU,KAAKR,MAAMJ,KAClBoE,YAAaA,EACbI,SAAU5D,KAAKd,gBAGV,EAAAyB,cACL,EAAAkD,UACA,CAAEC,gBAAiB9D,KAAKgD,YACxB,EAAArC,cAAc,EAAAoD,YAAa,CACzBvD,UAAW,yBACXlB,MAAOU,KAAKR,MAAMJ,KAClB4E,KAAM,OACNR,YAAaA,EACbI,SAAU5D,KAAKd,cACf+E,QAAS,WACP,EAAKhF,UAAW,GAElBiF,OAAQ,WACN,EAAKjF,UAAW,EAChB,EAAKQ,SAAS,EAAKG,aAAa,EAAKb,SAEvCoF,MAAO3C,EAAUA,EAAQ4C,gBAAa1C,EACtC2C,UAAWrE,KAAKsE,YAMhB,yBAAAC,4BAAR,SAAoC1E,GAClC,IAAM2E,EAAU3E,EAAU4E,KAAI,SAACC,GAC7B,MAAO,CAAE9C,IAAK8C,EAAMC,MAAOD,MAK7B,OAHK1E,KAAKjB,MAAMmB,iBACdsE,EAAQI,QAAQ,CAAEhD,SAAKF,EAAWiD,MAAO,gBAEpCH,GAGD,yBAAA9D,qBAAR,sBACE,KAAIV,KAAKH,UAAUI,OAAS,GAA5B,CAIA,IAAMuE,EAAUxE,KAAKuE,4BAA4BvE,KAAKH,WAChDN,EAAWS,KAAKR,MAAMD,SACtBsF,EAAiB,EAAAC,KAAKN,GAAS,SAACO,GAAW,OAAAA,EAAOnD,MAAQrC,KAEhE,OAAOV,EAAY,CAEjB2B,UAAW,6BACXoD,SAAU,SAACc,GAAS,SAAK/C,kBAAkB+C,IAC3CF,QAASA,EACTlF,MAAOuF,EACPG,SAAUR,EAAQvE,OAAS,EAC3BgF,WAAW,MAIP,yBAAAxB,yBAAR,SAAiCzB,GAC/B,MAAO,UAAU,EAAAkD,kBAAkBlD,EAAW2C,QAAU,SAASQ,oBAAmB,YAG/E,eAAAC,YAAc,EAAAC,iBAAiBC,kBACxC,eA7LA,CAAoC,EAAAD,kBA+LpC,SAASjE,oBAAoBmE,GAC3B,GAAMA,GAAQA,EAAKC,YAGnB,OAAOD,EAAKhG,SAAWgG,EAAKhG,cAAWmC,EAGzC,SAASiC,iBAAiBD,GACxB,OAAQA,GACN,IAAK,UACH,MAAO,CAAE+B,YAAa,WACxB,IAAK,QACH,MAAO,CAAEA,YAAa,WACxB,QACE,MAAO,IA7MA,EAAAC,iBAiNb,EAAAC,iBAAiBC,aAAaF,GAE9B,UAAeA","file":"semantic-form-text-input-db974d083dcdf3691854.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { createElement, createFactory, ReactElement, CSSProperties, ChangeEvent, FormEvent } from 'react';\nimport * as D from 'react-dom-factories';\nimport { FormGroup, FormControl } from 'react-bootstrap';\nimport { find } from 'lodash';\nimport TextareaAutosize from 'react-textarea-autosize';\n\nimport ReactSelectComponent from 'react-select';\nconst ReactSelect = createFactory(ReactSelectComponent);\n\nimport { Rdf, vocabularies, XsdDataTypeValidation } from 'platform/api/rdf';\n\nimport { FieldDefinition, getPreferredLabel } from '../FieldDefinition';\nimport { FieldValue, AtomicValue, EmptyValue, FieldError, DataState } from '../FieldValues';\nimport { SingleValueInput, AtomicValueInput, AtomicValueInputProps } from './SingleValueInput';\nimport { ValidationMessages } from './Decorations';\n\ninterface Language {\n  key: string;\n  value: string;\n}\n\ntype ValidationStyle = 'success' | 'warning' | 'error' | undefined;\n\nexport interface PlainTextInputProps extends AtomicValueInputProps {\n  placeholder?: string;\n  multiline?: boolean;\n  languages?: string[];\n  requireLanguage?: boolean;\n}\n\ninterface State {\n  text: string;\n  language: string;\n}\n\nexport class PlainTextInput extends AtomicValueInput<PlainTextInputProps, State> {\n  private hasFocus = false;\n  private languages: string[];\n\n  constructor(props: PlainTextInputProps, context: any) {\n    super(props, context);\n    this.state = this.reformatText(props);\n    this.languages = this.getAvailableLanguages();\n  }\n\n  componentDidMount() {\n    if (this.languages.length > 0 && this.props.requireLanguage) {\n      this.setState({ language: this.languages[0] });\n    }\n  }\n\n  componentWillReceiveProps(nextProps: PlainTextInputProps) {\n    if (!this.hasFocus) {\n      this.setState(this.reformatText(nextProps));\n    }\n  }\n\n  render() {\n    return D.div(\n      { className: 'plain-text-field' },\n      D.div({ className: 'plain-text-field__inputs' }, this.renderElement(), this.renderLanguageSelect()),\n      createElement(ValidationMessages, { errors: FieldValue.getErrors(this.props.value) })\n    );\n  }\n\n  /**\n   * Display as <input> field or <textarea>.\n   */\n  private isMultiline() {\n    return this.props.multiline || false;\n  }\n\n  private getAvailableLanguages() {\n    let languages: string[] = [];\n    if (this.props.languages) {\n      languages = languages.concat(this.props.languages);\n    }\n\n    const rdfNode = FieldValue.asRdfNode(this.props.value);\n    const nodeLanguage = getLanguageFromNode(rdfNode);\n    if (nodeLanguage && languages.indexOf(nodeLanguage) < 0) {\n      languages.push(nodeLanguage);\n    }\n\n    return languages;\n  }\n\n  private reformatText(props: PlainTextInputProps): State {\n    const rdfNode = FieldValue.asRdfNode(props.value);\n    const selectedLanguage = this.state ? this.state.language : undefined;\n    return {\n      text: rdfNode ? rdfNode.value : '',\n      language: rdfNode ? getLanguageFromNode(rdfNode) : selectedLanguage,\n    };\n  }\n\n  private onTextChanged = (event: FormEvent<FormControl> | ChangeEvent<HTMLTextAreaElement>) => {\n    const text = (event.target as any).value;\n    const language = this.state.language;\n    this.setState({ text, language });\n    this.setAndValidate(this.createValue(text, language));\n  };\n\n  private onLanguageChanged(language: Language): void {\n    const text = this.state.text;\n    this.setState({ text, language: language.key });\n    if (!FieldValue.isEmpty(this.props.value)) {\n      // create new value only if there was an old value\n      this.setAndValidate(this.createValue(text, language.key));\n    }\n  }\n\n  private createValue(text: string, language: string): AtomicValue | EmptyValue {\n    if (text.length === 0) {\n      return FieldValue.empty;\n    }\n\n    let datatype = this.props.definition.xsdDatatype || vocabularies.xsd._string;\n    if (!language && XsdDataTypeValidation.sameXsdDatatype(datatype, vocabularies.rdf.langString)) {\n      // Replace rdf:langString -> xsd:string if no language specified\n      datatype = vocabularies.xsd._string;\n    }\n\n    let value: Rdf.Node;\n    if (language) {\n      value = Rdf.langLiteral(text, language);\n    } else if (XsdDataTypeValidation.sameXsdDatatype(datatype, vocabularies.xsd.anyURI)) {\n      value = Rdf.iri(text);\n    } else {\n      value = Rdf.literal(text, datatype);\n    }\n\n    return AtomicValue.set(this.props.value, { value });\n  }\n\n  private getStyle(): ValidationStyle {\n    if (this.props.dataState === DataState.Verifying) {\n      return undefined;\n    }\n    const value = this.props.value;\n    const errors = FieldValue.getErrors(value);\n    if (errors.size > 0) {\n      return errors.some(FieldError.isPreventSubmit) ? 'error' : 'warning';\n    } else {\n      return undefined;\n    }\n  }\n\n  private renderElement(): ReactElement<any> {\n    const definition = this.props.definition;\n    const rdfNode = FieldValue.asRdfNode(this.props.value);\n\n    const placeholder =\n      typeof this.props.placeholder === 'undefined'\n        ? this.createDefaultPlaceholder(definition)\n        : this.props.placeholder;\n\n    if (this.isMultiline()) {\n      return createElement(TextareaAutosize, {\n        className: 'plain-text-field__text',\n        style: getTextAreaStyle(this.getStyle()),\n        value: this.state.text,\n        placeholder: placeholder,\n        onChange: this.onTextChanged,\n      });\n    } else {\n      return createElement(\n        FormGroup,\n        { validationState: this.getStyle() },\n        createElement(FormControl, {\n          className: 'plain-text-field__text',\n          value: this.state.text,\n          type: 'text',\n          placeholder: placeholder,\n          onChange: this.onTextChanged,\n          onFocus: () => {\n            this.hasFocus = true;\n          },\n          onBlur: () => {\n            this.hasFocus = false;\n            this.setState(this.reformatText(this.props));\n          },\n          title: rdfNode ? rdfNode.toString() : undefined,\n          readOnly: !this.canEdit,\n        })\n      );\n    }\n  }\n\n  private getOptionsForLanguageSelect(languages: string[]) {\n    const options = languages.map((lang) => {\n      return { key: lang, label: lang };\n    });\n    if (!this.props.requireLanguage) {\n      options.unshift({ key: undefined, label: 'No language' });\n    }\n    return options;\n  }\n\n  private renderLanguageSelect() {\n    if (this.languages.length < 1) {\n      return undefined;\n    }\n\n    const options = this.getOptionsForLanguageSelect(this.languages);\n    const language = this.state.language;\n    const selectedOption = find(options, (option) => option.key === language);\n\n    return ReactSelect({\n      // @TODO: add dynamic name\n      className: 'plain-text-field__language',\n      onChange: (lang) => this.onLanguageChanged(lang as Language),\n      options: options,\n      value: selectedOption,\n      disabled: options.length < 1,\n      clearable: false,\n    });\n  }\n\n  private createDefaultPlaceholder(definition: FieldDefinition): string {\n    return `Enter ${(getPreferredLabel(definition.label) || 'value').toLocaleLowerCase()} here...`;\n  }\n\n  static makeHandler = AtomicValueInput.makeAtomicHandler;\n}\n\nfunction getLanguageFromNode(node: Rdf.Node): string | undefined {\n  if (!(node && node.isLiteral())) {\n    return undefined;\n  }\n  return node.language ? node.language : undefined;\n}\n\nfunction getTextAreaStyle(style: ValidationStyle): CSSProperties {\n  switch (style) {\n    case 'warning':\n      return { borderColor: '#e99002' };\n    case 'error':\n      return { borderColor: '#d32a0e' };\n    default:\n      return {};\n  }\n}\n\nSingleValueInput.assertStatic(PlainTextInput);\n\nexport default PlainTextInput;\n"],"sourceRoot":""}