{"version":3,"sources":["webpack:///./src/main/web/components/semantic/map/SemanticMap.ts"],"names":["MAP_REF","props","context","createGeometries","markersData","geometries","forEach","marker","f","geo","undefined","_","isUndefined","readWKT","value","transformToMercator","parseFloat","setState","errorMessage","maybe","Just","setGeometry","type","getType","createLayer","features","styleCache","source","clusterSource","distance","style","size","radius","color","image","fill","text","toString","feature","get","length","geometry","getGeometry","getFeatureStyle","Math","max","min","clusterStyle","zIndex","addMarkersFromQuery","query","fixZoomLevel","stream","SparqlClient","select","semanticContext","onValue","res","m","map","results","bindings","v","mapValues","x","SparqlUtil","isSelectResultEmpty","noResults","Nothing","isLoading","updateLayers","view","getView","calculateExtent","fit","maxZoom","setZoom","onError","error","onEnd","id","trigger","eventType","BuiltInEvents","ComponentLoaded","ComponentLoading","data","layer","layers","getSource","clear","addFeatures","addLayer","createMap","renderMap","findDOMNode","refs","lng","lat","getMarkerFromMapAsElements","elementDiv","getFeaturesInExtent","getExtent","d","template","state","tupleTemplate","html","SemanticMap","createPopupContent","getProperties","doc","DOMParser","parseFromString","appendChild","body","firstChild","compileTemplatesInConfig","config","fromNullable","handleDeprecatedLayout","chain","getOrElse","appliedTemplateScope","compile","then","catch","defaultContent","link","description","componentDidMount","this","componentWillReceiveProps","componentWillMount","render","isNothing","createElement","Spinner","TemplateItem","noResultTemplate","D","div","height","width","ref","className","visibility","onClick","bind","display","ErrorNotification","initializeMarkerPopup","popup","Popup","addOverlay","on","evt","hide","setOffset","forEachFeatureAtPixel","pixel","coord","getPopupCoordinate","coordinate","getCoordinates","getInteriorPoint","polygons","getPolygons","i","polygon","intersectsCoordinate","getGeometries","getClosestPoint","popupContent","show","join","e","hasFeatureAtPixel","getTarget","cursor","transform","wkt","readGeometry","dataProjection","featureProjection","node","center","markers","window","setTimeout","controls","defaults","attributionOptions","collapsible","interactions","mouseWheelZoom","values","target","zoom","addEventListener","updateSize","viewExtent","createEmpty","extend","has","console","warn","Component","font","textBaseline","geom","stroke"],"mappings":"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","file":"semantic-map-f7455dd23fdf83afb281.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { Props, createElement } from 'react';\nimport * as D from 'react-dom-factories';\nimport { findDOMNode } from 'react-dom';\nimport * as _ from 'lodash';\nimport * as maybe from 'data.maybe';\n\nimport Map from 'ol/map';\nimport View from 'ol/view';\nimport TileLayer from 'ol/layer/tile';\nimport VectorLayer from 'ol/layer/vector';\nimport Vector from 'ol/source/vector';\nimport Cluster from 'ol/source/cluster';\nimport OSM from 'ol/source/osm';\nimport Style from 'ol/style/style';\nimport Text from 'ol/style/text';\nimport Fill from 'ol/style/fill';\nimport Circle from 'ol/style/circle';\nimport Stroke from 'ol/style/stroke';\nimport Feature from 'ol/feature';\nimport Geometry from 'ol/geom/geometry';\nimport Point from 'ol/geom/point';\nimport MultiPoint from 'ol/geom/multipoint';\nimport Polygon from 'ol/geom/polygon';\nimport MultiPolygon from 'ol/geom/multipolygon';\nimport GeometryCollection from 'ol/geom/geometrycollection';\nimport WKT from 'ol/format/wkt';\nimport proj from 'ol/proj';\nimport control from 'ol/control';\nimport interaction from 'ol/interaction';\nimport extent from 'ol/extent';\n\nimport { BuiltInEvents, trigger } from 'platform/api/events';\nimport { SparqlClient, SparqlUtil } from 'platform/api/sparql';\nimport { Component, ComponentContext } from 'platform/api/components';\n\nimport { ErrorNotification } from 'platform/components/ui/notification';\nimport { Spinner } from 'platform/components/ui/spinner';\nimport { TemplateItem } from 'platform/components/ui/template';\n\nimport * as Popup from 'ol-popup';\nimport AnimatedCluster from 'ol-ext/layer/AnimatedCluster';\n\nimport 'ol/ol.css';\nimport 'ol-popup/src/ol-popup.css';\n\ninterface Marker {\n  link?: string;\n  description?: string;\n}\n\nexport interface SemanticMapConfig {\n  /**\n   * SPARQL Select query. Query should project `lat` and `lng`, with the WKT point.\n   * Or `wkt` variable with WKT point literal.\n   *\n   * Also to use default marker template one need to project `link` with IRI of\n   * the corresponding resource and `description` with some short textual\n   * marker description text.\n   *\n   * One can customize color of the marker/polygon using `color` projection variable\n   */\n  query: string;\n\n  /**\n   * <semantic-link uri='http://help.researchspace.org/resource/FrontendTemplating'>Template</semantic-link> for marker popup. By default shows `<semantic-link>` to the resource with a short textual description\n   */\n  tupleTemplate?: string;\n\n  /**\n   * <semantic-link uri='http://help.researchspace.org/resource/FrontendTemplating'>Template</semantic-link> which is applied when query returns no results\n   */\n  noResultTemplate?: string;\n\n  /**\n   * Optional numeric zoom between 0-18 (max zoom level may vary depending on the resolution)\n   * to fix the inital map zoom.\n   * If no fixed zoom level is provided, the zoom will be calculated on the max bounding box\n   * of available markers.\n   */\n  fixZoomLevel?: number;\n\n  /**\n   * ID for issuing component events.\n   */\n  id?: string;\n}\n\nexport type SemanticMapProps = SemanticMapConfig & Props<any>;\n\ninterface MapState {\n  tupleTemplate?: Data.Maybe<HandlebarsTemplateDelegate>;\n  errorMessage: Data.Maybe<string>;\n  noResults?: boolean;\n  isLoading?: boolean;\n}\n\nconst MAP_REF = 'researchspace-map-widget';\n\nexport class SemanticMap extends Component<SemanticMapProps, MapState> {\n  private layers: { [id: string]: VectorLayer };\n  private map: Map;\n\n  constructor(props: SemanticMapProps, context: ComponentContext) {\n    super(props, context);\n    this.state = {\n      tupleTemplate: maybe.Nothing<HandlebarsTemplateDelegate>(),\n      noResults: false,\n      isLoading: true,\n      errorMessage: maybe.Nothing<string>(),\n    };\n  }\n\n  private static createPopupContent(props, tupleTemplate: Data.Maybe<HandlebarsTemplateDelegate>) {\n    let defaultContent = '';\n\n    if (_.isUndefined(props.link) === false) {\n      defaultContent += `\n          <semantic-link uri=\"${props.link}\"></semantic-link>\n          <p>${props.description}</p>\n      `;\n    }\n\n    return tupleTemplate.map((template) => template(props)).getOrElse(defaultContent);\n  }\n\n  public componentDidMount() {\n    this.createMap();\n  }\n\n  public componentWillReceiveProps(props: SemanticMapProps, context: ComponentContext) {\n    if (props.query !== this.props.query) {\n      this.addMarkersFromQuery(props, context);\n    }\n  }\n\n  public componentWillMount() {\n    this.compileTemplatesInConfig(this.props);\n  }\n\n  public render() {\n    if (!this.state.errorMessage.isNothing) {\n      return D.div(\n        { className: 'researchspace-map-widget' },\n        createElement(ErrorNotification, { errorMessage: this.state.errorMessage.get() })\n      );\n    } else if (this.state.tupleTemplate === undefined) {\n      return createElement(Spinner);\n    } else if (this.state.noResults) {\n      return createElement(TemplateItem, { template: { source: this.props.noResultTemplate } });\n    }\n    return D.div(\n      { style: { height: '100%', width: '100%' } },\n      D.div(\n        {\n          ref: MAP_REF,\n          className: 'researchspace-map-widget',\n          style: {\n            height: '100%',\n            width: '100%',\n            visibility: this.state.noResults ? 'hidden' : 'visible',\n          },\n        },\n        D.div({\n          // this div is for testing purpose only\n          className: 'researchspace-map-widget-elements',\n          ref: 'ref-map-widget-elements',\n          onClick: this.getMarkerFromMapAsElements.bind(this),\n          style: { display: 'none' },\n        })\n      ),\n      this.state.isLoading ? createElement(Spinner) : null\n    );\n  }\n\n  private initializeMarkerPopup(map) {\n    const popup = new Popup();\n    map.addOverlay(popup);\n\n    map.on('click', (evt) => {\n      // Hide existing popup and reset it's offset\n      popup.hide();\n      popup.setOffset([0, 0]);\n\n      // Attempt to find a feature in one of the visible vector layers\n      const feature = map.forEachFeatureAtPixel(evt.pixel, function (f, layer) {\n        return f;\n      });\n\n      if (feature) {\n        const geometry = feature.getGeometry();\n        const coord = getPopupCoordinate(geometry, evt.coordinate);\n        const { features = [feature] } = feature.getProperties();\n\n        const popupContent = features.map((feature) => {\n          const props = feature.getProperties();\n          return `<div>${SemanticMap.createPopupContent(props, this.state.tupleTemplate)}</div>`;\n        });\n\n        // info += \"<p>\" + props.locationtext + \"</p>\";\n        // Offset the popup so it points at the middle of the marker not the tip\n        popup.setOffset([0, -22]);\n        popup.show(coord, `<mp-template-item>${popupContent.join('')}</mp-template-item>`);\n      }\n    });\n\n    map.on('pointermove', (e) => {\n      const hasFeatureAtPixel = map.hasFeatureAtPixel(e.pixel);\n      map.getTarget().style.cursor = hasFeatureAtPixel ? 'pointer' : '';\n    });\n  }\n\n  private transformToMercator(lng: number, lat: number): [number, number] {\n    return proj.transform([lng, lat], 'EPSG:4326', 'EPSG:3857');\n  }\n\n  private readWKT(wkt: string) {\n    const format = new WKT();\n    return format.readGeometry(wkt, {\n      dataProjection: 'EPSG:4326',\n      featureProjection: 'EPSG:3857',\n    });\n  }\n\n  private createGeometries = (markersData: any[]) => {\n    const geometries: { [type: string]: Feature[] } = {};\n\n    markersData.forEach((marker) => {\n      const f = new Feature(marker);\n      let geo: Geometry = undefined;\n      if (!_.isUndefined(marker['lat']) && !_.isUndefined(marker['lng'])) {\n        geo = new Point(this.transformToMercator(parseFloat(marker['lng'].value), parseFloat(marker['lat'].value)));\n      } else if (!_.isUndefined(marker['wkt']) && _.isUndefined(geo)) {\n        geo = this.readWKT(marker['wkt'].value);\n      }\n\n      if (_.isUndefined(geo)) {\n        const msg = `Result of SPARQL Select query does have neither\n                    lat,lng nor wkt projection variable. `;\n        this.setState({ errorMessage: maybe.Just(msg) });\n      } else {\n        f.setGeometry(geo);\n\n        const type = geo.getType();\n        geometries[type] = geometries[type] ? [...geometries[type], f] : [f];\n      }\n    });\n\n    return geometries;\n  };\n\n  private createLayer = (features: Feature[], type: string): VectorLayer => {\n    const source = new Vector({ features });\n    if (type === 'Point') {\n      const clusterSource = new Cluster({ source, distance: 40 });\n      return new AnimatedCluster({\n        source: clusterSource,\n        style: getMarkerStyle(),\n        zIndex: 1, // we want to always have markers on top of polygons\n      });\n    }\n    return new VectorLayer({\n      source,\n      style: (feature: Feature) => {\n        const geometry = feature.getGeometry();\n        const color = feature.get('color');\n        return getFeatureStyle(geometry, color ? color.value : undefined);\n      },\n      zIndex: 0,\n    });\n  };\n\n  private renderMap(node, props, center, markers) {\n    window.setTimeout(() => {\n      const geometries = this.createGeometries(markers);\n      const layers = _.mapValues(geometries, this.createLayer);\n\n      const map = new Map({\n        controls: control.defaults({\n          attributionOptions: {\n            collapsible: false,\n          },\n        }),\n        interactions: interaction.defaults({ mouseWheelZoom: false }),\n        layers: [\n          new TileLayer({\n            source: new OSM(),\n          }),\n          ..._.values(layers),\n        ],\n        target: node,\n        view: new View({\n          center: this.transformToMercator(parseFloat(center.lng), parseFloat(center.lat)),\n          zoom: 1,\n        }),\n      });\n\n      this.layers = layers;\n      this.map = map;\n\n      // asynch execute query and add markers\n      this.addMarkersFromQuery(this.props, this.context);\n\n      this.initializeMarkerPopup(map);\n      // map.getView().fit(markersSource.getExtent(), map.getSize());\n\n      window.addEventListener('resize', () => {\n        map.updateSize();\n      });\n    }, 1000);\n  }\n\n  addMarkersFromQuery = (props: SemanticMapProps, context: ComponentContext) => {\n    const { query, fixZoomLevel } = props;\n\n    if (query) {\n      const stream = SparqlClient.select(query, { context: context.semanticContext });\n\n      stream.onValue((res) => {\n        const m = _.map(res.results.bindings, (v) => <any>_.mapValues(v, (x) => x));\n        if (SparqlUtil.isSelectResultEmpty(res)) {\n          this.setState({\n            noResults: true,\n            errorMessage: maybe.Nothing<string>(),\n            isLoading: false,\n          });\n        } else {\n          this.setState({\n            noResults: false,\n            errorMessage: maybe.Nothing<string>(),\n            isLoading: false,\n          });\n\n          const geometries = this.createGeometries(m);\n          this.updateLayers(geometries);\n\n          const view = this.map.getView();\n          const extent = this.calculateExtent();\n          view.fit(extent, { maxZoom: 10 });\n\n          if (fixZoomLevel) {\n            view.setZoom(fixZoomLevel);\n          }\n        }\n      });\n\n      stream.onError((error) =>\n        this.setState({\n          errorMessage: maybe.Just(error),\n          isLoading: false,\n        })\n      );\n\n      stream.onEnd(() => {\n        if (this.props.id) {\n          trigger({ eventType: BuiltInEvents.ComponentLoaded, source: this.props.id });\n        }\n      });\n\n      if (this.props.id) {\n        trigger({\n          eventType: BuiltInEvents.ComponentLoading,\n          source: this.props.id,\n          data: stream,\n        });\n      }\n    }\n  };\n\n  private updateLayers = (geometries: { [type: string]: Feature[] }) => {\n    _.forEach(geometries, (features, type) => {\n      let layer = this.layers[type];\n\n      if (layer) {\n        let source = layer.getSource();\n        if (source instanceof Cluster) {\n          source = source.getSource();\n        }\n        source.clear();\n        source.addFeatures(features);\n      } else {\n        layer = this.createLayer(features, type);\n        this.layers[type] = layer;\n        this.map.addLayer(layer);\n      }\n    });\n  };\n\n  private calculateExtent() {\n    const viewExtent = extent.createEmpty();\n\n    _.forEach(this.layers, (layer) => {\n      let source = layer.getSource();\n      if (source instanceof Cluster) {\n        source = source.getSource();\n      }\n      extent.extend(viewExtent, source.getExtent());\n    });\n\n    return viewExtent;\n  }\n\n  private createMap = () => {\n    this.renderMap(\n      findDOMNode(this.refs[MAP_REF]),\n      this.props,\n      {\n        lng: parseFloat('0'),\n        lat: parseFloat('0'),\n      },\n      []\n    );\n  };\n\n  private getMarkerFromMapAsElements = () => {\n    if (!_.isUndefined(this.layers)) {\n      _.forEach(this.layers, (layer) => {\n        const elementDiv = this.refs['ref-map-widget-elements'];\n        let source = layer.getSource();\n        if (source instanceof Cluster) {\n          source = source.getSource();\n        }\n        const features = source.getFeaturesInExtent(source.getExtent());\n        const d = findDOMNode(elementDiv);\n        const template = this.state.tupleTemplate;\n\n        _.forEach(features, (f) => {\n          const html = SemanticMap.createPopupContent(f.getProperties(), template);\n          const doc = new DOMParser().parseFromString(html, 'text/html');\n          d.appendChild(doc.body.firstChild);\n        });\n      });\n    }\n  };\n\n  private compileTemplatesInConfig = (config: SemanticMapConfig): void => {\n    const defaultTemplate = `\n        <semantic-link class=\"map-resource-link\" data-uri=\"{{link.value}}\">\n        </semantic-link>\n        <p>{{description.value}}</p>\n    `;\n\n    const template = maybe\n      .fromNullable(this.handleDeprecatedLayout(config))\n      .chain((tupleTemplate) => maybe.fromNullable(tupleTemplate))\n      .getOrElse(defaultTemplate);\n\n    this.appliedTemplateScope\n      .compile(template)\n      .then((tupleTemplate) => {\n        this.setState({\n          tupleTemplate: maybe.Just(tupleTemplate),\n          errorMessage: maybe.Nothing<string>(),\n        });\n      })\n      .catch((error) => {\n        this.setState({ errorMessage: maybe.Just(error) });\n      });\n  };\n\n  private handleDeprecatedLayout(props: SemanticMapConfig): string {\n    if (_.has(props, 'layout')) {\n      console.warn('layout property in semantic-map is deprecated, please use flat properties instead');\n      return props['layout']['tupleTemplate'];\n    } else {\n      return props.tupleTemplate;\n    }\n  }\n}\n\nfunction getMarkerStyle() {\n  const styleCache = {};\n\n  const clusterStyle = (size, radius, color) =>\n    new Style({\n      image: new Circle({\n        radius,\n        fill: new Fill({ color }),\n      }),\n      text: new Text({\n        text: size.toString(),\n        fill: new Fill({ color: '#fff' }),\n      }),\n    });\n\n  return function (feature: Feature) {\n    const features = feature.get('features');\n    const size = features.length;\n\n    const { value: color } = features[0].get('color') || { value: '#000' };\n\n    let style = styleCache[`${size}${color}`];\n    if (!style) {\n      if (size === 1) {\n        const geometry = feature.getGeometry();\n        style = getFeatureStyle(geometry, color);\n      } else {\n        const radius = Math.max(8, Math.min(size * 0.75, 20));\n        style = clusterStyle(size, radius, color);\n      }\n\n      styleCache[size] = style;\n    }\n    return [style];\n  };\n}\n\nfunction getFeatureStyle(geometry: Geometry, color: string | undefined) {\n  if (geometry instanceof Point || geometry instanceof MultiPoint) {\n    return new Style({\n      geometry,\n      text: new Text({\n        text: '\\uf041',\n        font: 'normal 22px FontAwesome',\n        textBaseline: 'bottom',\n        fill: new Fill({ color: color || '#000' }),\n      }),\n    });\n  } else if (geometry instanceof GeometryCollection) {\n    return geometry.getGeometries().map((geom) => getFeatureStyle(geom, color));\n  }\n  return new Style({\n    geometry,\n    fill: new Fill({ color: color || 'rgba(255, 255, 255, 0.5)' }),\n    stroke: new Stroke({\n      color: color || '#3399CC',\n      width: 1.25,\n    }),\n  });\n}\n\nfunction getPopupCoordinate(geometry: Geometry, coordinate: [number, number]) {\n  if (geometry instanceof Point) {\n    return geometry.getCoordinates();\n  }\n  if (geometry instanceof Polygon) {\n    return geometry.getInteriorPoint().getCoordinates();\n  } else if (geometry instanceof MultiPolygon) {\n    const polygons = geometry.getPolygons();\n    for (let i = 0; i < polygons.length; i++) {\n      const polygon = polygons[i];\n      if (polygon.intersectsCoordinate(coordinate)) {\n        return getPopupCoordinate(polygon, coordinate);\n      }\n    }\n  } else if (geometry instanceof GeometryCollection) {\n    const geometries = geometry.getGeometries();\n    for (let i = 0; i < geometries.length; i++) {\n      const geometry = geometries[i];\n      if (geometry.intersectsCoordinate(coordinate)) {\n        return getPopupCoordinate(geometry, coordinate);\n      }\n    }\n  }\n  return geometry.getClosestPoint(coordinate);\n}\n\nexport default SemanticMap;\n"],"sourceRoot":""}