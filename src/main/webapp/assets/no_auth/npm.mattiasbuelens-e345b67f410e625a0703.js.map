{"version":3,"sources":["webpack:///./node_modules/@mattiasbuelens/web-streams-polyfill/dist/ponyfill.mjs"],"names":["_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","Constructor","protoProps","staticProps","prototype","SymbolPolyfill","Symbol","iterator","description","NumberIsInteger","Number","isInteger","value","isFinite","Math","floor","noop","betterAssert","default","NumberIsNaN","isNaN","x","getCjsExportFromNamespace","n","helpers","createCommonjsModule","fn","module","exports","isFakeDetached","Call","F","V","args","TypeError","Function","apply","call","PromiseCall","Promise","resolve","reject","typeIsObject","createDataProperty","o","p","v","createArrayFromList","elements","slice","ArrayBufferCopy","dest","destOffset","src","srcOffset","Uint8Array","set","IsFiniteNonNegativeNumber","IsNonNegativeNumber","Infinity","CreateAlgorithmFromUnderlyingMethod","underlyingObject","methodName","algoArgCount","extraArgs","method","undefined","arg","fullArgs","concat","InvokeOrNoop","O","P","TransferArrayBuffer","transferredIshVersion","get","IsDetachedBuffer","ValidateAndNormalizeHighWaterMark","highWaterMark","RangeError","MakeSizeAlgorithmFromSizeFunction","size","chunk","PerformPromiseThen","promise","onFulfilled","onRejected","then","WaitForAll","promises","successSteps","failureSteps","rejected","rejectionHandler","index","fulfilledCount","total","result","Array","_loop","_i2","promiseIndex","fulfillmentHandler","WaitForAllPromise","resolvePromise","rejectPromise","successStepsWrapper","results","stepsResult","e","failureStepsWrapper","reason","helpers_1","helpers_2","helpers_3","helpers_4","helpers_5","helpers_6","helpers_7","helpers_8","helpers_9","helpers_10","helpers$1","assert","AssertionError","assert$2","utils","rethrowAssertionErrorRejection","setTimeout","require$$0","queueWithSizes","DequeueValue","container","pair","_queue","shift","_queueTotalSize","EnqueueValueWithSize","push","PeekQueueValue","ResetQueue","require$$0$1","rethrowAssertionErrorRejection$1","DequeueValue$1","EnqueueValueWithSize$1","PeekQueueValue$1","ResetQueue$1","AbortSteps","ErrorSteps","WritableStream","underlyingSink","strategy","InitializeWritableStream","this","type","sizeAlgorithm","SetUpWritableStreamDefaultControllerFromUnderlyingSink","stream","controller","create","WritableStreamDefaultController","writeAlgorithm","closeAlgorithm","abortAlgorithm","SetUpWritableStreamDefaultController","startAlgorithm","_proto","abort","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","WritableStreamAbort","getWriter","AcquireWritableStreamDefaultWriter","writableStream","CreateWritableStream","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultWriterCloseWithErrorPropagation","writer","_ownerWritableStream","state","_state","WritableStreamCloseQueuedOrInFlight","_storedError","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamDefaultWriter","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","hasOwnProperty","_promise","wasAlreadyErroring","_resolve","_reject","_reason","_wasAlreadyErroring","WritableStreamStartErroring","WritableStreamDealWithRejection","error","WritableStreamFinishErroring","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","_started","storedError","_stream$_writeRequest2","abortRequest","WritableStreamRejectCloseAndClosedPromiseIfNeeded","WritableStreamFinishInFlightClose","defaultWriterClosedPromiseResolve","_closedPromise_resolve","_closedPromise_reject","_closedPromiseState","defaultWriterClosedPromiseReject","_closedPromise","catch","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseReset","_readyPromise","_readyPromise_resolve","_readyPromise_reject","_readyPromiseState","defaultWriterReadyPromiseResolve","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseInitializeAsResolved","defaultWriterClosedPromiseInitializeAsRejected","_proto2","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultWriterAbort","close","releaseLock","write","WritableStreamDefaultWriterGetDesiredSize","WritableStreamDefaultControllerGetDesiredSize","closeRequest","WritableStreamDefaultControllerClose","WritableStreamDefaultControllerAdvanceQueueIfNeeded","WritableStreamDefaultWriterEnsureClosedPromiseRejected","defaultWriterClosedPromiseResetToRejected","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","releasedError","chunkSize","WritableStreamDefaultControllerGetChunkSize","_strategySizeAlgorithm","chunkSizeE","WritableStreamAddWriteRequest","writeRequest","WritableStreamDefaultControllerWrite","writeRecord","enqueueE","_controlledWritableStream","WritableStreamDefaultControllerGetBackpressure","_proto3","IsWritableStreamDefaultController","WritableStreamDefaultControllerError","_abortAlgorithm","WritableStreamDefaultControllerClearAlgorithms","_strategyHWM","_writeAlgorithm","_closeAlgorithm","startResult","r","WritableStreamDefaultControllerProcessClose","WritableStreamMarkCloseRequestInFlight","sinkClosePromise","WritableStreamFinishInFlightCloseWithError","WritableStreamDefaultControllerProcessWrite","WritableStreamMarkFirstWriteRequestInFlight","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","name","writableStream_5","CreateAlgorithmFromUnderlyingMethod$1","IsFiniteNonNegativeNumber$1","InvokeOrNoop$1","IsDetachedBuffer$1","TransferArrayBuffer$1","ValidateAndNormalizeHighWaterMark$1","MakeSizeAlgorithmFromSizeFunction$1","typeIsObject$1","rethrowAssertionErrorRejection$2","DequeueValue$2","EnqueueValueWithSize$2","ResetQueue$2","AcquireWritableStreamDefaultWriter$1","IsWritableStream$1","IsWritableStreamLocked$1","WritableStreamAbort$1","WritableStreamDefaultWriterCloseWithErrorPropagation$1","WritableStreamDefaultWriterRelease$1","WritableStreamDefaultWriterWrite$1","WritableStreamCloseQueuedOrInFlight$1","CancelSteps","PullSteps","ReadableStream","underlyingSource","InitializeReadableStream","String","SetUpReadableByteStreamControllerFromUnderlyingSource","underlyingByteSource","ReadableByteStreamController","pullAlgorithm","cancelAlgorithm","autoAllocateChunkSize","SetUpReadableByteStreamController","SetUpReadableStreamDefaultControllerFromUnderlyingSource","ReadableStreamDefaultController","SetUpReadableStreamDefaultController","cancel","IsReadableStream","streamBrandCheckException$1","IsReadableStreamLocked","ReadableStreamCancel","getReader","_temp","mode","AcquireReadableStreamDefaultReader","AcquireReadableStreamBYOBReader","ReadableStreamBYOBReader","pipeThrough","_ref2","_temp2","readable","_ref3","preventClose","preventAbort","preventCancel","signal","Boolean","isAbortSignal","ReadableStreamPipeTo","pipeTo","_temp3","_ref4","tee","branches","ReadableStreamTee","cloneForBranch2","reason1","reason2","branch1","branch2","resolveCancelPromise","reader","closedOrErrored","canceled1","canceled2","cancelPromise","ReadableStreamDefaultReaderRead","done","ReadableStreamDefaultControllerClose","_readableStreamController","value1","value2","ReadableStreamDefaultControllerEnqueue","CreateReadableStream","cancel1Algorithm","compositeReason","cancelResult","cancel2Algorithm","ReadableStreamDefaultControllerError","readableStream","CreateReadableByteStream","IsReadableStreamDisturbed","_disturbed","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerHasBackpressure","ReadableStreamDefaultControllerShouldCallPull","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamDefaultReader","_reader","source","shuttingDown","currentWrite","DOMException","actions","shutdownWithAction","map","action","aborted","addEventListener","isOrBecomesErrored","shutdown","isOrBecomesClosed","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","ReadableStreamReaderGenericRelease","removeEventListener","pipeLoop","resolveLoop","rejectLoop","next","pipeStep","_ref5","err","ReadableStreamAddReadIntoRequest","forAuthorCode","readIntoRequest","_forAuthorCode","_readIntoRequests","ReadableStreamAddReadRequest","readRequest","_readRequests","ReadableStreamClose","IsReadableStreamDefaultReader","_reader$_readRequests2","_reader$_readRequests3","ReadableStreamCreateReadResult","defaultReaderClosedPromiseResolve","obj","ReadableStreamError","_i4","_reader$_readRequests5","_i6","_reader$_readIntoRequ2","defaultReaderClosedPromiseReject","ReadableStreamFulfillReadRequest","ReadableStreamGetNumReadIntoRequests","ReadableStreamGetNumReadRequests","ReadableStreamHasBYOBReader","IsReadableStreamBYOBReader","ReadableStreamHasDefaultReader","ReadableStreamReaderGenericInitialize","defaultReaderBrandCheckException","_ownerReadableStream","readerLockException","ReadableStreamReaderGenericCancel","read","IsReadableByteStreamController","byobReaderBrandCheckException","view","ArrayBuffer","isView","buffer","byteLength","ReadableStreamBYOBReaderRead","ReadableByteStreamControllerPullInto","_controlledReadableByteStream","elementSize","constructor","DataView","BYTES_PER_ELEMENT","ctor","pullIntoDescriptor","byteOffset","bytesFilled","readerType","_pendingPullIntos","emptyView","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","ReadableByteStreamControllerHandleQueueDrain","_closeRequested","ReadableByteStreamControllerError","ReadableByteStreamControllerCallPullIfNeeded","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","defaultReaderClosedPromiseResetToRejected","_proto4","IsReadableStreamDefaultController","defaultControllerBrandCheckException","enqueue","_cancelAlgorithm","ReadableStreamDefaultControllerClearAlgorithms","_controlledReadableStream","ReadableStreamDefaultControllerCallPullIfNeeded","pendingPromise","_pulling","_pullAlgorithm","_pullAgain","ReadableStreamBYOBRequest","_proto5","respond","bytesWritten","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_associatedReadableByteStreamController","_view","ReadableByteStreamControllerRespond","ReadableByteStreamControllerRespondInternal","respondWithNewView","ReadableByteStreamControllerRespondWithNewView","firstDescriptor","_proto6","byteStreamControllerBrandCheckException","ReadableByteStreamControllerClose","ReadableByteStreamControllerClearAlgorithms","ReadableByteStreamControllerEnqueue","transferredBuffer","ReadableByteStreamControllerEnqueueChunkToQueue","transferredView","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","entry","viewE","_autoAllocateChunkSize","bufferE","_byobRequest","byobRequest","SetUpReadableStreamBYOBRequest","request","ReadableByteStreamControllerGetDesiredSize","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerClearPendingPullIntos","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerCommitPullIntoDescriptor","ReadableStreamFulfillReadIntoRequest","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerRespondInClosedState","ReadableByteStreamControllerRespondInReadableState","remainderSize","end","remainder","getOwnPropertyDescriptor","AbortSignal","readableStream_3","byteLengthQueuingStrategy","ByteLengthQueuingStrategy","_ref","createDataProperty$1","countQueuingStrategy","CountQueuingStrategy","InvokeOrNoop$2","CreateAlgorithmFromUnderlyingMethod$2","typeIsObject$2","ValidateAndNormalizeHighWaterMark$2","MakeSizeAlgorithmFromSizeFunction$2","CreateReadableStream$1","ReadableStreamDefaultControllerClose$1","ReadableStreamDefaultControllerEnqueue$1","ReadableStreamDefaultControllerError$1","ReadableStreamDefaultControllerGetDesiredSize$1","ReadableStreamDefaultControllerHasBackpressure$1","ReadableStreamDefaultControllerCanCloseOrEnqueue$1","CreateWritableStream$1","WritableStreamDefaultControllerErrorIfNeeded$1","TransformStream","transformer","writableStrategy","readableStrategy","writableSizeFunction","writableHighWaterMark","readableSizeFunction","readableHighWaterMark","writableType","writableSizeAlgorithm","readableType","startPromise_resolve","readableSizeAlgorithm","InitializeTransformStream","SetUpTransformStreamDefaultControllerFromTransformer","TransformStreamDefaultController","transformAlgorithm","TransformStreamDefaultControllerEnqueue","transformResultE","transformMethod","transform","flushAlgorithm","SetUpTransformStreamDefaultController","_transformStreamController","IsTransformStream","streamBrandCheckException$2","_readable","_writable","startPromise","TransformStreamDefaultSinkWriteAlgorithm","_backpressureChangePromise","TransformStreamDefaultControllerPerformTransform","TransformStreamDefaultSinkCloseAlgorithm","flushPromise","_flushAlgorithm","TransformStreamDefaultControllerClearAlgorithms","readableController","TransformStreamError","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamDefaultSourcePullAlgorithm","TransformStreamSetBackpressure","TransformStreamErrorWritableAndUnblockWrite","_backpressureChangePromise_resolve","IsTransformStreamDefaultController","defaultControllerBrandCheckException$1","TransformStreamDefaultControllerError","_controlledTransformStream","terminate","TransformStreamDefaultControllerTerminate","_transformAlgorithm","transformStream_2","CreateTransformStream"],"mappings":"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","file":"npm.mattiasbuelens-e345b67f410e625a0703.js","sourcesContent":["function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol : function (description) {\n  return \"Symbol(\" + description + \")\";\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nvar NumberIsInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n};\n\nfunction noop() {// do nothing\n}\n\n\n\nvar betterAssert = ({\n  default: noop\n});\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nvar NumberIsNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nfunction getCjsExportFromNamespace (n) {\n\treturn n && n.default || n;\n}\n\ngetCjsExportFromNamespace(betterAssert);\n\nvar helpers = createCommonjsModule(function (module, exports) {\n\n  var isFakeDetached = SymbolPolyfill('is \"detached\" for our purposes');\n\n  exports.typeIsObject = function (x) {\n    return typeof x === 'object' && x !== null || typeof x === 'function';\n  };\n\n  exports.createDataProperty = function (o, p, v) {\n    Object.defineProperty(o, p, {\n      value: v,\n      writable: true,\n      enumerable: true,\n      configurable: true\n    });\n  };\n\n  exports.createArrayFromList = function (elements) {\n    // We use arrays to represent lists, so this is basically a no-op.\n    // Do a slice though just in case we happen to depend on the unique-ness.\n    return elements.slice();\n  };\n\n  exports.ArrayBufferCopy = function (dest, destOffset, src, srcOffset, n) {\n    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n  };\n\n  exports.IsFiniteNonNegativeNumber = function (v) {\n    if (exports.IsNonNegativeNumber(v) === false) {\n      return false;\n    }\n\n    if (v === Infinity) {\n      return false;\n    }\n\n    return true;\n  };\n\n  exports.IsNonNegativeNumber = function (v) {\n    if (typeof v !== 'number') {\n      return false;\n    }\n\n    if (NumberIsNaN(v)) {\n      return false;\n    }\n\n    if (v < 0) {\n      return false;\n    }\n\n    return true;\n  };\n\n  function Call(F, V, args) {\n    if (typeof F !== 'function') {\n      throw new TypeError('Argument is not a function');\n    }\n\n    return Function.prototype.apply.call(F, V, args);\n  }\n\n  exports.Call = Call;\n\n  exports.CreateAlgorithmFromUnderlyingMethod = function (underlyingObject, methodName, algoArgCount, extraArgs) {\n    var method = underlyingObject[methodName];\n\n    if (method !== undefined) {\n      if (typeof method !== 'function') {\n        throw new TypeError(method + \" is not a method\");\n      }\n\n      switch (algoArgCount) {\n        case 0:\n          {\n            return function () {\n              return PromiseCall(method, underlyingObject, extraArgs);\n            };\n          }\n\n        case 1:\n          {\n            return function (arg) {\n              var fullArgs = [arg].concat(extraArgs);\n              return PromiseCall(method, underlyingObject, fullArgs);\n            };\n          }\n      }\n    }\n\n    return function () {\n      return Promise.resolve();\n    };\n  };\n\n  exports.InvokeOrNoop = function (O, P, args) {\n    var method = O[P];\n\n    if (method === undefined) {\n      return undefined;\n    }\n\n    return Call(method, O, args);\n  };\n\n  function PromiseCall(F, V, args) {\n    try {\n      return Promise.resolve(Call(F, V, args));\n    } catch (value) {\n      return Promise.reject(value);\n    }\n  }\n\n  exports.PromiseCall = PromiseCall; // Not implemented correctly\n\n  exports.TransferArrayBuffer = function (O) {\n    var transferredIshVersion = O.slice(); // This is specifically to fool tests that test \"is transferred\" by taking a non-zero-length\n    // ArrayBuffer and checking if its byteLength starts returning 0.\n\n    Object.defineProperty(O, 'byteLength', {\n      get: function get() {\n        return 0;\n      }\n    });\n    O[isFakeDetached] = true;\n    return transferredIshVersion;\n  }; // Not implemented correctly\n\n\n  exports.IsDetachedBuffer = function (O) {\n    return isFakeDetached in O;\n  };\n\n  exports.ValidateAndNormalizeHighWaterMark = function (highWaterMark) {\n    highWaterMark = Number(highWaterMark);\n\n    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n      throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\n    }\n\n    return highWaterMark;\n  };\n\n  exports.MakeSizeAlgorithmFromSizeFunction = function (size) {\n    if (size === undefined) {\n      return function () {\n        return 1;\n      };\n    }\n\n    if (typeof size !== 'function') {\n      throw new TypeError('size property of a queuing strategy must be a function');\n    }\n\n    return function (chunk) {\n      return size(chunk);\n    };\n  };\n\n  exports.PerformPromiseThen = function (promise, onFulfilled, onRejected) {\n    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n    // approximation.\n    return Promise.prototype.then.call(promise, onFulfilled, onRejected);\n  };\n\n  exports.WaitForAll = function (promises, successSteps, failureSteps) {\n    var rejected = false;\n\n    var rejectionHandler = function rejectionHandler(arg) {\n      if (rejected === false) {\n        rejected = true;\n        failureSteps(arg);\n      }\n    };\n\n    var index = 0;\n    var fulfilledCount = 0;\n    var total = promises.length;\n    var result = new Array(total);\n\n    var _loop = function _loop(_i2) {\n      var promise = promises[_i2];\n      var promiseIndex = index;\n\n      var fulfillmentHandler = function fulfillmentHandler(arg) {\n        result[promiseIndex] = arg;\n        ++fulfilledCount;\n\n        if (fulfilledCount === total) {\n          successSteps(result);\n        }\n      };\n\n      exports.PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n      ++index;\n    };\n\n    for (var _i2 = 0; _i2 < promises.length; _i2++) {\n      _loop(_i2);\n    }\n  };\n\n  exports.WaitForAllPromise = function (promises, successSteps, failureSteps) {\n    if (failureSteps === void 0) {\n      failureSteps = undefined;\n    }\n\n    var resolvePromise;\n    var rejectPromise;\n    var promise = new Promise(function (resolve, reject) {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n\n    if (failureSteps === undefined) {\n      failureSteps = function failureSteps(arg) {\n        throw arg;\n      };\n    }\n\n    var successStepsWrapper = function successStepsWrapper(results) {\n      try {\n        var stepsResult = successSteps(results);\n        resolvePromise(stepsResult);\n      } catch (e) {\n        rejectPromise(e);\n      }\n    };\n\n    var failureStepsWrapper = function failureStepsWrapper(reason) {\n      try {\n        var stepsResult = failureSteps(reason);\n        resolvePromise(stepsResult);\n      } catch (e) {\n        rejectPromise(e);\n      }\n    };\n\n    exports.WaitForAll(promises, successStepsWrapper, failureStepsWrapper);\n    return promise;\n  };\n});\nvar helpers_1 = helpers.typeIsObject;\nvar helpers_2 = helpers.createDataProperty;\nvar helpers_3 = helpers.createArrayFromList;\nvar helpers_4 = helpers.ArrayBufferCopy;\nvar helpers_5 = helpers.IsFiniteNonNegativeNumber;\nvar helpers_6 = helpers.IsNonNegativeNumber;\nvar helpers_7 = helpers.Call;\nvar helpers_8 = helpers.CreateAlgorithmFromUnderlyingMethod;\nvar helpers_9 = helpers.InvokeOrNoop;\nvar helpers_10 = helpers.PromiseCall;\nvar helpers_11 = helpers.TransferArrayBuffer;\nvar helpers_12 = helpers.IsDetachedBuffer;\nvar helpers_13 = helpers.ValidateAndNormalizeHighWaterMark;\nvar helpers_14 = helpers.MakeSizeAlgorithmFromSizeFunction;\nvar helpers_15 = helpers.PerformPromiseThen;\nvar helpers_16 = helpers.WaitForAll;\nvar helpers_17 = helpers.WaitForAllPromise;\n\nfunction TransferArrayBuffer(O) {\n  return O;\n} // Not implemented correctly\n\nfunction IsDetachedBuffer(O) {\n  // eslint-disable-line no-unused-vars\n  return false;\n}\n\nvar helpers$1 = ({\n  TransferArrayBuffer: TransferArrayBuffer,\n  IsDetachedBuffer: IsDetachedBuffer,\n  typeIsObject: helpers_1,\n  createDataProperty: helpers_2,\n  createArrayFromList: helpers_3,\n  ArrayBufferCopy: helpers_4,\n  IsFiniteNonNegativeNumber: helpers_5,\n  IsNonNegativeNumber: helpers_6,\n  Call: helpers_7,\n  CreateAlgorithmFromUnderlyingMethod: helpers_8,\n  InvokeOrNoop: helpers_9,\n  PromiseCall: helpers_10,\n  ValidateAndNormalizeHighWaterMark: helpers_13,\n  MakeSizeAlgorithmFromSizeFunction: helpers_14,\n  PerformPromiseThen: helpers_15,\n  WaitForAll: helpers_16,\n  WaitForAllPromise: helpers_17\n});\n\nfunction assert() {// do nothing\n}\nassert.AssertionError = noop;\n\nvar assert$1 = ({\n  default: assert\n});\n\nvar assert$2 = getCjsExportFromNamespace(assert$1);\n\nvar rethrowAssertionErrorRejection = function rethrowAssertionErrorRejection(e) {\n  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n  // expect any errors, but assertion errors are always problematic.\n  if (e && e instanceof assert$2.AssertionError) {\n    setTimeout(function () {\n      throw e;\n    }, 0);\n  }\n};\n\nvar utils = {\n  rethrowAssertionErrorRejection: rethrowAssertionErrorRejection\n};\n\nvar require$$0 = getCjsExportFromNamespace(helpers$1);\n\nvar IsFiniteNonNegativeNumber = require$$0.IsFiniteNonNegativeNumber;\n\nvar DequeueValue = function DequeueValue(container) {\n  var pair = container._queue.shift();\n\n  container._queueTotalSize -= pair.size;\n\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n};\n\nvar EnqueueValueWithSize = function EnqueueValueWithSize(container, value, size) {\n  size = Number(size);\n\n  if (!IsFiniteNonNegativeNumber(size)) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({\n    value: value,\n    size: size\n  });\n\n  container._queueTotalSize += size;\n};\n\nvar PeekQueueValue = function PeekQueueValue(container) {\n  var pair = container._queue[0];\n  return pair.value;\n};\n\nvar ResetQueue = function ResetQueue(container) {\n  container._queue = [];\n  container._queueTotalSize = 0;\n};\n\nvar queueWithSizes = {\n  DequeueValue: DequeueValue,\n  EnqueueValueWithSize: EnqueueValueWithSize,\n  PeekQueueValue: PeekQueueValue,\n  ResetQueue: ResetQueue\n};\n\n\n\nvar debug = ({\n  default: noop\n});\n\nvar require$$0$1 = getCjsExportFromNamespace(debug);\n\n// and do not appear in the standard text.\n\n\nvar verbose = require$$0$1('streams:writable-stream:verbose');\nvar CreateAlgorithmFromUnderlyingMethod = require$$0.CreateAlgorithmFromUnderlyingMethod,\n    InvokeOrNoop = require$$0.InvokeOrNoop,\n    ValidateAndNormalizeHighWaterMark = require$$0.ValidateAndNormalizeHighWaterMark,\n    IsNonNegativeNumber = require$$0.IsNonNegativeNumber,\n    MakeSizeAlgorithmFromSizeFunction = require$$0.MakeSizeAlgorithmFromSizeFunction,\n    typeIsObject = require$$0.typeIsObject;\nvar rethrowAssertionErrorRejection$1 = utils.rethrowAssertionErrorRejection;\nvar DequeueValue$1 = queueWithSizes.DequeueValue,\n    EnqueueValueWithSize$1 = queueWithSizes.EnqueueValueWithSize,\n    PeekQueueValue$1 = queueWithSizes.PeekQueueValue,\n    ResetQueue$1 = queueWithSizes.ResetQueue;\nvar AbortSteps = SymbolPolyfill('[[AbortSteps]]');\nvar ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\n\nvar WritableStream =\n/*#__PURE__*/\nfunction () {\n  function WritableStream(underlyingSink, strategy) {\n    if (underlyingSink === void 0) {\n      underlyingSink = {};\n    }\n\n    if (strategy === void 0) {\n      strategy = {};\n    }\n\n    InitializeWritableStream(this);\n    var size = strategy.size;\n    var highWaterMark = strategy.highWaterMark;\n    var type = underlyingSink.type;\n\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    var sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n\n    if (highWaterMark === undefined) {\n      highWaterMark = 1;\n    }\n\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  var _proto = WritableStream.prototype;\n\n  _proto.abort = function abort(reason) {\n    if (IsWritableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  };\n\n  _proto.getWriter = function getWriter() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  };\n\n  _createClass(WritableStream, [{\n    key: \"locked\",\n    get: function get() {\n      if (IsWritableStream(this) === false) {\n        throw streamBrandCheckException('locked');\n      }\n\n      return IsWritableStreamLocked(this);\n    }\n  }]);\n\n  return WritableStream;\n}();\n\nvar writableStream = {\n  AcquireWritableStreamDefaultWriter: AcquireWritableStreamDefaultWriter,\n  CreateWritableStream: CreateWritableStream,\n  IsWritableStream: IsWritableStream,\n  IsWritableStreamLocked: IsWritableStreamLocked,\n  WritableStream: WritableStream,\n  WritableStreamAbort: WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded: WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation: WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease: WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite: WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight: WritableStreamCloseQueuedOrInFlight\n}; // Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter(stream) {\n  return new WritableStreamDefaultWriter(stream);\n} // Throws if and only if startAlgorithm throws.\n\n\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  if (highWaterMark === void 0) {\n    highWaterMark = 1;\n  }\n\n  if (sizeAlgorithm === void 0) {\n    sizeAlgorithm = function sizeAlgorithm() {\n      return 1;\n    };\n  }\n\n  var stream = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n  var controller = Object.create(WritableStreamDefaultController.prototype);\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream(stream) {\n  stream._state = 'writable'; // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n\n  stream._storedError = undefined;\n  stream._writer = undefined; // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n\n  stream._writableStreamController = undefined; // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n\n  stream._writeRequests = []; // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n\n  stream._inFlightWriteRequest = undefined; // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n\n  stream._closeRequest = undefined; // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n\n  stream._inFlightCloseRequest = undefined; // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n\n  stream._pendingAbortRequest = undefined; // The backpressure signal set by the controller.\n\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsWritableStreamLocked(stream) {\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream, reason) {\n  var state = stream._state;\n\n  if (state === 'closed' || state === 'errored') {\n    return Promise.resolve(undefined);\n  }\n\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  var wasAlreadyErroring = false;\n\n  if (state === 'erroring') {\n    wasAlreadyErroring = true; // reason will not be used, so don't keep a reference to it.\n\n    reason = undefined;\n  }\n\n  var promise = new Promise(function (resolve, reject) {\n    stream._pendingAbortRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest._promise = promise;\n\n  if (wasAlreadyErroring === false) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n} // WritableStream API exposed for controllers.\n\n\nfunction WritableStreamAddWriteRequest(stream) {\n  var promise = new Promise(function (resolve, reject) {\n    var writeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream, error) {\n  var state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream, reason) {\n  var controller = stream._writableStreamController;\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  var writer = stream._writer;\n\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream) {\n  stream._state = 'errored';\n\n  stream._writableStreamController[ErrorSteps]();\n\n  var storedError = stream._storedError;\n\n  for (var _i2 = 0, _stream$_writeRequest2 = stream._writeRequests; _i2 < _stream$_writeRequest2.length; _i2++) {\n    var writeRequest = _stream$_writeRequest2[_i2];\n\n    writeRequest._reject(storedError);\n  }\n\n  stream._writeRequests = [];\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  var abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring === true) {\n    abortRequest._reject(storedError);\n\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n\n  promise.then(function () {\n    abortRequest._resolve();\n\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n  }, function (reason) {\n    abortRequest._reject(reason);\n\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n  });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream) {\n  stream._inFlightWriteRequest._resolve(undefined);\n\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n  stream._inFlightWriteRequest._reject(error);\n\n  stream._inFlightWriteRequest = undefined;\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream) {\n  stream._inFlightCloseRequest._resolve(undefined);\n\n  stream._inFlightCloseRequest = undefined;\n  var state = stream._state;\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n  var writer = stream._writer;\n\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n  stream._inFlightCloseRequest._reject(error);\n\n  stream._inFlightCloseRequest = undefined; // Never execute sink abort() after sink close().\n\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n\n    stream._pendingAbortRequest = undefined;\n  }\n\n  WritableStreamDealWithRejection(stream, error);\n} // TODO(ricea): Fix alphabetical order.\n\n\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  if (stream._closeRequest !== undefined) {\n    stream._closeRequest._reject(stream._storedError);\n\n    stream._closeRequest = undefined;\n  }\n\n  var writer = stream._writer;\n\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n\n    writer._closedPromise.catch(function () {});\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n  var writer = stream._writer;\n\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure === true) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\nvar WritableStreamDefaultWriter =\n/*#__PURE__*/\nfunction () {\n  function WritableStreamDefaultWriter(stream) {\n    if (IsWritableStream(stream) === false) {\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\n    }\n\n    if (IsWritableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n    var state = stream._state;\n\n    if (state === 'writable') {\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n\n      this._readyPromise.catch(function () {});\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      var storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n\n      this._readyPromise.catch(function () {});\n\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n\n      this._closedPromise.catch(function () {});\n    }\n  }\n\n  var _proto2 = WritableStreamDefaultWriter.prototype;\n\n  _proto2.abort = function abort(reason) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  };\n\n  _proto2.close = function close() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('close'));\n    }\n\n    var stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return Promise.reject(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  };\n\n  _proto2.releaseLock = function releaseLock() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    var stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    WritableStreamDefaultWriterRelease(this);\n  };\n\n  _proto2.write = function write(chunk) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  };\n\n  _createClass(WritableStreamDefaultWriter, [{\n    key: \"closed\",\n    get: function get() {\n      if (IsWritableStreamDefaultWriter(this) === false) {\n        return Promise.reject(defaultWriterBrandCheckException('closed'));\n      }\n\n      return this._closedPromise;\n    }\n  }, {\n    key: \"desiredSize\",\n    get: function get() {\n      if (IsWritableStreamDefaultWriter(this) === false) {\n        throw defaultWriterBrandCheckException('desiredSize');\n      }\n\n      if (this._ownerWritableStream === undefined) {\n        throw defaultWriterLockException('desiredSize');\n      }\n\n      return WritableStreamDefaultWriterGetDesiredSize(this);\n    }\n  }, {\n    key: \"ready\",\n    get: function get() {\n      if (IsWritableStreamDefaultWriter(this) === false) {\n        return Promise.reject(defaultWriterBrandCheckException('ready'));\n      }\n\n      return this._readyPromise;\n    }\n  }]);\n\n  return WritableStreamDefaultWriter;\n}(); // Abstract operations for the WritableStreamDefaultWriter.\n\n\nfunction IsWritableStreamDefaultWriter(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return true;\n} // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\n\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n  var stream = writer._ownerWritableStream;\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer) {\n  var stream = writer._ownerWritableStream;\n  var state = stream._state;\n\n  if (state === 'closed' || state === 'errored') {\n    return Promise.reject(new TypeError(\"The stream (in \" + state + \" state) is not in the writable state and cannot be closed\"));\n  }\n\n  var promise = new Promise(function (resolve, reject) {\n    var closeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n    stream._closeRequest = closeRequest;\n  });\n\n  if (stream._backpressure === true && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n  return promise;\n}\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  var stream = writer._ownerWritableStream;\n  var state = stream._state;\n\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.resolve();\n  }\n\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n\n  writer._closedPromise.catch(function () {});\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n\n  writer._readyPromise.catch(function () {});\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n  var stream = writer._ownerWritableStream;\n  var state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer) {\n  var stream = writer._ownerWritableStream;\n  var releasedError = new TypeError('Writer was released and can no longer be used to monitor the stream\\'s closedness');\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError); // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined;\n}\n\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n  var stream = writer._ownerWritableStream;\n  var controller = stream._writableStreamController;\n  var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return Promise.reject(defaultWriterLockException('write to'));\n  }\n\n  var state = stream._state;\n\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n\n  if (state === 'erroring') {\n    return Promise.reject(stream._storedError);\n  }\n\n  var promise = WritableStreamAddWriteRequest(stream);\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n  return promise;\n}\n\nvar WritableStreamDefaultController =\n/*#__PURE__*/\nfunction () {\n  function WritableStreamDefaultController() {\n    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\n  }\n\n  var _proto3 = WritableStreamDefaultController.prototype;\n\n  _proto3.error = function error(e) {\n    if (IsWritableStreamDefaultController(this) === false) {\n      throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n    }\n\n    var state = this._controlledWritableStream._state;\n\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  };\n\n  _proto3[AbortSteps] = function (reason) {\n    var result = this._abortAlgorithm(reason);\n\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  };\n\n  _proto3[ErrorSteps] = function () {\n    ResetQueue$1(this);\n  };\n\n  return WritableStreamDefaultController;\n}(); // Abstract operations implementing interface required by the WritableStream.\n\n\nfunction IsWritableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller; // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue$1(controller);\n  controller._started = false;\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n  var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n  var startResult = startAlgorithm();\n  var startPromise = Promise.resolve(startResult);\n  startPromise.then(function () {\n    controller._started = true;\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n  }, function (r) {\n    controller._started = true;\n    WritableStreamDealWithRejection(stream, r);\n  }).catch(rethrowAssertionErrorRejection$1);\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n  var controller = Object.create(WritableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSink, 'start', [controller]);\n  }\n\n  var writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\n  var closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\n  var abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n} // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n\n\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._writeAlgorithm = undefined;\n  controller._closeAlgorithm = undefined;\n  controller._abortAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n}\n\nfunction WritableStreamDefaultControllerClose(controller) {\n  EnqueueValueWithSize$1(controller, 'close', 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n  var writeRecord = {\n    chunk: chunk\n  };\n\n  try {\n    EnqueueValueWithSize$1(controller, writeRecord, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  var stream = controller._controlledWritableStream;\n\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\n    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n} // Abstract operations for the WritableStreamDefaultController.\n\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  var stream = controller._controlledWritableStream;\n\n  if (controller._started === false) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  var state = stream._state;\n\n  if (state === 'closed' || state === 'errored') {\n    return;\n  }\n\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  var writeRecord = PeekQueueValue$1(controller);\n\n  if (writeRecord === 'close') {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n  var stream = controller._controlledWritableStream;\n  WritableStreamMarkCloseRequestInFlight(stream);\n  DequeueValue$1(controller);\n\n  var sinkClosePromise = controller._closeAlgorithm();\n\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  sinkClosePromise.then(function () {\n    WritableStreamFinishInFlightClose(stream);\n  }, function (reason) {\n    WritableStreamFinishInFlightCloseWithError(stream, reason);\n  }).catch(rethrowAssertionErrorRejection$1);\n}\n\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n  var stream = controller._controlledWritableStream;\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  var sinkWritePromise = controller._writeAlgorithm(chunk);\n\n  sinkWritePromise.then(function () {\n    WritableStreamFinishInFlightWrite(stream);\n    var state = stream._state;\n    DequeueValue$1(controller);\n\n    if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\n      var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n      WritableStreamUpdateBackpressure(stream, backpressure);\n    }\n\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n  }, function (reason) {\n    if (stream._state === 'writable') {\n      WritableStreamDefaultControllerClearAlgorithms(controller);\n    }\n\n    WritableStreamFinishInFlightWriteWithError(stream, reason);\n  }).catch(rethrowAssertionErrorRejection$1);\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n  var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n} // A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\n\nfunction WritableStreamDefaultControllerError(controller, error) {\n  var stream = controller._controlledWritableStream;\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n} // Helper functions for the WritableStream.\n\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(\"WritableStream.prototype.\" + name + \" can only be used on a WritableStream\");\n} // Helper functions for the WritableStreamDefaultWriter.\n\n\nfunction defaultWriterBrandCheckException(name) {\n  return new TypeError(\"WritableStreamDefaultWriter.prototype.\" + name + \" can only be used on a WritableStreamDefaultWriter\");\n}\n\nfunction defaultWriterLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer) {\n  writer._closedPromise = new Promise(function (resolve, reject) {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  writer._closedPromise = Promise.resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n  writer._closedPromise_reject(reason);\n\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResolve(writer) {\n  writer._closedPromise_resolve(undefined);\n\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer) {\n  writer._readyPromise = new Promise(function (resolve, reject) {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  writer._readyPromise = Promise.resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n  writer._readyPromise_reject(reason);\n\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer) {\n  writer._readyPromise = new Promise(function (resolve, reject) {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseResolve(writer) {\n  writer._readyPromise_resolve(undefined);\n\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\nvar writableStream_5 = writableStream.WritableStream;\n\n/* global AbortSignal:false */\n\n\nvar ArrayBufferCopy = require$$0.ArrayBufferCopy,\n    CreateAlgorithmFromUnderlyingMethod$1 = require$$0.CreateAlgorithmFromUnderlyingMethod,\n    IsFiniteNonNegativeNumber$1 = require$$0.IsFiniteNonNegativeNumber,\n    InvokeOrNoop$1 = require$$0.InvokeOrNoop,\n    IsDetachedBuffer$1 = require$$0.IsDetachedBuffer,\n    TransferArrayBuffer$1 = require$$0.TransferArrayBuffer,\n    ValidateAndNormalizeHighWaterMark$1 = require$$0.ValidateAndNormalizeHighWaterMark,\n    IsNonNegativeNumber$1 = require$$0.IsNonNegativeNumber,\n    MakeSizeAlgorithmFromSizeFunction$1 = require$$0.MakeSizeAlgorithmFromSizeFunction,\n    createArrayFromList = require$$0.createArrayFromList,\n    typeIsObject$1 = require$$0.typeIsObject,\n    WaitForAllPromise = require$$0.WaitForAllPromise;\nvar rethrowAssertionErrorRejection$2 = utils.rethrowAssertionErrorRejection;\nvar DequeueValue$2 = queueWithSizes.DequeueValue,\n    EnqueueValueWithSize$2 = queueWithSizes.EnqueueValueWithSize,\n    ResetQueue$2 = queueWithSizes.ResetQueue;\nvar AcquireWritableStreamDefaultWriter$1 = writableStream.AcquireWritableStreamDefaultWriter,\n    IsWritableStream$1 = writableStream.IsWritableStream,\n    IsWritableStreamLocked$1 = writableStream.IsWritableStreamLocked,\n    WritableStreamAbort$1 = writableStream.WritableStreamAbort,\n    WritableStreamDefaultWriterCloseWithErrorPropagation$1 = writableStream.WritableStreamDefaultWriterCloseWithErrorPropagation,\n    WritableStreamDefaultWriterRelease$1 = writableStream.WritableStreamDefaultWriterRelease,\n    WritableStreamDefaultWriterWrite$1 = writableStream.WritableStreamDefaultWriterWrite,\n    WritableStreamCloseQueuedOrInFlight$1 = writableStream.WritableStreamCloseQueuedOrInFlight;\nvar CancelSteps = SymbolPolyfill('[[CancelSteps]]');\nvar PullSteps = SymbolPolyfill('[[PullSteps]]');\n\nvar ReadableStream =\n/*#__PURE__*/\nfunction () {\n  function ReadableStream(underlyingSource, strategy) {\n    if (underlyingSource === void 0) {\n      underlyingSource = {};\n    }\n\n    if (strategy === void 0) {\n      strategy = {};\n    }\n\n    InitializeReadableStream(this);\n    var size = strategy.size;\n    var highWaterMark = strategy.highWaterMark;\n    var type = underlyingSource.type;\n    var typeString = String(type);\n\n    if (typeString === 'bytes') {\n      if (size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n\n      if (highWaterMark === undefined) {\n        highWaterMark = 0;\n      }\n\n      highWaterMark = ValidateAndNormalizeHighWaterMark$1(highWaterMark);\n      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n    } else if (type === undefined) {\n      var sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction$1(size);\n\n      if (highWaterMark === undefined) {\n        highWaterMark = 1;\n      }\n\n      highWaterMark = ValidateAndNormalizeHighWaterMark$1(highWaterMark);\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n    } else {\n      throw new RangeError('Invalid type is specified');\n    }\n  }\n\n  var _proto = ReadableStream.prototype;\n\n  _proto.cancel = function cancel(reason) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException$1('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  };\n\n  _proto.getReader = function getReader(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        mode = _ref.mode;\n\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException$1('getReader');\n    }\n\n    if (mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    mode = String(mode);\n\n    if (mode === 'byob') {\n      return AcquireReadableStreamBYOBReader(this);\n    }\n\n    throw new RangeError('Invalid mode is specified');\n  };\n\n  _proto.pipeThrough = function pipeThrough(_ref2, _temp2) {\n    var writable = _ref2.writable,\n        readable = _ref2.readable;\n\n    var _ref3 = _temp2 === void 0 ? {} : _temp2,\n        preventClose = _ref3.preventClose,\n        preventAbort = _ref3.preventAbort,\n        preventCancel = _ref3.preventCancel,\n        signal = _ref3.signal;\n\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException$1('pipeThrough');\n    }\n\n    if (IsWritableStream$1(writable) === false) {\n      throw new TypeError('writable argument to pipeThrough must be a WritableStream');\n    }\n\n    if (IsReadableStream(readable) === false) {\n      throw new TypeError('readable argument to pipeThrough must be a ReadableStream');\n    }\n\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    if (signal !== undefined && !isAbortSignal(signal)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough\\'s signal option must be an AbortSignal');\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n    }\n\n    if (IsWritableStreamLocked$1(writable) === true) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n    }\n\n    var promise = ReadableStreamPipeTo(this, writable, preventClose, preventAbort, preventCancel, signal);\n    promise.catch(function () {});\n    return readable;\n  };\n\n  _proto.pipeTo = function pipeTo(dest, _temp3) {\n    var _ref4 = _temp3 === void 0 ? {} : _temp3,\n        preventClose = _ref4.preventClose,\n        preventAbort = _ref4.preventAbort,\n        preventCancel = _ref4.preventCancel,\n        signal = _ref4.signal;\n\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException$1('pipeTo'));\n    }\n\n    if (IsWritableStream$1(dest) === false) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\n    }\n\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    if (signal !== undefined && !isAbortSignal(signal)) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo\\'s signal option must be an AbortSignal'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n    }\n\n    if (IsWritableStreamLocked$1(dest) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n    }\n\n    return ReadableStreamPipeTo(this, dest, preventClose, preventAbort, preventCancel, signal);\n  };\n\n  _proto.tee = function tee() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException$1('tee');\n    }\n\n    var branches = ReadableStreamTee(this, false);\n    return createArrayFromList(branches);\n  };\n\n  _createClass(ReadableStream, [{\n    key: \"locked\",\n    get: function get() {\n      if (IsReadableStream(this) === false) {\n        throw streamBrandCheckException$1('locked');\n      }\n\n      return IsReadableStreamLocked(this);\n    }\n  }]);\n\n  return ReadableStream;\n}();\n\nvar readableStream = {\n  CreateReadableByteStream: CreateReadableByteStream,\n  CreateReadableStream: CreateReadableStream,\n  ReadableStream: ReadableStream,\n  IsReadableStreamDisturbed: IsReadableStreamDisturbed,\n  ReadableStreamDefaultControllerClose: ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue: ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError: ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize: ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure: ReadableStreamDefaultControllerHasBackpressure,\n  ReadableStreamDefaultControllerCanCloseOrEnqueue: ReadableStreamDefaultControllerCanCloseOrEnqueue\n}; // Abstract operations for the ReadableStream.\n\nfunction AcquireReadableStreamBYOBReader(stream) {\n  return new ReadableStreamBYOBReader(stream);\n}\n\nfunction AcquireReadableStreamDefaultReader(stream) {\n  return new ReadableStreamDefaultReader(stream);\n} // Throws if and only if startAlgorithm throws.\n\n\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  if (highWaterMark === void 0) {\n    highWaterMark = 1;\n  }\n\n  if (sizeAlgorithm === void 0) {\n    sizeAlgorithm = function sizeAlgorithm() {\n      return 1;\n    };\n  }\n\n  var stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n  var controller = Object.create(ReadableStreamDefaultController.prototype);\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n} // Throws if and only if startAlgorithm throws.\n\n\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n  if (highWaterMark === void 0) {\n    highWaterMark = 0;\n  }\n\n  if (autoAllocateChunkSize === void 0) {\n    autoAllocateChunkSize = undefined;\n  }\n\n  var stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n  var controller = Object.create(ReadableByteStreamController.prototype);\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n  return stream;\n}\n\nfunction InitializeReadableStream(stream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nfunction IsReadableStream(x) {\n  if (!typeIsObject$1(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDisturbed(stream) {\n  return stream._disturbed;\n}\n\nfunction IsReadableStreamLocked(stream) {\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n  var reader = AcquireReadableStreamDefaultReader(source);\n  var writer = AcquireWritableStreamDefaultWriter$1(dest);\n  var shuttingDown = false; // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n\n  var currentWrite = Promise.resolve();\n  return new Promise(function (resolve, reject) {\n    var abortAlgorithm;\n\n    if (signal !== undefined) {\n      abortAlgorithm = function abortAlgorithm() {\n        var error = new DOMException('Aborted', 'AbortError');\n        var actions = [];\n\n        if (preventAbort === false) {\n          actions.push(function () {\n            if (dest._state === 'writable') {\n              return WritableStreamAbort$1(dest, error);\n            }\n\n            return Promise.resolve();\n          });\n        }\n\n        if (preventCancel === false) {\n          actions.push(function () {\n            if (source._state === 'readable') {\n              return ReadableStreamCancel(source, error);\n            }\n\n            return Promise.resolve();\n          });\n        }\n\n        shutdownWithAction(function () {\n          return WaitForAllPromise(actions.map(function (action) {\n            return action();\n          }), function (results) {\n            return results;\n          });\n        }, true, error);\n      };\n\n      if (signal.aborted === true) {\n        abortAlgorithm();\n        return;\n      }\n\n      signal.addEventListener('abort', abortAlgorithm);\n    } // Using reader and writer, read all chunks from this and write them to dest\n    // - Backpressure must be enforced\n    // - Shutdown must stop all activity\n\n\n    function pipeLoop() {\n      return new Promise(function (resolveLoop, rejectLoop) {\n        function next(done) {\n          if (done) {\n            resolveLoop();\n          } else {\n            pipeStep().then(next, rejectLoop);\n          }\n        }\n\n        next(false);\n      });\n    }\n\n    function pipeStep() {\n      if (shuttingDown === true) {\n        return Promise.resolve(true);\n      }\n\n      return writer._readyPromise.then(function () {\n        return ReadableStreamDefaultReaderRead(reader).then(function (_ref5) {\n          var value = _ref5.value,\n              done = _ref5.done;\n\n          if (done === true) {\n            return true;\n          }\n\n          currentWrite = WritableStreamDefaultWriterWrite$1(writer, value).catch(function () {});\n          return false;\n        });\n      });\n    } // Errors must be propagated forward\n\n\n    isOrBecomesErrored(source, reader._closedPromise, function (storedError) {\n      if (preventAbort === false) {\n        shutdownWithAction(function () {\n          return WritableStreamAbort$1(dest, storedError);\n        }, true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n    }); // Errors must be propagated backward\n\n    isOrBecomesErrored(dest, writer._closedPromise, function (storedError) {\n      if (preventCancel === false) {\n        shutdownWithAction(function () {\n          return ReadableStreamCancel(source, storedError);\n        }, true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n    }); // Closing must be propagated forward\n\n    isOrBecomesClosed(source, reader._closedPromise, function () {\n      if (preventClose === false) {\n        shutdownWithAction(function () {\n          return WritableStreamDefaultWriterCloseWithErrorPropagation$1(writer);\n        });\n      } else {\n        shutdown();\n      }\n    }); // Closing must be propagated backward\n\n    if (WritableStreamCloseQueuedOrInFlight$1(dest) === true || dest._state === 'closed') {\n      var destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n      if (preventCancel === false) {\n        shutdownWithAction(function () {\n          return ReadableStreamCancel(source, destClosed);\n        }, true, destClosed);\n      } else {\n        shutdown(true, destClosed);\n      }\n    }\n\n    pipeLoop().catch(function (err) {\n      currentWrite = Promise.resolve();\n      rethrowAssertionErrorRejection$2(err);\n    });\n\n    function waitForWritesToFinish() {\n      // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n      // for that too.\n      var oldCurrentWrite = currentWrite;\n      return currentWrite.then(function () {\n        return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined;\n      });\n    }\n\n    function isOrBecomesErrored(stream, promise, action) {\n      if (stream._state === 'errored') {\n        action(stream._storedError);\n      } else {\n        promise.catch(action).catch(rethrowAssertionErrorRejection$2);\n      }\n    }\n\n    function isOrBecomesClosed(stream, promise, action) {\n      if (stream._state === 'closed') {\n        action();\n      } else {\n        promise.then(action).catch(rethrowAssertionErrorRejection$2);\n      }\n    }\n\n    function shutdownWithAction(action, originalIsError, originalError) {\n      if (shuttingDown === true) {\n        return;\n      }\n\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight$1(dest) === false) {\n        waitForWritesToFinish().then(doTheRest);\n      } else {\n        doTheRest();\n      }\n\n      function doTheRest() {\n        action().then(function () {\n          return finalize(originalIsError, originalError);\n        }, function (newError) {\n          return finalize(true, newError);\n        }).catch(rethrowAssertionErrorRejection$2);\n      }\n    }\n\n    function shutdown(isError, error) {\n      if (shuttingDown === true) {\n        return;\n      }\n\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight$1(dest) === false) {\n        waitForWritesToFinish().then(function () {\n          return finalize(isError, error);\n        }).catch(rethrowAssertionErrorRejection$2);\n      } else {\n        finalize(isError, error);\n      }\n    }\n\n    function finalize(isError, error) {\n      WritableStreamDefaultWriterRelease$1(writer);\n      ReadableStreamReaderGenericRelease(reader);\n\n      if (signal !== undefined) {\n        signal.removeEventListener('abort', abortAlgorithm);\n      }\n\n      if (isError) {\n        reject(error);\n      } else {\n        resolve(undefined);\n      }\n    }\n  });\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n  var reader = AcquireReadableStreamDefaultReader(stream);\n  var closedOrErrored = false;\n  var canceled1 = false;\n  var canceled2 = false;\n  var reason1;\n  var reason2;\n  var branch1;\n  var branch2;\n  var resolveCancelPromise;\n  var cancelPromise = new Promise(function (resolve) {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm() {\n    return ReadableStreamDefaultReaderRead(reader).then(function (result) {\n      var value = result.value;\n      var done = result.done;\n\n      if (done === true && closedOrErrored === false) {\n        if (canceled1 === false) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n        }\n\n        if (canceled2 === false) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n        }\n\n        closedOrErrored = true;\n      }\n\n      if (closedOrErrored === true) {\n        return;\n      }\n\n      var value1 = value;\n      var value2 = value; // There is no way to access the cloning code right now in the reference implementation.\n      // If we add one then we'll need an implementation for serializable objects.\n      // if (canceled2 === false && cloneForBranch2 === true) {\n      //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n      // }\n\n      if (canceled1 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n      }\n\n      if (canceled2 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n      }\n    });\n  }\n\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n\n    if (canceled2 === true) {\n      var compositeReason = createArrayFromList([reason1, reason2]);\n      var cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n\n    if (canceled1 === true) {\n      var compositeReason = createArrayFromList([reason1, reason2]);\n      var cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {}\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  reader._closedPromise.catch(function (r) {\n    if (closedOrErrored === true) {\n      return;\n    }\n\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n    closedOrErrored = true;\n  });\n\n  return [branch1, branch2];\n} // ReadableStream API exposed for controllers.\n\n\nfunction ReadableStreamAddReadIntoRequest(stream, forAuthorCode) {\n  var promise = new Promise(function (resolve, reject) {\n    var readIntoRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _forAuthorCode: forAuthorCode\n    };\n\n    stream._reader._readIntoRequests.push(readIntoRequest);\n  });\n  return promise;\n}\n\nfunction ReadableStreamAddReadRequest(stream, forAuthorCode) {\n  var promise = new Promise(function (resolve, reject) {\n    var readRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _forAuthorCode: forAuthorCode\n    };\n\n    stream._reader._readRequests.push(readRequest);\n  });\n  return promise;\n}\n\nfunction ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n\n  return sourceCancelPromise.then(function () {\n    return undefined;\n  });\n}\n\nfunction ReadableStreamClose(stream) {\n  stream._state = 'closed';\n  var reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (var _i2 = 0, _reader$_readRequests2 = reader._readRequests; _i2 < _reader$_readRequests2.length; _i2++) {\n      var _reader$_readRequests3 = _reader$_readRequests2[_i2],\n          _resolve = _reader$_readRequests3._resolve,\n          _forAuthorCode = _reader$_readRequests3._forAuthorCode;\n\n      _resolve(ReadableStreamCreateReadResult(undefined, true, _forAuthorCode));\n    }\n\n    reader._readRequests = [];\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n  return undefined;\n}\n\nfunction ReadableStreamCreateReadResult(value, done, forAuthorCode) {\n  var prototype = null;\n\n  if (forAuthorCode === true) {\n    prototype = Object.prototype;\n  }\n\n  var obj = Object.create(prototype);\n  Object.defineProperty(obj, 'value', {\n    value: value,\n    enumerable: true,\n    writable: true,\n    configurable: true\n  });\n  Object.defineProperty(obj, 'done', {\n    value: done,\n    enumerable: true,\n    writable: true,\n    configurable: true\n  });\n  return obj;\n}\n\nfunction ReadableStreamError(stream, e) {\n  stream._state = 'errored';\n  stream._storedError = e;\n  var reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (var _i4 = 0, _reader$_readRequests5 = reader._readRequests; _i4 < _reader$_readRequests5.length; _i4++) {\n      var readRequest = _reader$_readRequests5[_i4];\n\n      readRequest._reject(e);\n    }\n\n    reader._readRequests = [];\n  } else {\n    for (var _i6 = 0, _reader$_readIntoRequ2 = reader._readIntoRequests; _i6 < _reader$_readIntoRequ2.length; _i6++) {\n      var readIntoRequest = _reader$_readIntoRequ2[_i6];\n\n      readIntoRequest._reject(e);\n    }\n\n    reader._readIntoRequests = [];\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n\n  reader._closedPromise.catch(function () {});\n}\n\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  var reader = stream._reader;\n\n  var readIntoRequest = reader._readIntoRequests.shift();\n\n  readIntoRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readIntoRequest._forAuthorCode));\n}\n\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  var reader = stream._reader;\n\n  var readRequest = reader._readRequests.shift();\n\n  readRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readRequest._forAuthorCode));\n}\n\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n}\n\nfunction ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n}\n\nfunction ReadableStreamHasBYOBReader(stream) {\n  var reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamBYOBReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamHasDefaultReader(stream) {\n  var reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n} // Readers\n\n\nvar ReadableStreamDefaultReader =\n/*#__PURE__*/\nfunction () {\n  function ReadableStreamDefaultReader(stream) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n    }\n\n    if (IsReadableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n    this._readRequests = [];\n  }\n\n  var _proto2 = ReadableStreamDefaultReader.prototype;\n\n  _proto2.cancel = function cancel(reason) {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  };\n\n  _proto2.read = function read() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    return ReadableStreamDefaultReaderRead(this, true);\n  };\n\n  _proto2.releaseLock = function releaseLock() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  };\n\n  _createClass(ReadableStreamDefaultReader, [{\n    key: \"closed\",\n    get: function get() {\n      if (IsReadableStreamDefaultReader(this) === false) {\n        return Promise.reject(defaultReaderBrandCheckException('closed'));\n      }\n\n      return this._closedPromise;\n    }\n  }]);\n\n  return ReadableStreamDefaultReader;\n}();\n\nvar ReadableStreamBYOBReader =\n/*#__PURE__*/\nfunction () {\n  function ReadableStreamBYOBReader(stream) {\n    if (!IsReadableStream(stream)) {\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' + 'byte source');\n    }\n\n    if (IsReadableByteStreamController(stream._readableStreamController) === false) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');\n    }\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n    this._readIntoRequests = [];\n  }\n\n  var _proto3 = ReadableStreamBYOBReader.prototype;\n\n  _proto3.cancel = function cancel(reason) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  };\n\n  _proto3.read = function read(view) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return Promise.reject(new TypeError('view must be an array buffer view'));\n    }\n\n    if (IsDetachedBuffer$1(view.buffer) === true) {\n      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));\n    }\n\n    if (view.byteLength === 0) {\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\n    }\n\n    return ReadableStreamBYOBReaderRead(this, view, true);\n  };\n\n  _proto3.releaseLock = function releaseLock() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  };\n\n  _createClass(ReadableStreamBYOBReader, [{\n    key: \"closed\",\n    get: function get() {\n      if (!IsReadableStreamBYOBReader(this)) {\n        return Promise.reject(byobReaderBrandCheckException('closed'));\n      }\n\n      return this._closedPromise;\n    }\n  }]);\n\n  return ReadableStreamBYOBReader;\n}(); // Abstract operations for the readers.\n\n\nfunction IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject$1(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject$1(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n\n    reader._closedPromise.catch(function () {});\n  }\n} // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\n\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n  var stream = reader._ownerReadableStream;\n  return ReadableStreamCancel(stream, reason);\n}\n\nfunction ReadableStreamReaderGenericRelease(reader) {\n  if (reader._ownerReadableStream._state === 'readable') {\n    defaultReaderClosedPromiseReject(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  }\n\n  reader._closedPromise.catch(function () {});\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n}\n\nfunction ReadableStreamBYOBReaderRead(reader, view, forAuthorCode) {\n  if (forAuthorCode === void 0) {\n    forAuthorCode = false;\n  }\n\n  var stream = reader._ownerReadableStream;\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  } // Controllers must implement this.\n\n\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view, forAuthorCode);\n}\n\nfunction ReadableStreamDefaultReaderRead(reader, forAuthorCode) {\n  if (forAuthorCode === void 0) {\n    forAuthorCode = false;\n  }\n\n  var stream = reader._ownerReadableStream;\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(ReadableStreamCreateReadResult(undefined, true, forAuthorCode));\n  }\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  return stream._readableStreamController[PullSteps](forAuthorCode);\n} // Controllers\n\n\nvar ReadableStreamDefaultController =\n/*#__PURE__*/\nfunction () {\n  function ReadableStreamDefaultController() {\n    throw new TypeError();\n  }\n\n  var _proto4 = ReadableStreamDefaultController.prototype;\n\n  _proto4.close = function close() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  };\n\n  _proto4.enqueue = function enqueue(chunk) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  };\n\n  _proto4.error = function error(e) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  };\n\n  _proto4[CancelSteps] = function (reason) {\n    ResetQueue$2(this);\n\n    var result = this._cancelAlgorithm(reason);\n\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  };\n\n  _proto4[PullSteps] = function (forAuthorCode) {\n    var stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      var chunk = DequeueValue$2(this);\n\n      if (this._closeRequested === true && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      return Promise.resolve(ReadableStreamCreateReadResult(chunk, false, forAuthorCode));\n    }\n\n    var pendingPromise = ReadableStreamAddReadRequest(stream, forAuthorCode);\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    return pendingPromise;\n  };\n\n  _createClass(ReadableStreamDefaultController, [{\n    key: \"desiredSize\",\n    get: function get() {\n      if (IsReadableStreamDefaultController(this) === false) {\n        throw defaultControllerBrandCheckException('desiredSize');\n      }\n\n      return ReadableStreamDefaultControllerGetDesiredSize(this);\n    }\n  }]);\n\n  return ReadableStreamDefaultController;\n}(); // Abstract operations for the ReadableStreamDefaultController.\n\n\nfunction IsReadableStreamDefaultController(x) {\n  if (!typeIsObject$1(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  controller._pulling = true;\n\n  var pullPromise = controller._pullAlgorithm();\n\n  pullPromise.then(function () {\n    controller._pulling = false;\n\n    if (controller._pullAgain === true) {\n      controller._pullAgain = false;\n      return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\n\n    return undefined;\n  }, function (e) {\n    ReadableStreamDefaultControllerError(controller, e);\n  }).catch(rethrowAssertionErrorRejection$2);\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n  var stream = controller._controlledReadableStream;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n} // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\n\nfunction ReadableStreamDefaultControllerClose(controller) {\n  var stream = controller._controlledReadableStream;\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\n\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  var stream = controller._controlledReadableStream;\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    var chunkSize;\n\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize$2(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerError(controller, e) {\n  var stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue$2(controller);\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  var stream = controller._controlledReadableStream;\n  var state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n} // This is used in the implementation of TransformStream.\n\n\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  var state = controller._controlledReadableStream._state;\n\n  if (controller._closeRequested === false && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  controller._controlledReadableStream = stream;\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue$2(controller);\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n  stream._readableStreamController = controller;\n  var startResult = startAlgorithm();\n  Promise.resolve(startResult).then(function () {\n    controller._started = true;\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n  }, function (r) {\n    ReadableStreamDefaultControllerError(controller, r);\n  }).catch(rethrowAssertionErrorRejection$2);\n}\n\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n  var controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop$1(underlyingSource, 'start', [controller]);\n  }\n\n  var pullAlgorithm = CreateAlgorithmFromUnderlyingMethod$1(underlyingSource, 'pull', 0, [controller]);\n  var cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod$1(underlyingSource, 'cancel', 1, []);\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n}\n\nvar ReadableStreamBYOBRequest =\n/*#__PURE__*/\nfunction () {\n  function ReadableStreamBYOBRequest() {\n    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\n  }\n\n  var _proto5 = ReadableStreamBYOBRequest.prototype;\n\n  _proto5.respond = function respond(bytesWritten) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer$1(this._view.buffer) === true) {\n      throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  };\n\n  _proto5.respondWithNewView = function respondWithNewView(view) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (IsDetachedBuffer$1(view.buffer) === true) {\n      throw new TypeError('The supplied view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  };\n\n  _createClass(ReadableStreamBYOBRequest, [{\n    key: \"view\",\n    get: function get() {\n      if (IsReadableStreamBYOBRequest(this) === false) {\n        throw byobRequestBrandCheckException('view');\n      }\n\n      return this._view;\n    }\n  }]);\n\n  return ReadableStreamBYOBRequest;\n}();\n\nvar ReadableByteStreamController =\n/*#__PURE__*/\nfunction () {\n  function ReadableByteStreamController() {\n    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\n  }\n\n  var _proto6 = ReadableByteStreamController.prototype;\n\n  _proto6.close = function close() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    var state = this._controlledReadableByteStream._state;\n\n    if (state !== 'readable') {\n      throw new TypeError(\"The stream (in \" + state + \" state) is not in the readable state and cannot be closed\");\n    }\n\n    ReadableByteStreamControllerClose(this);\n  };\n\n  _proto6.enqueue = function enqueue(chunk) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    var state = this._controlledReadableByteStream._state;\n\n    if (state !== 'readable') {\n      throw new TypeError(\"The stream (in \" + state + \" state) is not in the readable state and cannot be enqueued to\");\n    }\n\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n    }\n\n    if (IsDetachedBuffer$1(chunk.buffer) === true) {\n      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  };\n\n  _proto6.error = function error(e) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  };\n\n  _proto6[CancelSteps] = function (reason) {\n    if (this._pendingPullIntos.length > 0) {\n      var firstDescriptor = this._pendingPullIntos[0];\n      firstDescriptor.bytesFilled = 0;\n    }\n\n    ResetQueue$2(this);\n\n    var result = this._cancelAlgorithm(reason);\n\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  };\n\n  _proto6[PullSteps] = function (forAuthorCode) {\n    var stream = this._controlledReadableByteStream;\n\n    if (this._queueTotalSize > 0) {\n      var entry = this._queue.shift();\n\n      this._queueTotalSize -= entry.byteLength;\n      ReadableByteStreamControllerHandleQueueDrain(this);\n      var view;\n\n      try {\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n      } catch (viewE) {\n        return Promise.reject(viewE);\n      }\n\n      return Promise.resolve(ReadableStreamCreateReadResult(view, false, forAuthorCode));\n    }\n\n    var autoAllocateChunkSize = this._autoAllocateChunkSize;\n\n    if (autoAllocateChunkSize !== undefined) {\n      var buffer;\n\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        return Promise.reject(bufferE);\n      }\n\n      var pullIntoDescriptor = {\n        buffer: buffer,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        ctor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    var promise = ReadableStreamAddReadRequest(stream, forAuthorCode);\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n    return promise;\n  };\n\n  _createClass(ReadableByteStreamController, [{\n    key: \"byobRequest\",\n    get: function get() {\n      if (IsReadableByteStreamController(this) === false) {\n        throw byteStreamControllerBrandCheckException('byobRequest');\n      }\n\n      if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n        var firstDescriptor = this._pendingPullIntos[0];\n        var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n        var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n        SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n        this._byobRequest = byobRequest;\n      }\n\n      return this._byobRequest;\n    }\n  }, {\n    key: \"desiredSize\",\n    get: function get() {\n      if (IsReadableByteStreamController(this) === false) {\n        throw byteStreamControllerBrandCheckException('desiredSize');\n      }\n\n      return ReadableByteStreamControllerGetDesiredSize(this);\n    }\n  }]);\n\n  return ReadableByteStreamController;\n}(); // Abstract operations for the ReadableByteStreamController.\n\n\nfunction IsReadableByteStreamController(x) {\n  if (!typeIsObject$1(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject$1(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  controller._pulling = true; // TODO: Test controller argument\n\n  var pullPromise = controller._pullAlgorithm();\n\n  pullPromise.then(function () {\n    controller._pulling = false;\n\n    if (controller._pullAgain === true) {\n      controller._pullAgain = false;\n      ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n  }, function (e) {\n    ReadableByteStreamControllerError(controller, e);\n  }).catch(rethrowAssertionErrorRejection$2);\n  return undefined;\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = [];\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  var done = false;\n\n  if (stream._state === 'closed') {\n    done = true;\n  }\n\n  var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n  var bytesFilled = pullIntoDescriptor.bytesFilled;\n  var elementSize = pullIntoDescriptor.elementSize;\n  return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  controller._queue.push({\n    buffer: buffer,\n    byteOffset: byteOffset,\n    byteLength: byteLength\n  });\n\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n  var elementSize = pullIntoDescriptor.elementSize;\n  var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n  var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n  var totalBytesToCopyRemaining = maxBytesToCopy;\n  var ready = false;\n\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  var queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    var headOfQueue = queue[0];\n    var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n    var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n\n    controller._queueTotalSize -= bytesToCopy;\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === undefined) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = undefined;\n  controller._byobRequest = undefined;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    var pullIntoDescriptor = controller._pendingPullIntos[0];\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerPullInto(controller, view, forAuthorCode) {\n  var stream = controller._controlledReadableByteStream;\n  var elementSize = 1;\n\n  if (view.constructor !== DataView) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n\n  var ctor = view.constructor;\n  var buffer = TransferArrayBuffer$1(view.buffer);\n  var pullIntoDescriptor = {\n    buffer: buffer,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize: elementSize,\n    ctor: ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor); // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n\n    return ReadableStreamAddReadIntoRequest(stream, forAuthorCode);\n  }\n\n  if (stream._state === 'closed') {\n    var emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    return Promise.resolve(ReadableStreamCreateReadResult(emptyView, true, forAuthorCode));\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n      return Promise.resolve(ReadableStreamCreateReadResult(filledView, false, forAuthorCode));\n    }\n\n    if (controller._closeRequested === true) {\n      var e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n      return Promise.reject(e);\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  var promise = ReadableStreamAddReadIntoRequest(stream, forAuthorCode);\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n  return promise;\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  firstDescriptor.buffer = TransferArrayBuffer$1(firstDescriptor.buffer);\n  var stream = controller._controlledReadableByteStream;\n\n  if (ReadableStreamHasBYOBReader(stream) === true) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n    throw new RangeError('bytesWritten out of range');\n  }\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    // TODO: Figure out whether we should detach the buffer or not here.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n  var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n\n  if (remainderSize > 0) {\n    var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.buffer = TransferArrayBuffer$1(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  var firstDescriptor = controller._pendingPullIntos[0];\n  var stream = controller._controlledReadableByteStream;\n\n  if (stream._state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  var descriptor = controller._pendingPullIntos.shift();\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n  var stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested === true) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n} // A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\n\nfunction ReadableByteStreamControllerClose(controller) {\n  var stream = controller._controlledReadableByteStream;\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    var firstPendingPullInto = controller._pendingPullIntos[0];\n\n    if (firstPendingPullInto.bytesFilled > 0) {\n      var e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n      throw e;\n    }\n  }\n\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\n\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n  var stream = controller._controlledReadableByteStream;\n  var buffer = chunk.buffer;\n  var byteOffset = chunk.byteOffset;\n  var byteLength = chunk.byteLength;\n  var transferredBuffer = TransferArrayBuffer$1(buffer);\n\n  if (ReadableStreamHasDefaultReader(stream) === true) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerError(controller, e) {\n  var stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n  ResetQueue$2(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n  var stream = controller._controlledReadableByteStream;\n  var state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n\n  if (IsFiniteNonNegativeNumber$1(bytesWritten) === false) {\n    throw new RangeError('bytesWritten must be a finite');\n  }\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  var firstDescriptor = controller._pendingPullIntos[0];\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n\n  if (firstDescriptor.byteLength !== view.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n\n  firstDescriptor.buffer = view.buffer;\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\n\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n\n  controller._controlledReadableByteStream = stream;\n  controller._pullAgain = false;\n  controller._pulling = false;\n  ReadableByteStreamControllerClearPendingPullIntos(controller); // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n\n  controller._queue = controller._queueTotalSize = undefined;\n  ResetQueue$2(controller);\n  controller._closeRequested = false;\n  controller._started = false;\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark$1(highWaterMark);\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n  controller._pendingPullIntos = [];\n  stream._readableStreamController = controller;\n  var startResult = startAlgorithm();\n  Promise.resolve(startResult).then(function () {\n    controller._started = true;\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }, function (r) {\n    ReadableByteStreamControllerError(controller, r);\n  }).catch(rethrowAssertionErrorRejection$2);\n}\n\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n  var controller = Object.create(ReadableByteStreamController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop$1(underlyingByteSource, 'start', [controller]);\n  }\n\n  var pullAlgorithm = CreateAlgorithmFromUnderlyingMethod$1(underlyingByteSource, 'pull', 0, [controller]);\n  var cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod$1(underlyingByteSource, 'cancel', 1, []);\n  var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n\n  if (autoAllocateChunkSize !== undefined) {\n    autoAllocateChunkSize = Number(autoAllocateChunkSize);\n\n    if (NumberIsInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\n      throw new RangeError('autoAllocateChunkSize must be a positive integer');\n    }\n  }\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n}\n\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n} // Helper functions for the ReadableStream.\n\n\nfunction isAbortSignal(value) {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  } // Use the brand check to distinguish a real AbortSignal from a fake one.\n\n\n  var aborted = Object.getOwnPropertyDescriptor(AbortSignal.prototype, 'aborted').get;\n\n  try {\n    aborted.call(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction streamBrandCheckException$1(name) {\n  return new TypeError(\"ReadableStream.prototype.\" + name + \" can only be used on a ReadableStream\");\n} // Helper functions for the readers.\n\n\nfunction readerLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n} // Helper functions for the ReadableStreamDefaultReader.\n\n\nfunction defaultReaderBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamDefaultReader.prototype.\" + name + \" can only be used on a ReadableStreamDefaultReader\");\n}\n\nfunction defaultReaderClosedPromiseInitialize(reader) {\n  reader._closedPromise = new Promise(function (resolve, reject) {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  reader._closedPromise = Promise.reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  reader._closedPromise = Promise.resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n  reader._closedPromise_reject(reason);\n\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  reader._closedPromise = Promise.reject(reason);\n}\n\nfunction defaultReaderClosedPromiseResolve(reader) {\n  reader._closedPromise_resolve(undefined);\n\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n} // Helper functions for the ReadableStreamDefaultReader.\n\n\nfunction byobReaderBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamBYOBReader.prototype.\" + name + \" can only be used on a ReadableStreamBYOBReader\");\n} // Helper functions for the ReadableStreamDefaultController.\n\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamDefaultController.prototype.\" + name + \" can only be used on a ReadableStreamDefaultController\");\n} // Helper functions for the ReadableStreamBYOBRequest.\n\n\nfunction byobRequestBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamBYOBRequest.prototype.\" + name + \" can only be used on a ReadableStreamBYOBRequest\");\n} // Helper functions for the ReadableByteStreamController.\n\n\nfunction byteStreamControllerBrandCheckException(name) {\n  return new TypeError(\"ReadableByteStreamController.prototype.\" + name + \" can only be used on a ReadableByteStreamController\");\n}\nvar readableStream_3 = readableStream.ReadableStream;\n\nvar createDataProperty = require$$0.createDataProperty;\n\nvar byteLengthQueuingStrategy =\n/*#__PURE__*/\nfunction () {\n  function ByteLengthQueuingStrategy(_ref) {\n    var highWaterMark = _ref.highWaterMark;\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  var _proto = ByteLengthQueuingStrategy.prototype;\n\n  _proto.size = function size(chunk) {\n    return chunk.byteLength;\n  };\n\n  return ByteLengthQueuingStrategy;\n}();\n\nvar createDataProperty$1 = require$$0.createDataProperty;\n\nvar countQueuingStrategy =\n/*#__PURE__*/\nfunction () {\n  function CountQueuingStrategy(_ref) {\n    var highWaterMark = _ref.highWaterMark;\n    createDataProperty$1(this, 'highWaterMark', highWaterMark);\n  }\n\n  var _proto = CountQueuingStrategy.prototype;\n\n  _proto.size = function size() {\n    return 1;\n  };\n\n  return CountQueuingStrategy;\n}();\n\n// and do not appear in the standard text.\n\n\nvar verbose$1 = require$$0$1('streams:transform-stream:verbose');\nvar InvokeOrNoop$2 = require$$0.InvokeOrNoop,\n    CreateAlgorithmFromUnderlyingMethod$2 = require$$0.CreateAlgorithmFromUnderlyingMethod,\n    PromiseCall = require$$0.PromiseCall,\n    typeIsObject$2 = require$$0.typeIsObject,\n    ValidateAndNormalizeHighWaterMark$2 = require$$0.ValidateAndNormalizeHighWaterMark,\n    IsNonNegativeNumber$2 = require$$0.IsNonNegativeNumber,\n    MakeSizeAlgorithmFromSizeFunction$2 = require$$0.MakeSizeAlgorithmFromSizeFunction;\nvar CreateReadableStream$1 = readableStream.CreateReadableStream,\n    ReadableStreamDefaultControllerClose$1 = readableStream.ReadableStreamDefaultControllerClose,\n    ReadableStreamDefaultControllerEnqueue$1 = readableStream.ReadableStreamDefaultControllerEnqueue,\n    ReadableStreamDefaultControllerError$1 = readableStream.ReadableStreamDefaultControllerError,\n    ReadableStreamDefaultControllerGetDesiredSize$1 = readableStream.ReadableStreamDefaultControllerGetDesiredSize,\n    ReadableStreamDefaultControllerHasBackpressure$1 = readableStream.ReadableStreamDefaultControllerHasBackpressure,\n    ReadableStreamDefaultControllerCanCloseOrEnqueue$1 = readableStream.ReadableStreamDefaultControllerCanCloseOrEnqueue;\nvar CreateWritableStream$1 = writableStream.CreateWritableStream,\n    WritableStreamDefaultControllerErrorIfNeeded$1 = writableStream.WritableStreamDefaultControllerErrorIfNeeded; // Class TransformStream\n\nvar TransformStream =\n/*#__PURE__*/\nfunction () {\n  function TransformStream(transformer, writableStrategy, readableStrategy) {\n    if (transformer === void 0) {\n      transformer = {};\n    }\n\n    if (writableStrategy === void 0) {\n      writableStrategy = {};\n    }\n\n    if (readableStrategy === void 0) {\n      readableStrategy = {};\n    }\n\n    var writableSizeFunction = writableStrategy.size;\n    var writableHighWaterMark = writableStrategy.highWaterMark;\n    var readableSizeFunction = readableStrategy.size;\n    var readableHighWaterMark = readableStrategy.highWaterMark;\n    var writableType = transformer.writableType;\n\n    if (writableType !== undefined) {\n      throw new RangeError('Invalid writable type specified');\n    }\n\n    var writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction$2(writableSizeFunction);\n\n    if (writableHighWaterMark === undefined) {\n      writableHighWaterMark = 1;\n    }\n\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark$2(writableHighWaterMark);\n    var readableType = transformer.readableType;\n\n    if (readableType !== undefined) {\n      throw new RangeError('Invalid readable type specified');\n    }\n\n    var readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction$2(readableSizeFunction);\n\n    if (readableHighWaterMark === undefined) {\n      readableHighWaterMark = 0;\n    }\n\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark$2(readableHighWaterMark);\n    var startPromise_resolve;\n    var startPromise = new Promise(function (resolve) {\n      startPromise_resolve = resolve;\n    });\n    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n    var startResult = InvokeOrNoop$2(transformer, 'start', [this._transformStreamController]);\n    startPromise_resolve(startResult);\n  }\n\n  _createClass(TransformStream, [{\n    key: \"readable\",\n    get: function get() {\n      if (IsTransformStream(this) === false) {\n        throw streamBrandCheckException$2('readable');\n      }\n\n      return this._readable;\n    }\n  }, {\n    key: \"writable\",\n    get: function get() {\n      if (IsTransformStream(this) === false) {\n        throw streamBrandCheckException$2('writable');\n      }\n\n      return this._writable;\n    }\n  }]);\n\n  return TransformStream;\n}(); // Transform Stream Abstract Operations\n\n\nfunction CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n  if (writableHighWaterMark === void 0) {\n    writableHighWaterMark = 1;\n  }\n\n  if (writableSizeAlgorithm === void 0) {\n    writableSizeAlgorithm = function writableSizeAlgorithm() {\n      return 1;\n    };\n  }\n\n  if (readableHighWaterMark === void 0) {\n    readableHighWaterMark = 0;\n  }\n\n  if (readableSizeAlgorithm === void 0) {\n    readableSizeAlgorithm = function readableSizeAlgorithm() {\n      return 1;\n    };\n  }\n\n  var stream = Object.create(TransformStream.prototype);\n  var startPromise_resolve;\n  var startPromise = new Promise(function (resolve) {\n    startPromise_resolve = resolve;\n  });\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n  var controller = Object.create(TransformStreamDefaultController.prototype);\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n  var startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n  function startAlgorithm() {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk) {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason) {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm() {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream$1(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm() {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason) {\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n    return Promise.resolve();\n  }\n\n  stream._readable = CreateReadableStream$1(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm); // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n\n  stream._backpressure = undefined;\n  stream._backpressureChangePromise = undefined;\n  stream._backpressureChangePromise_resolve = undefined;\n  TransformStreamSetBackpressure(stream, true); // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\n\n  stream._transformStreamController = undefined;\n}\n\nfunction IsTransformStream(x) {\n  if (!typeIsObject$2(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return true;\n} // This is a no-op if both sides are already errored.\n\n\nfunction TransformStreamError(stream, e) {\n  ReadableStreamDefaultControllerError$1(stream._readable._readableStreamController, e);\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded$1(stream._writable._writableStreamController, e);\n\n  if (stream._backpressure === true) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n  // Passes also when called during construction.\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = new Promise(function (resolve) {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n  stream._backpressure = backpressure;\n} // Class TransformStreamDefaultController\n\n\nvar TransformStreamDefaultController =\n/*#__PURE__*/\nfunction () {\n  function TransformStreamDefaultController() {\n    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\n  }\n\n  var _proto = TransformStreamDefaultController.prototype;\n\n  _proto.enqueue = function enqueue(chunk) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException$1('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  };\n\n  _proto.error = function error(reason) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException$1('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  };\n\n  _proto.terminate = function terminate() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException$1('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  };\n\n  _createClass(TransformStreamDefaultController, [{\n    key: \"desiredSize\",\n    get: function get() {\n      if (IsTransformStreamDefaultController(this) === false) {\n        throw defaultControllerBrandCheckException$1('desiredSize');\n      }\n\n      var readableController = this._controlledTransformStream._readable._readableStreamController;\n      return ReadableStreamDefaultControllerGetDesiredSize$1(readableController);\n    }\n  }]);\n\n  return TransformStreamDefaultController;\n}(); // Transform Stream Default Controller Abstract Operations\n\n\nfunction IsTransformStreamDefaultController(x) {\n  if (!typeIsObject$2(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n  var controller = Object.create(TransformStreamDefaultController.prototype);\n\n  var transformAlgorithm = function transformAlgorithm(chunk) {\n    try {\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\n      return Promise.resolve();\n    } catch (transformResultE) {\n      return Promise.reject(transformResultE);\n    }\n  };\n\n  var transformMethod = transformer.transform;\n\n  if (transformMethod !== undefined) {\n    if (typeof transformMethod !== 'function') {\n      throw new TypeError('transform is not a method');\n    }\n\n    transformAlgorithm = function transformAlgorithm(chunk) {\n      return PromiseCall(transformMethod, transformer, [chunk, controller]);\n    };\n  }\n\n  var flushAlgorithm = CreateAlgorithmFromUnderlyingMethod$2(transformer, 'flush', 0, [controller]);\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n  controller._transformAlgorithm = undefined;\n  controller._flushAlgorithm = undefined;\n}\n\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  var stream = controller._controlledTransformStream;\n  var readableController = stream._readable._readableStreamController;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue$1(readableController) === false) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  } // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n\n  try {\n    ReadableStreamDefaultControllerEnqueue$1(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n    throw stream._readable._storedError;\n  }\n\n  var backpressure = ReadableStreamDefaultControllerHasBackpressure$1(readableController);\n\n  if (backpressure !== stream._backpressure) {\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller, e) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n  var transformPromise = controller._transformAlgorithm(chunk);\n\n  return transformPromise.catch(function (r) {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\n\nfunction TransformStreamDefaultControllerTerminate(controller) {\n  var stream = controller._controlledTransformStream;\n  var readableController = stream._readable._readableStreamController;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue$1(readableController) === true) {\n    ReadableStreamDefaultControllerClose$1(readableController);\n  }\n\n  var error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n} // TransformStreamDefaultSink Algorithms\n\n\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n  var controller = stream._transformStreamController;\n\n  if (stream._backpressure === true) {\n    var backpressureChangePromise = stream._backpressureChangePromise;\n    return backpressureChangePromise.then(function () {\n      var writable = stream._writable;\n      var state = writable._state;\n\n      if (state === 'erroring') {\n        throw writable._storedError;\n      }\n\n      return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n    });\n  }\n\n  return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n  // errored.\n  TransformStreamError(stream, reason);\n  return Promise.resolve();\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  var readable = stream._readable;\n  var controller = stream._transformStreamController;\n\n  var flushPromise = controller._flushAlgorithm();\n\n  TransformStreamDefaultControllerClearAlgorithms(controller); // Return a promise that is fulfilled with undefined on success.\n\n  return flushPromise.then(function () {\n    if (readable._state === 'errored') {\n      throw readable._storedError;\n    }\n\n    var readableController = readable._readableStreamController;\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue$1(readableController) === true) {\n      ReadableStreamDefaultControllerClose$1(readableController);\n    }\n  }).catch(function (r) {\n    TransformStreamError(stream, r);\n    throw readable._storedError;\n  });\n} // TransformStreamDefaultSource Algorithms\n\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n  // Invariant. Enforced by the promises returned by start() and pull().\n  TransformStreamSetBackpressure(stream, false); // Prevent the next pull() call until there is backpressure.\n\n  return stream._backpressureChangePromise;\n}\n\nvar transformStream = {\n  CreateTransformStream: CreateTransformStream,\n  TransformStream: TransformStream\n}; // Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException$1(name) {\n  return new TypeError(\"TransformStreamDefaultController.prototype.\" + name + \" can only be used on a TransformStreamDefaultController\");\n} // Helper functions for the TransformStream.\n\n\nfunction streamBrandCheckException$2(name) {\n  return new TypeError(\"TransformStream.prototype.\" + name + \" can only be used on a TransformStream\");\n}\nvar transformStream_2 = transformStream.TransformStream;\n\nexport { readableStream_3 as ReadableStream, writableStream_5 as WritableStream, byteLengthQueuingStrategy as ByteLengthQueuingStrategy, countQueuingStrategy as CountQueuingStrategy, transformStream_2 as TransformStream };\n//# sourceMappingURL=ponyfill.mjs.map\n"],"sourceRoot":""}