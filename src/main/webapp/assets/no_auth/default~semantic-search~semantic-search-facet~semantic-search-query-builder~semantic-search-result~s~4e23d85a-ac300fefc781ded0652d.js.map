{"version":3,"sources":["webpack:///./src/main/web/components/semantic/search/config/SearchConfig.ts"],"names":["RELATION_PROFILE_VARIABLES","CATEGORY_PROJECTION_VAR","RELATION_PROJECTION_VAR","LABEL_PROJECTION_VAR","THUMBNAIL_PROJECTION_VAR","DESCRIPTION_PROJECTION_VAR","PROFILE_PROJECTION_VAR","RELATION_RANGE_PROJECTION_VAR","RELATION_DOMAIN_PROJECTION_VAR","SEMANTIC_SEARCH_VARIABLES","PROJECTION_ALIAS_VAR","DOMAIN_VAR","RANGE_VAR","RESOURCE_VAR","SET_VAR","RELATION_VAR","RELATION_PATTERN_VAR","DATE_BEGING_VAR","DATE_END_VAR","GEO_CENTER_VAR","GEO_CENTER_LAT_VAR","GEO_CENTER_LONG_VAR","GEO_DISTANCE_VAR","GEO_SOUTH_WEST","GEO_SOUTH_WEST_LAT","GEO_SOUTH_WEST_LONG","GEO_NORTH_EAST","GEO_NORTH_EAST_LAT","GEO_NORTH_EAST_LONG","LITERAL_VAR","NUMERIC_RANGE_BEGIN_VAR","NUMERIC_RANGE_END_VAR","SELECTED_DATASET","SELECTED_ALIGNMENT","RESOURCE_SEGGESTIONS_VARIABLES","SUGGESTION_IRI","SUGGESTION_LABEL","SEARCH_TERM_VAR","RESULT_VARIABLES","CONTEXT_RELATION_VAR","CONTEXT_RELATION_PATTERN_VAR","FACET_VARIABLES","VALUE_RESOURCE_VAR","VALUE_RESOURCE_LABEL_VAR","VALUE_DATE_RANGE_BEGIN_VAR","VALUE_DATE_RANGE_END_VAR","VALUE_LITERAL","VALUE_NUMERIC_RANGE_BEGIN_VAR","VALUE_NUMERIC_RANGE_END_VAR","getConfigPatternForCategory","config","category","patternConfigs","categories","toString","length","isQuerySearchProfileConfig","_","has"],"mappings":"iIAuBA,YAEa,EAAAA,2BAA6B,CACxCC,wBAAyB,WACzBC,wBAAyB,WACzBC,qBAAsB,QACtBC,yBAA0B,YAC1BC,2BAA4B,cAC5BC,uBAAwB,UACxBC,8BAA+B,WAC/BC,+BAAgC,aAGrB,EAAAC,0BAA4B,CACvCC,qBAAsB,UACtBC,WAAY,aACZC,UAAW,YACXC,aAAc,YACdC,QAAS,UACTC,aAAc,eACdC,qBAAsB,sBACtBC,gBAAiB,qBACjBC,aAAc,mBACdC,eAAgB,gBAChBC,mBAAoB,mBACpBC,oBAAqB,oBACrBC,iBAAkB,kBAClBC,eAAgB,mBAChBC,mBAAoB,sBACpBC,oBAAqB,uBACrBC,eAAgB,mBAChBC,mBAAoB,sBACpBC,oBAAqB,uBACrBC,YAAa,cACbC,wBAAyB,6BACzBC,sBAAuB,2BACvBC,iBAAkB,cAClBC,mBAAoB,iBAGT,EAAAC,+BAAiC,CAC5CC,eAAgB,aAChBC,iBAAkB,QAClBC,gBAAiB,aAGN,EAAAC,iBAAmB,CAC9BC,qBAAsB,sBACtBC,6BAA8B,8BA2rBnB,EAAAC,gBAAkB,CAC7B1B,aAAc,eACdC,qBAAsB,2BACtBJ,UAAW,YACXD,WAAY,aACZ+B,mBAAoB,QACpBC,yBAA0B,QAC1BC,2BAA4B,iBAC5BC,yBAA0B,eAC1BC,cAAe,UACfC,8BAA+B,yBAC/BC,4BAA6B,wBA8D/B,uCAAgBC,4BACdC,EACAC,GAEA,IAAMC,EAAiBF,EAAOG,WAAWF,EAASG,YAClD,OAAIF,GAAkBA,EAAeG,OAAS,EACrCH,EAAe,QAEtB,GAIJ,sCAAgBI,2BAA2BN,GACzC,OAAOO,EAAEC,IAAIR,EAAQ","file":"default~semantic-search~semantic-search-facet~semantic-search-query-builder~semantic-search-result~s~4e23d85a-ac300fefc781ded0652d.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Maybe from 'data.maybe';\n\nimport { LightwightTreePatterns, ComplexTreePatterns } from 'platform/components/semantic/lazy-tree';\nimport { Rdf } from 'platform/api/rdf';\nimport * as _ from 'lodash';\n\nexport const RELATION_PROFILE_VARIABLES = {\n  CATEGORY_PROJECTION_VAR: 'category',\n  RELATION_PROJECTION_VAR: 'relation',\n  LABEL_PROJECTION_VAR: 'label',\n  THUMBNAIL_PROJECTION_VAR: 'thumbnail',\n  DESCRIPTION_PROJECTION_VAR: 'description',\n  PROFILE_PROJECTION_VAR: 'profile',\n  RELATION_RANGE_PROJECTION_VAR: 'hasRange',\n  RELATION_DOMAIN_PROJECTION_VAR: 'hasDomain',\n};\n\nexport const SEMANTIC_SEARCH_VARIABLES = {\n  PROJECTION_ALIAS_VAR: 'subject',\n  DOMAIN_VAR: '__domain__',\n  RANGE_VAR: '__range__',\n  RESOURCE_VAR: '__value__',\n  SET_VAR: '__set__',\n  RELATION_VAR: '__relation__',\n  RELATION_PATTERN_VAR: '__relationPattern__',\n  DATE_BEGING_VAR: '__dateBeginValue__',\n  DATE_END_VAR: '__dateEndValue__',\n  GEO_CENTER_VAR: '__geoCenter__',\n  GEO_CENTER_LAT_VAR: '__geoCenterLat__',\n  GEO_CENTER_LONG_VAR: '__geoCenterLong__',\n  GEO_DISTANCE_VAR: '__geoDistance__',\n  GEO_SOUTH_WEST: '__geoSouthWest__',\n  GEO_SOUTH_WEST_LAT: '__geoSouthWestLat__',\n  GEO_SOUTH_WEST_LONG: '__geoSouthWestLong__',\n  GEO_NORTH_EAST: '__geoNorthEast__',\n  GEO_NORTH_EAST_LAT: '__geoNorthEastLat__',\n  GEO_NORTH_EAST_LONG: '__geoNorthEastLong__',\n  LITERAL_VAR: '__literal__',\n  NUMERIC_RANGE_BEGIN_VAR: '__numericRangeBeginValue__',\n  NUMERIC_RANGE_END_VAR: '__numericRangeEndValue__',\n  SELECTED_DATASET: '__dataset__',\n  SELECTED_ALIGNMENT: '__alignment__',\n};\n\nexport const RESOURCE_SEGGESTIONS_VARIABLES = {\n  SUGGESTION_IRI: 'suggestion',\n  SUGGESTION_LABEL: 'label',\n  SEARCH_TERM_VAR: '__token__',\n};\n\nexport const RESULT_VARIABLES = {\n  CONTEXT_RELATION_VAR: '__contextRelation__',\n  CONTEXT_RELATION_PATTERN_VAR: '__contextRelationPattern__',\n};\n\nexport type SearchProfileConfig = QuerySearchProfileConfig | InlineSearchProfileConfig;\n\nexport interface QuerySearchProfileConfig {\n  /**\n   * SPARQL Select query returning the list of categories available for search,\n   * grouped by corresponding search profile.\n   *\n   * Expected projection variables:\n   *   category - IRI of the category\n   *   profile - search profile IRI that a given category belongs to\n   *   thumbnail - URL of the category thumbnail\n   *   label - category label\n   *   description - detailed description of the category\n   */\n  categoriesQuery: string;\n\n  /**\n   * SPARQL Select query returning the list of relations available for search,\n   * grouped by corresponding search profile.\n   *\n   * Expected projection variables:\n   *   relation- relation IRI\n   *   label - relation label\n   *   description - detailed description of the relation\n   *   domain - relation domain IRI\n   *   range - relation range IRI\n   */\n  relationsQuery: string;\n\n  /**\n   * IRI of the default profile\n   */\n  defaultProfile?: string;\n}\n\n/**\n * Base supertype for inline category/relation descriptors\n */\nexport interface InlineResource {\n  /**\n   * IRI of the category/relation.\n   * Must be expressed as a full IRI enclosed in '<>'\n   */\n  iri: string;\n\n  /**\n   * Label of the category/relation shown in the UI\n   */\n  label: string;\n}\n\n/**\n * Inline configuration for a category\n */\nexport interface InlineCategory extends InlineResource {\n  /**\n   * URL reference of the icon image to depict the category in the query builder UI\n   */\n  thumbnail?: string;\n  color?: string;\n}\n\n/**\n * Inline configuration for a relation\n */\nexport interface InlineRelation extends InlineResource {\n  /**\n   * IRI of the category whose instances appear as subjects of this relation.\n   * Must be expressed as a full IRI enclosed in '<>'\n   */\n  hasDomain: string;\n\n  /**\n   * IRI of the category whose instances appear as objects of this relation.\n   * Must be expressed as a full IRI enclosed in '<>'\n   */\n  hasRange: string;\n}\n\nexport interface InlineSearchProfileConfig {\n  categories: Array<InlineCategory>;\n  relations: Array<InlineRelation>;\n}\n\nexport type TreeSelectorConfig = ComplexTreePatterns | LightwightTreePatterns;\nexport interface TreeSelectorPatterns {\n  [key: string]: TreeSelectorConfig;\n}\n\nexport interface ResourceSelectorPatterns {\n  [key: string]: ResourceSelectorConfig;\n}\n\nexport interface SemanticQueryBuilderConfig {\n  /**\n   * Id is used when triggering events.\n   */\n  id: string;\n  /**\n   * Default configuration for autosuggestion that is used to select values for relations of 'resource' kind.\n   */\n  resourceSelector: ResourceSelectorConfig;\n\n  /**\n   * Override configuration for resource selector based on the range of the selected relation.\n   */\n  resourceSelectorCategories?: ResourceSelectorPatterns;\n\n  /**\n   * Override configuration for resource selector based on the selected relation.\n   */\n  resourceSelectorRelations?: ResourceSelectorPatterns;\n\n  /**\n   * Default configuration for tree-based autosuggestion, that is used to select values for any relations of 'hierarchy' kind.\n   */\n  treeSelector?: TreeSelectorConfig;\n\n  /**\n   * Override configuration for tree selector based on the range of the selected relation.\n   */\n  treeSelectorCategories?: TreeSelectorPatterns;\n\n  /**\n   * Override configuration for tree selector based on the selected relation.\n   */\n  treeSelectorRelations?: TreeSelectorPatterns;\n\n  /**\n   * Configuration for place autosuggestion that is used for relations of 'place' kind.\n   */\n  geoSelector?: ResourceSelectorConfig;\n\n  /**\n   * Handlebars template for category selection item. Can be customized to provide additional help information in the search interface, e.g tooltip with description of the category etc.\n   *\n   * By default shows category thumbnail along with label.\n   *\n   * For SPARQL Select binding variables available in the template,\n   * @see SearchProfileConfig#categoriesQuery.\n   */\n  categoryViewTemplate?: string;\n\n  /**\n   * Handlebars template for relation selection item. Can be customized to provide additional help\n   * information in the search interface, e.g tooltip with description of relation etc.\n   *\n   * By default shows relation label only.\n\n   * For SPARQL Select binding variables available in the template,\n   * @see SearchProfileConfig#relationsQuery.\n   */\n  relationViewTemplate?: string;\n\n  /**\n   * By default `subject` variable is used as projection variable for the generated query, however it is possible to override the default.\n   * Independently from the projection variable in the base query, it is always possible to use `?subject` variable in the result visualizaiton query to refer to the result. If the projection variable in the base-query is not named `subject`, an additional bind clause will be injected to bind it to `?subject`.\n   *\n   * @default subject\n   */\n  projectionVariable?: string;\n}\n\nexport interface ResourceSelectorConfig {\n  /**\n   * SPARQL Select query that is used for autosuggestion.\n   *\n   * Mandatory projection variables:\n   *   suggestion - should contain suggestion item IRI\n   *   label - should contain suggestion item label\n   *\n   * Variables that will be substituted with user selected value:\n   *   __token__ - user input represented as string literal\n   *   __domain__ - search domain category IRI\n   *   __range__ - conjunct range category IRI\n   *   __relation__ - conjunct relation IRI\n   */\n  query: string;\n\n  /**\n   * A flag determining whether any special Lucene syntax will be escaped.\n   * When `false` lucene syntax in the user input is not escaped.\n   *\n   * @default true\n   */\n  escapeLuceneSyntax?: boolean;\n\n  /**\n   * A flag determining whether the user input is tokenized by whitespace into words postfixed by `*`.\n   * E.g. the search for `Hello World` becomes `Hello* World*`.\n   *\n   * @default true\n   */\n  tokenizeLuceneQuery?: boolean;\n\n  /**\n   * SPARQL Select query that is used for default autosuggestions.\n   *\n   * Mandatory projection variables:\n   *   suggestion - should contain suggestion item IRI\n   *   label - should contain suggestion item label\n   *\n   * Variables that will be substituted with user selected value:\n   *   __token__ - user input represented as string literal\n   *   __domain__ - search domain category IRI\n   *   __range__ - conjunct range category IRI\n   *   __relation__ - conjunct relation IRI\n   */\n  defaultQuery?: string;\n\n  /**\n   * Handlebars template that is used when there are no results that match user input.\n   */\n  noSuggestionsTemplate: string;\n\n  /**\n   * Handlebars template that is used to render suggestion items.\n   * Template has access to all SPARQL projection variables from the query.\n   */\n  suggestionTupleTemplate: string;\n}\n\nexport interface SearchDatasetConfig {\n  /**\n   * Service IRI of the dataset's SPARQL endpoint.\n   * If not present, denotes the default repository (having the ID \"default\" in the RepositoryManager).\n   */\n  iri?: string;\n\n  /**\n   * Textual label denoting the repository.\n   */\n  label: string;\n\n  /**\n   * True if dataset should be selected by default.\n   */\n  isDefault?: boolean;\n\n  /**\n   * If true, then error from the repository in fedarate query will be ignored (using SILENT from SPARQL 1.1 standard).\n   */\n  silent?: boolean;\n\n  /**\n   * Optional list of alignments with other datasets.\n   */\n  alignments?: Array<DatasetAlignmentConfig>;\n}\n\nexport interface DatasetAlignmentConfig {\n  /**\n   * Alignment IRI, typically some skos:scheme.\n   */\n  iri: string;\n\n  /**\n   * Alignment label.\n   */\n  label: string;\n\n  /**\n   * True if alignment should be selected by default.\n   */\n  isDefault?: boolean;\n}\n\nexport interface DatasetsConfig {\n  /**\n   * If true, denotes a federated scenario, in which the search query must be sent\n   * to multiple repositories (described in the datasets property).\n   */\n  federated?: boolean;\n\n  /**\n   * The list of datasets which should be queried.\n   * If not provided, only the search will only affect the default repository.\n   */\n  datasets?: Array<SearchDatasetConfig>;\n\n  /**\n   * Query pattern that is used to discriminate items between datasets in non-federated mode.\n   * This pattern will be applied to tree selector queries, resource selector queries,\n   * facet queries and final result query. At the runtime `__dataset__`\n   * will be bound to dataset selected by the user.\n   *\n   * @default `\n   *   GRAPH ?__dataset__ {\n   *      ?subject a ?t .\n   *    }\n   *\n   *  `\n   */\n  datasetPattern?: string;\n}\n\nexport interface SemanticSearchConfig {\n  /**\n   * Unique HTML id that is used by all nested search-related components, used when one need to have multiple search interfaces on the same page.\n   */\n  id?: string;\n\n  /**\n   * Definition of the categories to be used in structured search. Specified kind will be use\n   * for all relations that have given category as a range.\n   *\n   * If not specified otherwise, by default, all categories/relations from Search Profile\n   * are considered of kind 'resource'.\n   */\n  categories?: Patterns;\n\n  /**\n   * Definition of the relations to be used in structured search.\n   *\n   * If not specified otherwise, by default, all categories/relations from Search Profile\n   * are considered of kind 'resource'.\n   */\n  relations?: Patterns;\n\n  /**\n   * Search Profile defines list of categories and relations available in the search.\n   */\n  searchProfile: SearchProfileConfig;\n\n  /**\n   * Multi-datasets search configuration.\n   * If not provided, only the search will only affect the default repository.\n   */\n  datasetsConfig?: DatasetsConfig;\n\n  /**\n   * Maximal number of answers to be returned\n   *\n   * @default 1000\n   */\n  limit?: number;\n\n  /**\n   * Specifies if any optimizer 'magic' patterns are included\n   * for the specific repository type.\n   */\n  optimizer?: 'blazegraph' | 'none';\n\n  /**\n   * Specifies a mode for category and relation selectors to operate in:\n   *   `stack` - vertical stack of buttons.\n   *   `dropdown` - dropdown field.\n   */\n  selectorMode?: 'stack' | 'dropdown';\n}\n\n/**\n * Mapping of categories/relations IRIs (fully qualified IRI enclosed in <>) to corresponding UI input components and generated query patterns.\n * Every IRI can have multiple kinds, e.g it makes sense to have a category that, at the same time,\n * represents `hierarchy` and `place`.\n *\n * Currently supported kinds of categories/relations:\n *\n * 1) `resource` - any RDF Resource, selection of value is performed with autosuggestion dropdown.\n * 2) `hierarchy` - RDF Resource that belongs to some hierarchy (e.g. with `skos:broader`),\n *                  selection of value is performed with hierarchical tree-selector with.\n * 3) `date-range` - date range values, in the simple case begin and end of the range.\n *                   can be represented with the same value.\n *                   Selection of value is performed with speciall date-range selection components.\n * 4) `place` - geo-spatial value. Selection of value is performed with visual region selector.\n * 5) `text` - speciall kind that is used as a marker for full-text search.\n * 6) `set` - special kind that is used as a marker for the ability to use set of items as input, can be used only in combination with `resource` or `hierarchy` kind.\n * 7) `literal`\n * 8) `numeric-range`\n *\n * Special variable, common to all patterns, that are substituted with user selected values:\n *   * `__domain__` - search domain category IRI\n *   * `__range__` - conjunct range category IRI\n *   * `__relation__` - conjunct relation IRI\n *   * `__relationPattern__` - conjunct relation query pattern\n *\n * In all query patterns ?subject variable refers to result projection variable,\n * and should be always present in the query pattern. All other free variables except ?subject,\n * variable are randomized to prevent name collisions.\n * So for example resource pattern like:\n *\n * ```sparql\n * ?subject ?__relation__ ?holder .\n * ?holder ?p ?__value__ .\n * ```\n *\n * Will be rewritten and all special variables will be replaced by user selected values:\n *\n * ```\n * ?subject <http://example/com/relation> ?holder_tgyzctyko3oozv2jzto6r .\n * ?holder_tgyzctyko3oozv2jzto6r <http://example.cm/some_resource> .\n * ```\n */\nexport interface Patterns {\n  [key: string]: Array<PatternConfig>;\n}\n\nexport type PatternConfig = Resource | Hierarchy | DateRange | Place | Text | Set | Literal | NumericRange;\n\nexport interface Resource {\n  kind: 'resource';\n\n  /**\n   * Injected variables:\n   *  * `__value__` - user selected value IRI\n   *\n   * @default `$subject ?__relation__ ?__value__ .`\n   */\n  queryPattern: string;\n}\n\nexport interface DateRange {\n  kind: 'date-range';\n\n  /**\n   * Injected variables:\n   *   * `__dateBeginValue__` - xsd:date literal\n   *   * `__dateEndValue__` - xsd:date literal\n   *\n   * Keep in mind that there is no default query pattern for `date-range` kind,\n   * because date representation is always domain specific.\n   */\n  queryPattern: string;\n\n  /**\n   * Datatype for injected variables.\n   *\n   * @default xsd:date\n   */\n  datatype?: string;\n\n  /**\n   * moment.js format pattern for injected values.\n   *\n   * @default YYYY-MM-DD\n   */\n  format?: string;\n}\n\nexport interface Hierarchy {\n  kind: 'hierarchy';\n\n  /**\n   * Injected variables:\n   *  * `__value__` - user selected value IRI\n   *\n   * @default `$subject ?__relation__ ?__value__ .`\n   */\n  queryPattern: string;\n}\n\nexport interface Text {\n  kind: 'text';\n\n  /**\n   * Injected variables:\n   *   * `__value__` - string literal with user input. User input is split into words and interleaved with `*`. E.g for the user input \"Hello World\", injected literal will be \"Hello* World*\"\n   *\n   * @default `$subject ?__relation__ ?__value__ .`\n   */\n  queryPattern: string;\n\n  /**\n   * IRI of the help page to explain any special syntax used in the text search.\n   * Must be a fully qualified IRI enclosed in <>.\n   * Default: <http://help.researchspace.org/resource/SolrFullTextSearchSyntax> (shown if escapeLuceneSyntax is false)\n   *\n   */\n  helpPage?: string;\n\n  /**\n   * A flag determining whether any special Lucene syntax will be escaped.\n   * When `false` lucene syntax in the user input is not escaped.\n   *\n   * @default true\n   */\n  escapeLuceneSyntax?: boolean;\n\n  /**\n   * A flag determining whether the user input is tokenized by whitespace into words postfixed by `*`.\n   * E.g. the search for `Hello World` becomes `Hello* World*`.\n   *\n   * @default true\n   */\n  tokenizeLuceneQuery?: boolean;\n}\n\nexport interface Place {\n  kind: 'place';\n\n  /**\n   * Injected variables:\n   *   * `__geoCenter__` - coordinates of the circle center, default is xsd:string literal in the `lat#long` format\n   *   * `__geoCenterLat__` - xsd:string literal with the latitude of the circle center\n   *   * `__geoCenterLong__` - xsd:string literal with the longitude of the circle center\n   *   * `__geoDistance__` - xsd:string literal with radius of the circle in km\n   */\n  distanceQueryPattern: string;\n\n  /**\n   * Injected variables:\n   *   `__geoSouthWest__` - coordinates of the south-west bounding-box corner, default is xsd:string literal in the `lat#long` format\n   *   `__geoSouthWestLat__` - xsd:string literal with the latitude of the south-west bounding-box corner\n   *   `__geoSouthWestLong__` - xsd:string literal with the longitude of the south-west bounding-box corner\n   *   `__geoNorthEast__` - coordinates of the north-east bounding-box corner, default is xsd:string literal in the `lat#long` format\n   *   `__geoNorthEastLat__` - xsd:string literal with the latitude of the north-east bounding-box corner\n   *   `__geoNorthEastLong__` - xsd:string literal with the longitude of the north-east bounding-box corner\n   */\n  boundingBoxQueryPattern: string;\n\n  /**\n   * format pattern for injected coordinates\n   *\n   * @default `lat#long`\n   */\n  format?: string;\n\n  /**\n   * datatype for injected coordinates\n   *\n   * @default http://www.w3.org/2001/XMLSchema#string\n   */\n  datatype?: string;\n}\n\nexport interface Set {\n  kind: 'set';\n\n  /**\n   * `set` pattern will be combined with corresponding `hierarchy` or `resource` pattern.\n   *\n   * Additional special variables, that will be substituted with values:\n   *   `__set__` - set IRI\n   *\n   * @default `?__set__ ldp:contains/platform:setItem ?__value__ .`\n   */\n  queryPattern: string;\n}\n\nexport interface Literal {\n  kind: 'literal';\n\n  /**\n   * Injected variables:\n   *  * `__literal__` - user selected value literal\n   *\n   * @default `$subject ?__relation__ ?__literal__ .`\n   */\n  queryPattern: string;\n}\n\nexport interface NumericRange {\n  kind: 'numeric-range';\n\n  /**\n   * Injected variables:\n   *   * `__numericRangeBeginValue__` - xsd:double literal\n   *   * `__numericRangeEndValue__` - xsd:double literal\n   *\n   * Currently there is no default query pattern for `numeric-range` kind\n   */\n  queryPattern: string;\n\n  /**\n   * datatype for injected variables, default is http://www.w3.org/2001/XMLSchema#double\n   */\n  datatype?: string;\n}\n\nexport interface SemanticFacetConfig {\n  /**\n   * Unique HTML id that is used by all nested search-related components, used when one need to have multiple search interfaces on the same page.\n   */\n  id?: string;\n\n  /**\n   * Flag to open the facet by default.\n   *\n   * @default false\n   */\n  openByDefault?: boolean;\n\n  /**\n   * Flag to select first category in the categories filter by default.\n   *\n   * Can be used in situations with many categories to reduce facets loading time.\n   *\n   * @default false\n   */\n  selectFirstCategory?: boolean;\n\n  /**\n   * Settings determining the display of categories in the sidebar.\n   */\n  categories?: FacetCategoryConfig;\n\n  /**\n   * Settings determining the display of relations in the sidebar.\n   */\n  relations?: FacetRelationConfig;\n\n  /**\n   * Specialization of the categories to be used in the facet.\n   *\n   * If not specified otherwise, by default, all categories are treated as `resource` kind.\n   */\n  valueCategories?: FacetValuePatterns;\n\n  /**\n   * Specialization of the relations to be used in the facet.\n   *\n   * If not specified otherwise, by default, all relations inherit configuration from categories.\n   */\n  valueRelations?: FacetValuePatterns;\n\n  /**\n   * Query that is used to get values for relations, if no custom value query is specified\n   * in 'valueCategories' or 'valueRelations' mappings.\n   */\n  defaultValueQueries?: {\n    /**\n     * By default it uses 'preferredLabels' properties from the system ui configuration.\n     * E.g if `preferredLabels=rdfs:label,skos:prefLabel` default query will be -\n     * @default\n     * ```\n     *   SELECT ?value ?label (COUNT(DISTINCT $subject) AS ?count) WHERE {\n     *     FILTER(?__facetRelationPattern__)\n     *     ?value rdfs:label|skos:prefLabel ?label .\n     *   }\n     *   GROUP BY ?value ?label\n     *   ORDER BY ?label\n     * ```\n     * Where `FILTER(?__facetRelationPattern__)` will be replaced by a relation pattern if exists\n     * or the default pattern:\n     * ```\n     *   $subject ?__relation__ ?value\n     * ```\n     */\n    resource?: string;\n    /**\n     * @default\n     * ```\n     *   SELECT ?literal (COUNT(DISTINCT $subject) AS ?count) WHERE {\n     *     FILTER(?__facetRelationPattern__)\n     *   }\n     *   GROUP BY ?literal\n     *   ORDER BY ?literal\n     * ```\n     * where `FILTER(?__facetRelationPattern__)` will be replaced by a relation pattern if exists\n     * or the default pattern:\n     * ```\n     *   $subject ?__relation__ ?literal\n     * ```\n     */\n    literal?: string;\n  };\n\n  /**\n   * Default Handlebars template for facet value visualization. Can be overridden for\n   * individual categories/relations in 'valueCategories'/'valueRelations' mappings.\n   *\n   * @default\n   * ```\n   * <mp-highlight highlight=\"{{highlight}}\">{{label.value}}</mp-highlight> ({{count.value}})\n   * ```\n   */\n  defaultValueTemplate?: { resource: string; literal: string };\n\n  /**\n   * Maximal number of the facet values to show.\n   *\n   * @default 10000\n   */\n  facetValuesThreshold?: number;\n\n  /**\n   * If true facet will automatically switch open relations based on the context relation used\n   * in the visualization .\n   *\n   * @default false\n   */\n  listenToContextSwitch?: boolean;\n}\n\n/**\n * Mapping of categories/relations IRIs (fully qualified IRI enclosed in <>) to corresponding UI input components and generated query pattern.\n *\n * Currently supported kinds of categories/relations:\n * 1) `resource` - any RDF resource, selection of value is performed with checkbox.\n * 2) `date-range` - date range values, selection of value is performed with slider.\n */\nexport interface FacetValuePatterns {\n  [iri: string]: FacetValuePattern;\n}\nexport type FacetValuePattern = ResourceFacetValue | DateRangeFacetValue | LiteralFacetValue | NumericRangeFacetValue;\n\nexport const FACET_VARIABLES = {\n  RELATION_VAR: '__relation__',\n  RELATION_PATTERN_VAR: '__facetRelationPattern__',\n  RANGE_VAR: '__range__',\n  DOMAIN_VAR: '__domain__',\n  VALUE_RESOURCE_VAR: 'value',\n  VALUE_RESOURCE_LABEL_VAR: 'label',\n  VALUE_DATE_RANGE_BEGIN_VAR: 'dateBeginValue',\n  VALUE_DATE_RANGE_END_VAR: 'dateEndValue',\n  VALUE_LITERAL: 'literal',\n  VALUE_NUMERIC_RANGE_BEGIN_VAR: 'numericRangeBeginValue',\n  VALUE_NUMERIC_RANGE_END_VAR: 'numericRangeEndValue',\n};\nexport interface ResourceFacetValue {\n  kind: 'resource';\n  /**\n   * @default see FacetConfig.defaultValueQueries.resource\n   */\n  valuesQuery?: string;\n  tupleTemplate?: string;\n}\nexport interface DateRangeFacetValue {\n  kind: 'date-range';\n\n  /**\n   * Base search query will be injected as a sub-query with $subject as projection variable.\n   *\n   * Expected projection variables:\n   *   * `?dateBeginValue` - begin of the date range interval\n   *   * `?dateEndValue` - end of the date range interval\n   *\n   * Injected variables:\n   *   * `__domain__` - search domain IRI\n   *   * `__range__` - facet relation range IRI\n   *   * `__relation__` - facet relation IRI\n   *\n   */\n  valuesQuery: string;\n}\n\nexport interface LiteralFacetValue {\n  kind: 'literal';\n  /**\n   * @default see FacetConfig.defaultValueQueries.literal\n   */\n  valuesQuery: string;\n  tupleTemplate?: string;\n}\nexport interface NumericRangeFacetValue {\n  kind: 'numeric-range';\n  valuesQuery: string;\n}\n\nexport interface FacetCategoryConfig {\n  /**\n   * HTML template defining how each category link will be displayed in the sidebar.\n   */\n  tupleTemplate: string;\n}\n\nexport interface FacetRelationConfig {\n  /**\n   * HTML template defining how each category link will be displayed in the sidebar.\n   */\n  tupleTemplate: string;\n}\n\n/**\n * Extracts the pattern config for the given category IRI.\n * Returned value depends on the type of the category (e.g., Resource, Hierarchy, Text, DateRange).\n * If the given IRI does not represent a valid category from the search configuration profile,\n * returns undefined.\n */\nexport function getConfigPatternForCategory(\n  config: SemanticSearchConfig,\n  category: Rdf.Iri\n): PatternConfig | undefined {\n  const patternConfigs = config.categories[category.toString()];\n  if (patternConfigs && patternConfigs.length > 0) {\n    return patternConfigs[0];\n  } else {\n    return undefined;\n  }\n}\n\nexport function isQuerySearchProfileConfig(config: SearchProfileConfig): config is QuerySearchProfileConfig {\n  return _.has(config, 'relationsQuery');\n}\n"],"sourceRoot":""}