{"version":3,"sources":["webpack:///./src/main/web/components/forms/ResourceEditorForm.ts","webpack:///./src/main/web/components/forms/persistence/TriplestorePersistence.ts","webpack:///./src/main/web/components/forms/persistence/PersistenceUtils.ts","webpack:///./src/main/web/components/forms/persistence/SparqlPersistence.ts","webpack:///./src/main/web/components/forms/persistence/RawSparqlPersistence.ts","webpack:///./src/main/web/components/forms/SemanticForm.ts","webpack:///./src/main/web/components/forms/inputs/index.ts","webpack:///./src/main/web/components/forms/Serialization.ts","webpack:///./src/main/web/components/forms/persistence/LdpPersistence.ts"],"names":["BROWSER_PERSISTENCE","BrowserPersistence","adapter","props","context","cancellation","Cancellation","unmounted","mapChildren","children","Children","map","element","isValidChild","componentHasType","ResourceEditorForm","type","name","cloneElement","disabled","initialState","state","submitting","onClick","onReset","canSubmit","onSubmit","onRemove","createElement","ref","value","style","display","onChange","onChangeLoadData","onLoadData","onSaveData","RecoverNotification","recoveredFromStorage","discardRecoveredData","resetFormData","universalChildren","e","preventDefault","stopPropagation","validatedModel","form","validate","model","readyToSubmit","FieldError","isPreventSubmit","setState","finalize","flatMap","finalModel","persistence","persist","addToDefaultSet","subject","id","Kefir","constant","observe","resetStorage","isNewSubject","CompositeValue","isPlaceholder","performFormPostAction","postAction","eventProps","sourceId","queryParams","getPostActionUrlQueryParams","error","addNotification","level","message","itemToRemove","remove","isRemovedSubject","valuePatch","computeValuePatch","FieldValue","empty","formId","dataToSave","JSON","stringify","fileData","Blob","fileName","moment","format","fileSaver","saveAs","event","target","files","currentFile","loadTextFileFromInput","file","stream","emitter","reader","FileReader","onload","emit","result","end","onerror","readAsText","readyState","abort","data","loadedData","parse","patched","applyValuePatch","input","click","saveToStorage","browserPersistenceEnabled","patch","set","computePersistentId","loadFromStorage","get","err","console","warn","Boolean","browserPersistence","getFormId","getCurrentResource","normalizePersistenceMode","persistenceProp","repository","LdpPersistence","isTriplestorePersistence","config","configWithRepository","SparqlPersistence","RawSparqlPersistence","unknownConfig","undefined","componentDidMount","this","validateFields","listen","eventType","FormEvents","FormRemoveResource","iri","componentWillUnmount","cancelAll","invalidFields","getInvalidFields","fields","validateNestedFormsFields","length","invalidFieldsIds","uniqBy","join","forEach","CompositeInput","concat","invalidNestedFormsFields","render","ErrorNotification","errorMessage","formProps","fromLabeled","getSubject","newSubjectTemplate","onLoaded","loadedModel","initialized","initializeModel","onChanged","onUpdated","modelState","DataState","Ready","debug","SemanticForm","applyCachedData","isComposite","inputKind","InputKind","Component","subjectIri","Rdf","filter","field","insertPattern","deletePattern","isPlaceholderComposite","obj","computeModelDiff","base","changed","collectCompositeDiff","EMPTY_VALUES","Immutable","List","Error","fieldId","definition","definitions","changedValues","getFieldValues","composite","isEmpty","values","collectFieldDiff","has","baseSet","filterNot","isAtomic","isForcedDefault","asRdfNode","node","toSet","changedSet","deleted","subtract","toArray","inserted","push","baseComposites","pickComposites","changedComposites","baseComposite","subjectKey","changedComposite","Map","parseQueryStringAsUpdateOperation","queryString","query","SparqlUtil","parseQuery","withNamedGraph","targetGraphIri","updates","u","addInsertIntoGraph","insertOrDelete","updateType","insert","triples","initialModel","currentModel","targetInsertGraphIri","updateQueries","createFormUpdateQueries","stringQueries","serializeQuery","flatten","req","request","post","send","fromNodeCallback","cb","res","body","toProperty","size","log","zip","SparqlClient","executeSparqlUpdate","entries","deleteQuery","updateOperation","createFieldUpdateQueries","insertQuery","queries","paramterize","setBindings","update","toList","LoadingState","loadingState","None","updateModel","reducer","pendingModel","onCompositeMounted","handler","makeHandler","baseInputProps","componentWillReceiveProps","nextProps","componentDidUpdate","prevProps","dataState","Loading","modelOrDataStateChanged","lastDataState","asDebugJSObject","Completed","validated","finalized","constantError","Spinner","hasConfigurationErrors","errors","some","kind","ErrorKind","Configuration","D","div","className","updateValue","title","FormErrors","pre","EmptyValue","AtomicValue","toString","label","toObject","createFactory","AutocompleteInput","AutocompleteInputProps","CheckboxInput","CheckboxInputProps","ChecklistInput","ChecklistInputProps","ChecklistType","DatePickerInput","DatePickerInputProps","DatePickerMode","FormSwitch","FormSwitchProps","FormSwitchCase","FormSwitchCaseProps","HiddenInput","HiddenInputProps","PlainTextInput","PlainTextInputProps","SelectInput","SelectInputProps","TreePickerInput","TreePickerInputProps","asPatch","changedAtomic","equals","computeCompositePatch","equalRdfTerms","discriminator","visited","patchFields","hasAtLeastOnePatch","visit","baseState","changedState","baseLength","statePatch","computeFieldPatch","changedValue","index","p","turtle","serialize","nodeToN3","unknownFieldType","a","b","asValue","applyCompositePatch","patchDiscriminator","tryDeserializeN3","applyFieldPatch","Array","isArray","baseValue","FieldState","toMap","nodeValue","isLiteral","isIri","noErrors","Iri","states","Object","keys","v","n3value","deserialize","n3ValueToRdf","deleteSubjectContainer","persistModelUpdates","LdpService","VocabPlatform","FormContainer","deleteResource","listOfConstructs","createFormConstructQueries","sendConstructsToBackend","entry","createFieldConstructQueries","newValues","constructQueries","constructQuery","prefixes","queryType","insertDeleteOperations","pop","template","reduce","ar","cloneDeep","where","getTargetLdpResource","getTargetRepository","requestAsProperty","delete","containerIri"],"mappings":"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","file":"semantic-form-d984833e26919348bd17.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { Props, ReactNode, Children, cloneElement, MouseEvent, createElement } from 'react';\nimport * as Kefir from 'kefir';\nimport { uniqBy } from 'lodash';\nimport * as fileSaver from 'file-saver';\nimport * as moment from 'moment';\n\nimport { Cancellation } from 'platform/api/async';\nimport { Component } from 'platform/api/components';\nimport { getCurrentResource } from 'platform/api/navigation';\nimport { Rdf } from 'platform/api/rdf';\nimport { addNotification } from 'platform/components/ui/notification';\nimport { addToDefaultSet } from 'platform/api/services/ldp-set';\nimport { BrowserPersistence, isValidChild, componentHasType, universalChildren } from 'platform/components/utils';\nimport { ErrorNotification } from 'platform/components/ui/notification';\nimport { listen } from 'platform/api/events';\n\nimport { FieldDefinitionProp } from './FieldDefinition';\nimport { DataState, FieldValue, FieldError, CompositeValue } from './FieldValues';\nimport { readyToSubmit } from './FormModel';\nimport { SemanticForm, SemanticFormProps } from './SemanticForm';\nimport { ValuePatch, computeValuePatch, applyValuePatch } from './Serialization';\n\nimport { TriplestorePersistence, isTriplestorePersistence } from './persistence/TriplestorePersistence';\nimport { LdpPersistence } from './persistence/LdpPersistence';\nimport { SparqlPersistence } from './persistence/SparqlPersistence';\nimport { RawSparqlPersistence } from './persistence/RawSparqlPersistence';\nimport { SparqlPersistence as SparqlPersistenceClass } from './persistence/SparqlPersistence';\nimport { RecoverNotification } from './static/RecoverNotification';\n\nimport { CompositeInput } from './inputs/CompositeInput';\nimport * as FormEvents from './FormEvents';\nimport {\n  ResourceEditorFormProps, TriplestorePersistenceConfig, performFormPostAction, getPostActionUrlQueryParams,\n} from './ResourceEditorFormConfig';\nimport { InputKind } from './inputs/InputCommpons';\n\ninterface State {\n  readonly model?: CompositeValue;\n  readonly modelState?: DataState;\n  readonly submitting?: boolean;\n  readonly recoveredFromStorage?: boolean;\n  readonly error?: string;\n}\n\nconst BROWSER_PERSISTENCE = BrowserPersistence.adapter<ValuePatch>();\n\n/**\n * Form component to create and edit resources represented by input fields.\n *\n * The component supports submitting or reverting the form to the intial\n * state by specifying <button> element as child with the following name attribute:\n *   'reset' - revert form content to intial state.\n *   'submit' - persist form content as new or edited resource.\n *\n * This functionality can be used to backup form data,\n * to clone forms and to create multiple similar forms\n * without read access to the repository.\n *   'load-state' - load file from disk.\n *   'save-state' - save file to disk.\n *\n * @example\n * <resource-editor-form subject='http://exmaple.com/thing/foo' fields='{[...]}'>\n *   <!-- all the children will be passed down to SemanticForm -->\n *   <plain-text-input for='person-name'></plain-text-input>\n *   <div style='color: blue;'>\n *     <datetimepicker-text-input for='event-date'>\n *     </datetimepicker-text-input>\n *   </div>\n *   <!-- Button's onClick handler binds by 'name' attribute -->\n *   <semantic-form-errors></semantic-form-errors>\n *   <button name='reset' type='button' class='btn btn-default'>Reset</button>\n *   <button name='submit' type='button' class='btn btn-primary'>Submit</button>\n *   <button name='load-state' type='button' class='btn btn-info'>Load to file</button>\n *   <button name='save-state' type='button' class='btn btn-info'>Save to file</button>\n * </resource-editor-form>\n *\n * @example\n *  <!-- enable storing and recovering intermediate inputs from client persistence layer -->\n *  <resource-editor-form\n *  \tsubject='http://exmaple.com/thing/foo'\n *  \tfields='{[...]}'\n *  \tbrowser-persistence=true\n *  >\n *    <semantic-form-recover-notification></semantic-form-recover-notification>\n *    <!-- ... -->\n *  <resource-editor-form>\n *\n *  <!--\n *   custom form identifier for client persistence when using multiple forms on the same page\n *  -->\n *  <resource-editor-form\n *  \tsubject='http://exmaple.com/thing/foo'\n *  \tfields='{[...]}'\n *    browser-persistence=true\n *  \tform-id='form123'\n *  >\n *    <semantic-form-recover-notification></semantic-form-recover-notification>\n *    <!-- ... -->\n *  <resource-editor-form>\n */\nexport class ResourceEditorForm extends Component<ResourceEditorFormProps, State> {\n  public static readonly inputKind = InputKind.SemanticForm;\n\n  private initialState: State;\n  private persistence: TriplestorePersistence;\n\n  private form: SemanticForm;\n\n  private readonly cancellation = new Cancellation();\n  private unmounted = false;\n\n  constructor(props: ResourceEditorFormProps, context) {\n    super(props, context);\n\n    // TODO: add ability to use non-default repository to fetch and persist data\n    this.persistence = normalizePersistenceMode(this.props.persistence, 'default');\n\n    this.state = {\n      model: undefined,\n      submitting: false,\n    };\n  }\n\n  componentDidMount() {\n    if (this.persistence instanceof SparqlPersistenceClass) {\n      this.validateFields();\n    }\n\n    if (this.props.id) {\n      this.cancellation.map(\n        listen({\n          target: this.props.id,\n          eventType: FormEvents.FormRemoveResource,\n        })\n      ).observe({\n        value: (event) => {\n          if (event.data.iri === this.props.subject) {\n            this.onRemove();\n          }\n        }\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.cancellation.cancelAll();\n    this.unmounted = true;\n  }\n\n  private validateFields() {\n    const invalidFields = [\n      ...getInvalidFields(this.props.fields),\n      ...this.validateNestedFormsFields(this.props.children),\n    ];\n    if (invalidFields.length) {\n      const invalidFieldsIds = uniqBy(invalidFields, 'id')\n        .map(({ id }) => `\"${id}\"`)\n        .join(', ');\n      this.setState({\n        error: `The fields [${invalidFieldsIds}] don't have INSERT or DELETE patterns`,\n      });\n    }\n  }\n\n  private validateNestedFormsFields(children: ReactNode): FieldDefinitionProp[] {\n    let invalidFields: FieldDefinitionProp[] = [];\n    Children.forEach(children, (element) => {\n      if (!isValidChild(element)) {\n        return;\n      }\n      if (componentHasType(element, CompositeInput)) {\n        invalidFields = invalidFields.concat(getInvalidFields(element.props.fields));\n      }\n      if (element.props.children) {\n        const invalidNestedFormsFields = this.validateNestedFormsFields(element.props.children);\n        invalidFields = invalidFields.concat(invalidNestedFormsFields);\n      }\n    });\n    return invalidFields;\n  }\n\n  public render() {\n    if (this.state.error) {\n      return createElement(ErrorNotification, { errorMessage: this.state.error });\n    }\n\n    const formProps: SemanticFormProps & Props<SemanticForm> = {\n      ref: (form: SemanticForm) => {\n        this.form = form;\n      },\n      fields: this.props.fields,\n      model: this.state.model || FieldValue.fromLabeled({ value: getSubject(this.props) }),\n      newSubjectTemplate: this.props.newSubjectTemplate,\n      onLoaded: (loadedModel) => {\n        const initialized = this.props.initializeModel ? this.props.initializeModel(loadedModel) : loadedModel;\n        this.initialState = {\n          model: initialized,\n          submitting: false,\n          recoveredFromStorage: false,\n        };\n        const { model, recoveredFromStorage } = this.applyCachedData(this.initialState.model);\n        this.setState({ model, recoveredFromStorage, submitting: false });\n      },\n      onChanged: (model) => {\n        this.setState({ model });\n      },\n      onUpdated: (modelState) => {\n        this.setState({ modelState });\n        if (this.initialState && modelState === DataState.Ready) {\n          this.saveToStorage(this.state.model);\n        }\n      },\n      debug: this.props.debug,\n    };\n    return createElement(SemanticForm, formProps, this.mapChildren(this.props.children));\n  }\n\n  private applyCachedData(model: CompositeValue): { model: CompositeValue; recoveredFromStorage: boolean } {\n    const patch = this.loadFromStorage();\n    const patched = applyValuePatch(model, patch);\n    if (patched === model || !FieldValue.isComposite(patched)) {\n      return { model, recoveredFromStorage: false };\n    } else {\n      return { model: patched, recoveredFromStorage: true };\n    }\n  }\n\n  private canSubmit() {\n    return (\n      this.initialState &&\n      !this.state.submitting &&\n      this.state.modelState === DataState.Ready &&\n      readyToSubmit(this.state.model, FieldError.isPreventSubmit)\n    );\n  }\n\n  private mapChildren = (children: ReactNode): ReactNode => {\n    return Children.map(children, (element) => {\n      if (!isValidChild(element)) {\n        return element;\n      }\n\n      if (componentHasType(element, ResourceEditorForm)) {\n        // pass nested editor as is to support independent nested record creation\n        return element;\n      }\n\n      if (element.type === 'button') {\n        switch (element.props.name) {\n          case 'reset':\n            return cloneElement(element, {\n              disabled: !this.initialState || this.state.submitting,\n              onClick: this.onReset,\n            });\n          case 'submit':\n            return cloneElement(element, {\n              disabled: !this.canSubmit(),\n              onClick: this.onSubmit,\n            });\n          case 'delete':\n            return cloneElement(element, {\n              disabled: !this.canSubmit(),\n              onClick: this.onRemove,\n            });\n          case 'load-state': {\n            let input: HTMLInputElement;\n            const setInput = (value: HTMLInputElement) => (input = value);\n            return [\n              createElement('input', {\n                ref: setInput,\n                type: 'file',\n                style: { display: 'none' },\n                onChange: this.onChangeLoadData,\n              }),\n              cloneElement(element, {\n                onClick: () => this.onLoadData(input),\n              }),\n            ];\n          }\n          case 'save-state':\n            return cloneElement(element, {\n              onClick: this.onSaveData,\n            });\n        }\n        return element;\n      }\n\n      if (componentHasType(element, RecoverNotification)) {\n        return cloneElement(element, {\n          recoveredFromStorage: this.state.recoveredFromStorage,\n          discardRecoveredData: () => this.resetFormData(),\n        });\n      }\n\n      // need to map recursively through all children to find also deep nested\n      // buttons (i.e. in tabs) or editors\n      if (element.props.children) {\n        return cloneElement(element, {}, universalChildren(this.mapChildren(element.props.children)));\n      }\n\n      return element;\n    });\n  };\n\n  private onReset = (e: MouseEvent<HTMLElement>) => {\n    // we need to prevent default action because button is inside form and\n    // we don't want to submit the form\n    e.preventDefault();\n    e.stopPropagation();\n    this.resetFormData();\n  };\n\n  private resetFormData() {\n    let state = this.initialState;\n    if (this.props.initializeModel) {\n      state = {\n        model: this.props.initializeModel(state.model),\n        submitting: false,\n        recoveredFromStorage: false,\n      };\n    }\n\n    this.resetStorage();\n    this.setState(state);\n  }\n\n  private onSubmit = (e: MouseEvent<HTMLElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    const validatedModel = this.form.validate(this.state.model);\n    if (readyToSubmit(validatedModel, FieldError.isPreventSubmit)) {\n      this.setState((state) => ({ model: validatedModel, submitting: true }));\n\n      const initialModel = this.initialState.model;\n      this.form\n        .finalize(this.state.model)\n        .flatMap((finalModel) =>\n          this.persistence\n            .persist(initialModel, finalModel)\n            .map(() =>\n              this.props.addToDefaultSet ? addToDefaultSet(finalModel.subject, this.props.id) : Kefir.constant(true)\n            )\n            .map(() => finalModel)\n        )\n        .observe({\n          value: (finalModel) => {\n            // only ignore setState() and always reset localStorage and perform post-action\n            // event if the form is already unmounted\n            this.resetStorage();\n            if (!this.unmounted) {\n              this.setState({ model: finalModel, submitting: false });\n            }\n            const isNewSubject =\n              !this.initialState.model || CompositeValue.isPlaceholder(this.initialState.model.subject);\n            performFormPostAction({\n              postAction: this.props.postAction,\n              subject: finalModel.subject,\n              eventProps: { isNewSubject, sourceId: this.props.id },\n              queryParams: getPostActionUrlQueryParams(this.props),\n            });\n          },\n          error: (error) => {\n            if (!this.unmounted) {\n              this.setState({ submitting: false });\n            }\n            addNotification({ level: 'error', message: 'Failed to submit the form' }, error);\n          },\n        });\n    } else {\n      this.setState((state) => ({ model: validatedModel, submitting: false }));\n    }\n  };\n\n  private onRemove = () => {\n    const itemToRemove = this.initialState.model.subject;\n    this.persistence\n      .remove(this.initialState.model)\n      .observe({\n        value: () => {\n          performFormPostAction({\n            postAction: this.props.postAction,\n            subject: itemToRemove,\n            eventProps: { isNewSubject: false, isRemovedSubject: true, sourceId: this.props.id },\n            queryParams: getPostActionUrlQueryParams(this.props),\n          });\n        },\n        error: () => {}\n      })\n    ;\n  }\n\n  private onSaveData = () => {\n    const valuePatch: ValuePatch = computeValuePatch(FieldValue.empty, this.state.model);\n    const formId = this.props.formId;\n    const dataToSave = JSON.stringify({ formId: formId, valuePatch: valuePatch });\n    const fileData = new Blob([dataToSave]);\n    const fileName = `${formId}-${moment().format()}.json`;\n\n    fileSaver.saveAs(fileData, fileName);\n  };\n\n  private onChangeLoadData = (event: React.ChangeEvent<HTMLInputElement>) => {\n    if (event && event.target.files) {\n      const currentFile = event.target.files[0];\n      event.target.value = '';\n      this.cancellation.map(loadTextFileFromInput(currentFile)).observe({\n        value: (data) => {\n          const loadedData: { formId: string; valuePatch: ValuePatch } = JSON.parse(data);\n          if (loadedData.formId === this.props.formId) {\n            const patched = applyValuePatch(this.state.model, loadedData.valuePatch);\n            this.setState({ model: patched as CompositeValue });\n          }\n        },\n        error: (error) => {\n          this.setState({ error });\n        },\n      });\n    }\n  };\n\n  private onLoadData = (input: HTMLInputElement) => {\n    input.click();\n  };\n\n  private computePersistentId(): string {\n    return this.getFormId() + ':' + getCurrentResource().value;\n  }\n\n  private saveToStorage = (model: CompositeValue): void => {\n    if (this.browserPersistenceEnabled() && this.initialState) {\n      const patch = computeValuePatch(this.initialState.model, model);\n      BROWSER_PERSISTENCE.set(this.computePersistentId(), patch);\n    }\n  };\n\n  private loadFromStorage = (): ValuePatch => {\n    if (this.browserPersistenceEnabled()) {\n      try {\n        return BROWSER_PERSISTENCE.get(this.computePersistentId());\n      } catch (err) {\n        console.warn(err);\n      }\n    }\n    return null;\n  };\n\n  private resetStorage = (): void => {\n    if (this.browserPersistenceEnabled()) {\n      BROWSER_PERSISTENCE.remove(this.computePersistentId());\n    }\n  };\n\n  /**\n   * Whether changes should be persisted or recovered from the client-side\n   * persistence layer. Disabled by default.\n   */\n  private browserPersistenceEnabled = (): boolean => {\n    return Boolean(this.props.browserPersistence);\n  };\n\n  /**\n   * Returns a id to be used as identifier for the client-side persistence layer.\n   * If no custom formId is set, the current  {@link ResourceContext} will be returned.\n   */\n  private getFormId = (): string => {\n    return this.props.formId ? this.props.formId : getCurrentResource().value;\n  };\n}\n\n\nfunction normalizePersistenceMode(\n  persistenceProp:\n    | TriplestorePersistenceConfig['type']\n    | TriplestorePersistenceConfig\n    | TriplestorePersistence\n    | undefined,\n  repository: string\n): TriplestorePersistence {\n  if (!persistenceProp) {\n    return new LdpPersistence();\n  } else if (isTriplestorePersistence(persistenceProp)) {\n    return persistenceProp;\n  }\n\n  const config =\n    typeof persistenceProp === 'string' ? ({ type: persistenceProp } as TriplestorePersistenceConfig) : persistenceProp;\n\n  const configWithRepository = { repository, ...config };\n  switch (configWithRepository.type) {\n    case 'sparql':\n      return new SparqlPersistence(configWithRepository);\n    case 'client-side-sparql':\n      return new RawSparqlPersistence(configWithRepository);\n    case 'ldp':\n      return new LdpPersistence(configWithRepository);\n    default: {\n      const unknownConfig = configWithRepository as TriplestorePersistenceConfig;\n      console.warn(`Unknown from persistence type '${unknownConfig.type}', using LDP as fallback`);\n      return new LdpPersistence();\n    }\n  }\n}\n\n/**\n * Returns the current subject as {@link Rdf.Iri} by guessing\n * from the supplied properties. Will return <> if undefined.\n */\nfunction getSubject(props: ResourceEditorFormProps): Rdf.Iri {\n  let subjectIri = props.subject;\n  if (typeof subjectIri === 'string') {\n    subjectIri = Rdf.iri(subjectIri);\n  }\n  return subjectIri || Rdf.iri('');\n}\n\nfunction getInvalidFields(fields: ReadonlyArray<FieldDefinitionProp>) {\n  return fields.filter((field) => !field.insertPattern || !field.deletePattern);\n}\n\nfunction loadTextFileFromInput(file: File): Kefir.Stream<string> {\n  return Kefir.stream((emitter) => {\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      emitter.emit((event.target as FileReader).result as string);\n      emitter.end();\n    };\n    reader.onerror = (event) => {\n      emitter.error(event);\n      emitter.end();\n    };\n    reader.readAsText(file);\n    return () => {\n      if (reader.readyState === 1 /* LOADING */) {\n        reader.abort();\n      }\n    };\n  });\n}\n\nexport default ResourceEditorForm;\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Immutable from 'immutable';\nimport * as Kefir from 'kefir';\n\nimport { Rdf } from 'platform/api/rdf';\n\nimport { FieldDefinition } from '../FieldDefinition';\nimport { FieldValue, CompositeValue, EmptyValue } from '../FieldValues';\n\nexport interface TriplestorePersistence {\n  persist(initialModel: CompositeValue | EmptyValue, currentModel: CompositeValue | EmptyValue): Kefir.Property<void>;\n\n  remove(model: CompositeValue): Kefir.Property<void>;\n}\n\nexport function isTriplestorePersistence(obj: any): obj is TriplestorePersistence {\n  return obj && typeof obj === 'object' && typeof obj.persist === 'function';\n}\n\nexport interface ModelDiffEntry {\n  subject: Rdf.Iri;\n  definition: FieldDefinition;\n  deleted: ReadonlyArray<Rdf.Node>;\n  inserted: ReadonlyArray<Rdf.Node>;\n}\n\nexport function computeModelDiff(\n  base: CompositeValue | EmptyValue,\n  changed: CompositeValue | EmptyValue\n): ModelDiffEntry[] {\n  const result: ModelDiffEntry[] = [];\n  // replace placeholder models with an empty ones to correctly handle default values\n  // (otherwise fields with default values would be considered unchanged)\n  const namedBaseOrEmpty = isPlaceholderComposite(base) ? FieldValue.empty : base;\n  const namedChangedOrEmpty = isPlaceholderComposite(changed) ? FieldValue.empty : changed;\n  collectCompositeDiff(namedBaseOrEmpty, namedChangedOrEmpty, result);\n  return result;\n}\n\nfunction isPlaceholderComposite(value: FieldValue): value is CompositeValue {\n  return FieldValue.isComposite(value) && CompositeValue.isPlaceholder(value.subject);\n}\n\nconst EMPTY_VALUES = Immutable.List<FieldValue>();\n\nfunction collectCompositeDiff(\n  base: CompositeValue | EmptyValue,\n  changed: CompositeValue | EmptyValue,\n  result: ModelDiffEntry[]\n) {\n  \n\n  if (FieldValue.isComposite(base)) {\n    if (CompositeValue.isPlaceholder(base.subject)) {\n      throw new Error('Cannot compute diff with placeholder base composite');\n    }\n    base.fields.forEach((state, fieldId) => {\n      const definition = base.definitions.get(fieldId);\n      const changedValues = getFieldValues(changed, fieldId);\n      collectFieldDiff(base.subject, definition, state.values, changedValues, result);\n    });\n  }\n\n  if (FieldValue.isComposite(changed)) {\n    if (CompositeValue.isPlaceholder(changed.subject)) {\n      throw new Error('Cannot compute diff with placeholder changed composite');\n    }\n    changed.fields.forEach((state, fieldId) => {\n      if (FieldValue.isEmpty(base) || !base.fields.has(fieldId)) {\n        const definition = changed.definitions.get(fieldId);\n        collectFieldDiff(changed.subject, definition, EMPTY_VALUES, state.values, result);\n      }\n    });\n  }\n}\n\nfunction getFieldValues(composite: CompositeValue | EmptyValue, fieldId: string): Immutable.List<FieldValue> {\n  if (FieldValue.isEmpty(composite)) {\n    return EMPTY_VALUES;\n  }\n  const state = composite.fields.get(fieldId);\n  return state ? state.values : EMPTY_VALUES;\n}\n\nfunction collectFieldDiff(\n  subject: Rdf.Iri,\n  definition: FieldDefinition,\n  base: Immutable.List<FieldValue>,\n  changed: Immutable.List<FieldValue>,\n  result: ModelDiffEntry[]\n) {\n  const baseSet = base\n    .filterNot(field => FieldValue.isAtomic(field) && field.isForcedDefault)\n    .map(FieldValue.asRdfNode)\n    .filter((node) => node !== undefined)\n    .toSet();\n  const changedSet = changed\n    .map(FieldValue.asRdfNode)\n    .filter((node) => node !== undefined)\n    .toSet();\n\n  const deleted = baseSet.subtract(changedSet).toArray();\n  const inserted = changedSet.subtract(baseSet).toArray();\n\n  if (deleted.length > 0 || inserted.length > 0) {\n    result.push({ subject, definition, deleted, inserted });\n  }\n\n  const baseComposites = pickComposites(base);\n  const changedComposites = pickComposites(changed);\n\n  baseComposites.forEach((baseComposite, subjectKey) => {\n    const changedComposite = changedComposites.get(subjectKey) || FieldValue.empty;\n    collectCompositeDiff(baseComposite, changedComposite, result);\n  });\n  changedComposites.forEach((changedComposite, subjectKey) => {\n    if (!baseComposites.has(subjectKey)) {\n      collectCompositeDiff(FieldValue.empty, changedComposite, result);\n    }\n  });\n}\n\nfunction pickComposites(values: Immutable.List<FieldValue>): Map<string, CompositeValue> {\n  const result = new Map<string, CompositeValue>();\n  values.forEach((value) => {\n    if (FieldValue.isComposite(value) && !CompositeValue.isPlaceholder(value.subject)) {\n      result.set(value.subject.value, value);\n    }\n  });\n  return result;\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as SparqlJs from 'sparqljs';\n\nimport { SparqlUtil } from 'platform/api/sparql';\n\n/**\n * Util to parse and cast an queryString to an SparqlJs.Update object.\n * Emits an error otherwise.\n *\n * @param {string | undefined} queryString SPARQL update query.\n */\nexport function parseQueryStringAsUpdateOperation(queryString: string | undefined): SparqlJs.Update {\n  if (!queryString) {\n    return undefined;\n  }\n  const query = SparqlUtil.parseQuery(queryString);\n  if (query.type === 'update') {\n    return query;\n  } else {\n    throw new Error('Specified deletePattern or insertPattern is not an update query.');\n  }\n}\n\n/**\n * Add WITH clause to UPDATE query to fully execute it on specific named graph.\n */\nexport function withNamedGraph(\n  query: SparqlJs.Update, targetGraphIri?: string\n): SparqlJs.Update {\n  if (targetGraphIri) {\n    // graph property on update opertian is missing is SparqlJs d.ts file\n    query.updates.forEach(u => u['graph'] = targetGraphIri);\n  }\n  return query;\n}\n\n/**\n * Add GRAPH clause to INSERT part of the UPDATE query to fully execute it on specific named graph.\n */\nexport function addInsertIntoGraph(\n  query: SparqlJs.Update, targetGraphIri?: string\n): SparqlJs.Update {\n  query.updates.forEach(u => {\n    const insertOrDelete = u as SparqlJs.InsertDeleteOperation;\n    if (insertOrDelete.updateType === 'insertdelete') {\n      insertOrDelete.insert =\n        [{\n          type: 'graph',\n          name: targetGraphIri as SparqlJs.Term,\n          triples: insertOrDelete.insert[0].triples,\n        }];\n    }\n  });\n  return query;\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\nimport * as SparqlJs from 'sparqljs';\nimport * as request from 'platform/api/http';\nimport * as Immutable from 'immutable';\n\nimport { SparqlUtil } from 'platform/api/sparql';\n\nimport { CompositeValue, EmptyValue, FieldValue } from '../FieldValues';\nimport { RawSparqlPersistence } from './RawSparqlPersistence';\nimport { TriplestorePersistence } from './TriplestorePersistence';\n\nexport interface SparqlPersistenceConfig {\n  type?: 'sparql';\n  repository?: string;\n  targetGraphIri?: string;\n  targetInsertGraphIri?: string;\n}\n\nexport class SparqlPersistence implements TriplestorePersistence {\n  constructor(private config: SparqlPersistenceConfig = {}) {}\n\n  persist(initialModel: CompositeValue | EmptyValue, currentModel: CompositeValue | EmptyValue): Kefir.Property<void> {\n    const {repository = 'default', targetGraphIri, targetInsertGraphIri} = this.config;\n    const updateQueries =\n      RawSparqlPersistence.createFormUpdateQueries(\n        initialModel, currentModel, targetGraphIri, targetInsertGraphIri\n      );\n\n    const stringQueries = Immutable.List<SparqlJs.ConstructQuery>(updateQueries)\n      .map(SparqlUtil.serializeQuery)\n      .flatten();\n\n    const req = request\n      .post('/form-persistence/sparql')\n      .type('application/json')\n      .query({ repository })\n      .send(stringQueries);\n    return Kefir.fromNodeCallback<void>((cb) => req.end((err, res) => cb(err, res.body))).toProperty();\n  }\n\n  remove(model: CompositeValue): Kefir.Property<void> {\n    return this.persist(model, FieldValue.empty);\n  }\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Immutable from 'immutable';\nimport * as Kefir from 'kefir';\nimport * as SparqlJs from 'sparqljs';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { SparqlClient, SparqlUtil } from 'platform/api/sparql';\n\nimport { CompositeValue, EmptyValue, FieldValue } from '../FieldValues';\nimport { parseQueryStringAsUpdateOperation, withNamedGraph, addInsertIntoGraph } from './PersistenceUtils';\nimport { TriplestorePersistence, computeModelDiff } from './TriplestorePersistence';\nimport { SparqlQueryForm } from 'platform/api/sparql/SparqlClient';\n\nexport interface RawSparqlPersistenceConfig {\n  type?: 'client-side-sparql';\n  repository?: string;\n  targetGraphIri?: string;\n  targetInsertGraphIri?: string;\n}\n\nexport class RawSparqlPersistence implements TriplestorePersistence {\n  constructor(private config: RawSparqlPersistenceConfig = {}) {}\n\n  persist(initialModel: CompositeValue | EmptyValue, currentModel: CompositeValue | EmptyValue): Kefir.Property<void> {\n    const updateQueries =\n      RawSparqlPersistence.createFormUpdateQueries(\n        initialModel, currentModel, this.config.targetGraphIri, this.config.targetInsertGraphIri\n      );\n    if (updateQueries.size === 0) {\n      return Kefir.constant<void>(undefined);\n    }\n    updateQueries.forEach((query) => {\n      console.log(SparqlUtil.serializeQuery(query));\n    });\n    const { repository = 'default' } = this.config;\n    const context: SparqlClient.QueryContext = { repository };\n    const updateOperations = Kefir.zip<void>(\n      updateQueries.map((query) => SparqlClient.executeSparqlUpdate(query, { context })).toArray()\n    );\n    return updateOperations\n      .map(() => {\n        /* void */\n      })\n      .toProperty();\n  }\n\n  remove(model: CompositeValue): Kefir.Property<void> {\n    return this.persist(model, FieldValue.empty);\n  }\n\n  static createFormUpdateQueries(\n    initialModel: CompositeValue | EmptyValue,\n    currentModel: CompositeValue | EmptyValue,\n    targetGraphIri?: string,\n    targetInsertGraphIri?: string,\n  ): Immutable.List<SparqlJs.Update> {\n    const entries = computeModelDiff(initialModel, currentModel);\n    return Immutable.List(entries)\n      .filter(({ definition }) => Boolean(definition.insertPattern && definition.deletePattern))\n      .map(({ definition, subject, inserted, deleted }) => {\n        const deleteQuery = withNamedGraph(\n          parseQueryStringAsUpdateOperation(definition.deletePattern), targetGraphIri\n        );\n\n        const updateOperation = parseQueryStringAsUpdateOperation(definition.insertPattern);\n        const insertQuery =\n          targetInsertGraphIri ?\n          addInsertIntoGraph(updateOperation, targetInsertGraphIri):\n          withNamedGraph(updateOperation, targetGraphIri);\n        return createFieldUpdateQueries(subject, deleteQuery, insertQuery, inserted, deleted);\n      })\n      .filter((update) => update.size > 0)\n      .flatten()\n      .toList();\n  }\n}\n\nfunction createFieldUpdateQueries(\n  subject: Rdf.Iri,\n  deleteQuery: SparqlJs.Update | undefined,\n  insertQuery: SparqlJs.Update | undefined,\n  inserted: ReadonlyArray<Rdf.Node>,\n  deleted: ReadonlyArray<Rdf.Node>\n): Immutable.List<SparqlJs.Update> {\n  let queries = Immutable.List<SparqlJs.Update>();\n\n  if (deleted.length === 0 && inserted.length === 0) {\n    return queries;\n  }\n\n  const paramterize = (query: SparqlJs.Update, value: Rdf.Node) =>\n    SparqlClient.setBindings(query, {\n      subject: subject,\n      value: value,\n    });\n\n  if (deleteQuery) {\n    queries = queries.concat(deleted.map((value) => paramterize(deleteQuery, value)));\n  }\n  if (insertQuery) {\n    queries = queries.concat(inserted.map((value) => paramterize(insertQuery, value)));\n  }\n  return queries;\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { createElement, ReactNode, Component, createFactory } from 'react';\nimport * as D from 'react-dom-factories';\nimport * as Immutable from 'immutable';\nimport * as Kefir from 'kefir';\n\nimport { Cancellation } from 'platform/api/async';\n\nimport { ErrorNotification } from 'platform/components/ui/notification';\nimport { Spinner } from 'platform/components/ui/spinner';\n\nimport { FieldDefinitionProp } from './FieldDefinition';\nimport { FieldValue, EmptyValue, AtomicValue, CompositeValue, ErrorKind, DataState } from './FieldValues';\n\nimport { CompositeInput, CompositeInputProps, SingleValueHandler } from './inputs';\nimport { FormErrors } from './static/FormErrors';\n\nimport './forms.scss';\n\nexport interface SemanticFormProps {\n  fields?: ReadonlyArray<FieldDefinitionProp>;\n  model: EmptyValue | AtomicValue | CompositeValue;\n  onChanged: (model: CompositeValue) => void;\n  onLoaded: (model: CompositeValue) => void;\n  onUpdated?: (dataState: DataState) => void;\n  newSubjectTemplate?: string;\n  children?: ReactNode;\n  debug?: boolean;\n}\n\nenum LoadingState {\n  None,\n  Loading,\n  Completed,\n}\n\n/**\n * Component to view and edit semantic data represented by a collection of fields.\n * This component is an equivalent of HTML <form> element for display and modification\n * of data represented by {@link Rdf.Node}s.\n *\n * Usage and lifecycle:\n *\n *   1. Render form with inputs as children (either {@link SingleValueInput} or\n *      {@link MultipleValuesInput}, former automatically wrapped by {@link CardinalitySupport}).\n *\n *      Child inputs provided with field definition and current field state from model\n *      based on 'for' property of input component.\n *\n *   2. Props.onLoaded is called on mount with intialized model derived from\n *      intially provided model by filtering unused field definitions and adding information\n *      about configuration errors (e.g. missing field defintion for input).\n *\n *   3. Props.onChanged is called on model change:\n *      a. when intial value and value set of field is loaded\n *      b. when user changed field value using form's input\n *      c. when new value of edited field finished validation by Sparql query\n */\nexport class SemanticForm extends Component<SemanticFormProps, {}> {\n  private readonly cancellation = new Cancellation();\n\n  private handler: SingleValueHandler;\n\n  private input: CompositeInput;\n  private lastDataState: DataState | undefined;\n  private loadingState = LoadingState.None;\n  private pendingModel: FieldValue;\n\n  constructor(props: SemanticFormProps, context: any) {\n    super(props, context);\n    this.handler = CompositeInput.makeHandler({\n      definition: undefined,\n      baseInputProps: {\n        fields: this.props.fields || [],\n        newSubjectTemplate: this.props.newSubjectTemplate,\n        children: this.props.children,\n      },\n    });\n  }\n\n  componentDidMount() {\n    this.pendingModel = this.props.model;\n  }\n\n  componentWillReceiveProps(nextProps: SemanticFormProps) {\n    if (nextProps.model !== this.props.model) {\n      this.pendingModel = nextProps.model;\n    }\n  }\n\n  componentWillUnmount() {\n    this.cancellation.cancelAll();\n  }\n\n  private updateModel = (reducer: (previous: FieldValue) => FieldValue) => {\n    this.pendingModel = reducer(this.pendingModel);\n    if (!FieldValue.isComposite(this.pendingModel)) {\n      throw new Error('CompositeValue.updateValue returned non-composite');\n    }\n    this.props.onChanged(this.pendingModel);\n  };\n\n  componentDidUpdate(prevProps: SemanticFormProps) {\n    const dataState = this.input ? this.input.dataState() : DataState.Loading;\n    const modelOrDataStateChanged = !(this.props.model === prevProps.model && this.lastDataState === dataState);\n    this.lastDataState = dataState;\n\n    if (modelOrDataStateChanged) {\n      if (this.props.onUpdated) {\n        this.props.onUpdated(dataState);\n      }\n\n      if (this.props.debug) {\n        console.log(`[${LoadingState[this.loadingState]}] ${DataState[dataState]}`, asDebugJSObject(this.props.model));\n      }\n\n      // transition from None to Loading\n      if (this.loadingState === LoadingState.None && dataState === DataState.Loading) {\n        this.loadingState = LoadingState.Loading;\n        if (this.props.debug) {\n          console.log(`[-> ${LoadingState[this.loadingState]}]`);\n        }\n      } else if (\n        // transition from Loading to Ready\n        this.loadingState === LoadingState.Loading &&\n        dataState === DataState.Ready &&\n        FieldValue.isComposite(this.props.model)\n      ) {\n        this.loadingState = LoadingState.Completed;\n        if (this.props.debug) {\n          console.log(`[-> ${LoadingState[this.loadingState]}]`);\n        }\n        this.props.onLoaded(this.props.model);\n      }\n    }\n  }\n\n  private onCompositeMounted = (input: CompositeInput) => {\n    this.input = input;\n  };\n\n  /**\n   * Performs validation of model with form inputs.\n   * This is useful when model is only partially validated or not validated at all,\n   * e.g. loaded as initial state, restored from previous session, etc.\n   */\n  validate(model: CompositeValue): CompositeValue {\n    const validated = this.handler.validate(model);\n    if (!FieldValue.isComposite(validated)) {\n      throw new Error('Expected to return either composite or empty value from CompositeInput.validate');\n    }\n    return validated;\n  }\n\n  finalize(model: CompositeValue): Kefir.Property<CompositeValue> {\n    return this.handler\n      .finalize(model, FieldValue.empty)\n      .flatMap((finalized) =>\n        FieldValue.isComposite(finalized)\n          ? Kefir.constant(finalized)\n          : Kefir.constantError<any>(new Error('Expected CompositeValue as finalize result'))\n      )\n      .toProperty();\n  }\n\n  render() {\n    if (FieldValue.isEmpty(this.props.model)) {\n      return createElement(Spinner);\n    }\n\n    const hasConfigurationErrors = this.props.model.errors.some((e) => e.kind === ErrorKind.Configuration);\n\n    return D.div(\n      { className: 'semantic-form' },\n      createElement(CompositeInput, {\n        ref: this.onCompositeMounted,\n        handler: this.handler,\n        fields: this.props.fields || [],\n        newSubjectTemplate: this.props.newSubjectTemplate,\n        dataState: DataState.Ready,\n        updateValue: this.updateModel,\n        value: this.props.model,\n        // in case of configuration errors show FormErrors component instead of form content\n        children: hasConfigurationErrors\n          ? createElement(\n              ErrorNotification,\n              { title: 'Errors in form configuration' },\n              createElement(FormErrors, { model: this.props.model })\n            )\n          : this.props.children,\n      }),\n      this.props.debug ? D.pre({}, JSON.stringify(asDebugJSObject(this.props.model), null, 2)) : null\n    );\n  }\n}\n\nfunction asDebugJSObject(value: FieldValue): object {\n  switch (value.type) {\n    case EmptyValue.type:\n      return { type: EmptyValue.type };\n    case AtomicValue.type:\n      return {\n        type: AtomicValue.type,\n        value: value.value.toString(),\n        label: value.label,\n        errors: value.errors.toArray(),\n      };\n    case CompositeValue.type:\n      return {\n        type: CompositeValue.type,\n        subject: value.subject.toString(),\n        fields: value.fields\n          .map((state) => ({\n            values: state.values.map(asDebugJSObject).toArray(),\n            errors: state.errors.toArray(),\n          }))\n          .toObject(),\n      };\n  }\n}\n\nexport default createFactory(SemanticForm);\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nexport * from './SingleValueInput';\nexport * from './MultipleValuesInput';\nexport * from './CardinalitySupport';\nexport * from './CompositeInput';\n\nexport { AutocompleteInput, AutocompleteInputProps } from './AutocompleteInput';\nexport { CheckboxInput, CheckboxInputProps } from './CheckboxInput';\nexport { ChecklistInput, ChecklistInputProps, ChecklistType } from './ChecklistInput';\nexport { DatePickerInput, DatePickerInputProps, DatePickerMode } from './DatePickerInput';\nexport { FormSwitch, FormSwitchProps } from './FormSwitch';\nexport { FormSwitchCase, FormSwitchCaseProps } from './FormSwitchCase';\nexport { HiddenInput, HiddenInputProps } from './HiddenInput';\nexport { PlainTextInput, PlainTextInputProps } from './PlainTextInput';\nexport { SelectInput, SelectInputProps } from './SelectInput';\nexport { TreePickerInput, TreePickerInputProps } from './TreePickerInput';\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Immutable from 'immutable';\n\nimport { Rdf, turtle } from 'platform/api/rdf';\n\nimport { FieldDefinition } from './FieldDefinition';\nimport { FieldValue, CompositeValue, AtomicValue, EmptyValue, FieldState, FieldError } from './FieldValues';\n\nexport type ValuePatch = CompositePatch | AtomicPatch | null;\n\ninterface CompositePatch {\n  readonly type: typeof CompositeValue.type;\n  /** RDF IRI represented in the N3 format */\n  readonly subject: string;\n  /** RDF node represented in the N3 format */\n  readonly discriminator?: string;\n  readonly fields: { readonly [fieldId: string]: FieldPatch };\n}\n\ninterface FieldPatch {\n  readonly baseLength: number;\n  readonly values: ReadonlyArray<ValuePatch>;\n}\n\ninterface AtomicPatch {\n  readonly type: typeof AtomicValue.type;\n  /** RDF node represented in the N3 format */\n  readonly value: string;\n  readonly label: string | undefined;\n}\n\nexport function computeValuePatch(base: FieldValue, changed: FieldValue): ValuePatch {\n  if (FieldValue.isEmpty(changed)) {\n    return null;\n  }\n  if (base.type !== changed.type) {\n    return asPatch(changed);\n  }\n  switch (base.type) {\n    case AtomicValue.type:\n      const changedAtomic = changed as AtomicValue;\n      const isEqual = base.value.equals(changedAtomic.value) && base.label === changedAtomic.label;\n      return isEqual ? null : asPatch(changedAtomic);\n    case CompositeValue.type:\n      return computeCompositePatch(base, changed as CompositeValue);\n  }\n  FieldValue.unknownFieldType(base);\n}\n\nfunction computeCompositePatch(base: CompositeValue, changed: CompositeValue): ValuePatch {\n  if (!equalRdfTerms(base.discriminator, changed.discriminator)) {\n    return asPatch(changed);\n  }\n\n  const visited: { [fieldId: string]: true } = {};\n  const patchFields: { [fieldId: string]: FieldPatch } = {};\n  let hasAtLeastOnePatch = false;\n\n  const visit = (fieldId: string, baseState: FieldState | undefined, changedState: FieldState | undefined) => {\n    if (visited[fieldId]) {\n      return;\n    }\n    visited[fieldId] = true;\n\n    if (!baseState && changedState) {\n      const values = changedState.values.map(asPatch).toArray();\n      patchFields[fieldId] = { baseLength: values.length, values };\n      hasAtLeastOnePatch = true;\n    } else if (baseState && changedState) {\n      const statePatch = computeFieldPatch(baseState, changedState);\n      if (statePatch.values.some((p) => p !== null)) {\n        patchFields[fieldId] = statePatch;\n        hasAtLeastOnePatch = true;\n      }\n    }\n  };\n\n  base.fields.forEach((baseState, fieldId) => visit(fieldId, baseState, changed.fields.get(fieldId)));\n  changed.fields.forEach((changedState, fieldId) => visit(fieldId, base.fields.get(fieldId), changedState));\n\n  return hasAtLeastOnePatch\n    ? {\n        type: CompositeValue.type,\n        subject: turtle.serialize.nodeToN3(changed.subject),\n        fields: patchFields,\n      }\n    : null;\n}\n\nfunction equalRdfTerms(a: Rdf.Node | null | undefined, b: Rdf.Node | null | undefined): boolean {\n  return !a ? !b : !b ? !a : a.equals(b);\n}\n\nfunction computeFieldPatch(base: FieldState, changed: FieldState): FieldPatch {\n  const values = changed.values\n    .map((changedValue, index) => {\n      const baseValue = base.values.get(index, FieldValue.empty);\n      return computeValuePatch(baseValue, changedValue);\n    })\n    .toArray();\n  return { baseLength: base.values.size, values };\n}\n\nfunction asPatch(value: FieldValue): ValuePatch {\n  switch (value.type) {\n    case EmptyValue.type:\n      return null;\n    case AtomicValue.type:\n      return {\n        type: AtomicValue.type,\n        value: turtle.serialize.nodeToN3(value.value),\n        label: value.label,\n      };\n    case CompositeValue.type:\n      return {\n        type: CompositeValue.type,\n        subject: turtle.serialize.nodeToN3(value.subject),\n        discriminator: value.discriminator ? turtle.serialize.nodeToN3(value.discriminator) : undefined,\n        fields: value.fields\n          .map(\n            (state): FieldPatch => {\n              const values = state.values.map(asPatch).toArray();\n              return { baseLength: values.length, values };\n            }\n          )\n          .toObject(),\n      };\n  }\n  FieldValue.unknownFieldType(value);\n}\n\nexport function applyValuePatch(base: FieldValue, patch: ValuePatch): FieldValue {\n  if (!patch) {\n    return base;\n  }\n  switch (base.type) {\n    case EmptyValue.type:\n      const value = asValue(patch);\n      // prevent reusing exising entity from patch by clearing the subject\n      return FieldValue.isComposite(value) ? CompositeValue.set(value, { subject: Rdf.iri('') }) : value;\n    case AtomicValue.type:\n      if (patch.type === AtomicValue.type) {\n        return asValue(patch);\n      }\n      break;\n    case CompositeValue.type:\n      if (patch.type === CompositeValue.type) {\n        return applyCompositePatch(base, patch);\n      }\n  }\n  return base;\n}\n\nfunction applyCompositePatch(base: CompositeValue, patch: CompositePatch): FieldValue {\n  const patchDiscriminator = patch.discriminator ? tryDeserializeN3(patch.discriminator) : undefined;\n  if (!equalRdfTerms(base.discriminator, patchDiscriminator)) {\n    return asValue(patch);\n  }\n\n  if (!patch.fields) {\n    return base;\n  }\n\n  const fields = base.fields\n    .map((baseState, fieldId) => {\n      const statePatch = patch.fields[fieldId];\n      return statePatch ? applyFieldPatch(baseState, statePatch) : baseState;\n    })\n    .toMap();\n\n  return CompositeValue.set(base, { fields });\n}\n\nfunction applyFieldPatch(base: FieldState, patch: FieldPatch): FieldState {\n  const isValidValues = Array.isArray(patch.values);\n  if (!isValidValues) {\n    return base;\n  }\n\n  const values = patch.values.map((valuePatch, index) => {\n    const baseValue = base.values.get(index, FieldValue.empty);\n    return valuePatch ? applyValuePatch(baseValue, valuePatch) : baseValue;\n  });\n\n  return FieldState.set(base, { values: Immutable.List(values) });\n}\n\nfunction asValue(patch: ValuePatch): FieldValue {\n  let isValid: boolean;\n  switch (patch.type) {\n    case AtomicValue.type:\n      const nodeValue = tryDeserializeN3(patch.value);\n      isValid =\n        nodeValue &&\n        (nodeValue.isLiteral() || nodeValue.isIri()) &&\n        (typeof patch.label === 'undefined' || typeof patch.label === 'string');\n      if (isValid) {\n        return {\n          type: AtomicValue.type,\n          value: nodeValue,\n          label: patch.label,\n          errors: FieldError.noErrors,\n        };\n      }\n      break;\n    case CompositeValue.type:\n      const subjectIri = tryDeserializeN3(patch.subject);\n      if (subjectIri && subjectIri instanceof Rdf.Iri) {\n        const states = Object.keys(patch.fields).map((fieldId): [string, FieldState] => {\n          const statePatch = patch.fields[fieldId];\n          const values =\n            statePatch && Array.isArray(statePatch.values)\n              ? statePatch.values.map((v) => (v ? asValue(v) : FieldValue.empty))\n              : [];\n          return [\n            fieldId,\n            {\n              values: Immutable.List(values),\n              errors: FieldError.noErrors,\n            },\n          ];\n        });\n        const discriminator = patch.discriminator ? tryDeserializeN3(patch.discriminator) : undefined;\n        return {\n          type: CompositeValue.type,\n          definitions: Immutable.Map<string, FieldDefinition>(),\n          subject: subjectIri,\n          discriminator,\n          fields: Immutable.Map<string, FieldState>(states),\n          errors: FieldError.noErrors,\n        };\n      }\n  }\n  return FieldValue.empty;\n}\n\nfunction tryDeserializeN3(n3value: string): Rdf.Node | undefined {\n  try {\n    return turtle.deserialize.n3ValueToRdf(n3value);\n  } catch (e) {\n    console.warn('Encountered invalid N3 value while applying form patch', n3value);\n    return undefined;\n  }\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Immutable from 'immutable';\nimport * as Kefir from 'kefir';\nimport { cloneDeep } from 'lodash';\nimport * as SparqlJs from 'sparqljs';\n\nimport { requestAsProperty } from 'platform/api/async';\nimport * as request from 'platform/api/http';\nimport { Rdf } from 'platform/api/rdf';\nimport { SparqlClient, SparqlUtil } from 'platform/api/sparql';\nimport { LdpService } from 'platform/api/services/ldp';\nimport { VocabPlatform } from 'platform/api/rdf/vocabularies';\n\nimport { FieldValue, CompositeValue, EmptyValue } from '../FieldValues';\nimport { parseQueryStringAsUpdateOperation } from './PersistenceUtils';\nimport { TriplestorePersistence, ModelDiffEntry, computeModelDiff } from './TriplestorePersistence';\n\nexport interface LdpPersistenceConfig {\n  type?: 'ldp';\n  repository?: string;\n  containerIri?: string;\n}\n\nexport class LdpPersistence implements TriplestorePersistence {\n  constructor(private config: LdpPersistenceConfig = {}) {}\n\n  persist(initialModel: CompositeValue | EmptyValue, currentModel: CompositeValue | EmptyValue): Kefir.Property<void> {\n    if (FieldValue.isEmpty(currentModel)) {\n      if (FieldValue.isEmpty(initialModel) || CompositeValue.isPlaceholder(initialModel.subject)) {\n        // nothing has changed\n        return Kefir.constant<void>(undefined);\n      } else {\n        // subject has been deleted\n        return this.deleteSubjectContainer(initialModel.subject);\n      }\n    } else {\n      // subject has changed\n      const updates = computeModelDiff(FieldValue.empty, currentModel);\n      return this.persistModelUpdates(currentModel.subject, updates);\n    }\n  }\n\n  remove(model: CompositeValue): Kefir.Property<void> {\n    const ldp = new LdpService(VocabPlatform.FormContainer.value, this.config);\n    return ldp.deleteResource(model.subject) as Kefir.Property<void>;\n  }\n\n  persistModelUpdates(subject: Rdf.Iri, updates: ModelDiffEntry[]) {\n    const listOfConstructs = this.createFormConstructQueries(updates);\n    return this.sendConstructsToBackend(subject, listOfConstructs.toArray());\n  }\n\n  private createFormConstructQueries(entries: ModelDiffEntry[]): Immutable.List<SparqlJs.ConstructQuery> {\n    return Immutable.List(\n      entries\n        .filter((entry) => entry.definition.insertPattern)\n        .map((entry) => {\n          const insertQuery = parseQueryStringAsUpdateOperation(entry.definition.insertPattern);\n          return this.createFieldConstructQueries(insertQuery, entry.inserted, entry.subject);\n        })\n    )\n      .filter((updates) => updates.size > 0)\n      .flatten()\n      .toList();\n  }\n\n  /**\n   * Takes an SPARQL insert query and turns it into an construct query.\n   * The query will be parameterize as many times as number of newValues (will parameterize $value),\n   * producing a list of SPARQL construct queries. All queries will be\n   * additionally parameterized by the supplied $subject value.\n   */\n  createFieldConstructQueries(\n    insertQuery: SparqlJs.Update | undefined,\n    newValues: ReadonlyArray<Rdf.Node>,\n    subject: Rdf.Iri\n  ): Immutable.List<SparqlJs.ConstructQuery> {\n    let constructQueries = Immutable.List<SparqlJs.ConstructQuery>();\n    if (!insertQuery) {\n      return constructQueries;\n    }\n\n    const constructQuery: SparqlJs.ConstructQuery = {\n      type: 'query',\n      prefixes: {},\n      queryType: 'CONSTRUCT',\n    };\n\n    const insertDeleteOperations = <SparqlJs.InsertDeleteOperation[]>insertQuery.updates;\n\n    // According to the SPARQL standard there can be several update operations\n    // separated by ; i.e. INSERT {} WHERER{}; INSERT {} WHERER{}\n    // However, in forms we always expect a single operation i.e. INSERT clause\n    if (insertDeleteOperations.length !== 1) {\n      // TODO error handling here ?\n      return constructQueries;\n    }\n\n    const updateOperation = insertDeleteOperations.pop();\n\n    // TODO silently filtering, logging, error ?\n    constructQuery.template = updateOperation.insert\n      .filter(\n        // first filter all bgp patters i.e. insert may also be SparqlJs.GraphPattern\n        // which is not supported in template of SparqlJs.ConstructQuery\n        (p) => p.type === 'bgp'\n      )\n      .reduce(\n        (ar: SparqlJs.Triple[], p) => ar.concat(cloneDeep(<SparqlJs.BgpPattern>p).triples),\n        new Array<SparqlJs.Triple>()\n      );\n\n    // clone the where part from the insert query to the construct query\n    constructQuery.where = cloneDeep(updateOperation.where);\n\n    // parameterization of $subject and $value\n    const paramterize = (query: SparqlJs.ConstructQuery, value: Rdf.Node) =>\n      SparqlClient.setBindings(query, {\n        subject: subject,\n        value: value,\n      });\n\n    if (constructQuery) {\n      constructQueries = constructQueries.concat(newValues.map((value) => paramterize(constructQuery, value)));\n    }\n    return constructQueries;\n  }\n\n  sendConstructsToBackend(subject: Rdf.Iri, queries: SparqlJs.ConstructQuery[]): Kefir.Property<void> {\n    // convert the array of SparqlJs.Update objects to plain strings\n    const stringQueries: string[] = queries.map(SparqlUtil.serializeQuery);\n\n    const req = request\n      .post('/form-persistence/ldp')\n      .type('application/json')\n      .query({\n        iri: this.getTargetLdpResource(subject),\n        repository: this.getTargetRepository(),\n      })\n      .send(stringQueries);\n\n    return requestAsProperty(req).map(() => {});\n  }\n\n  private deleteSubjectContainer(subject: Rdf.Iri) {\n    const req = request\n      .delete('/form-persistence/ldp')\n      .type('application/json')\n      .query({\n        iri: this.getTargetLdpResource(subject),\n        repository: this.getTargetRepository(),\n      })\n      .send();\n\n    return requestAsProperty(req).map(() => {});\n  }\n\n  private getTargetLdpResource(subject: Rdf.Iri) {\n    const { containerIri } = this.config;\n    return containerIri ? containerIri : `${subject.value}/container`;\n  }\n\n  private getTargetRepository() {\n    const { repository = 'default' } = this.config;\n    return repository;\n  }\n}\n"],"sourceRoot":""}