{"version":3,"sources":["webpack:///./src/main/web/components/forms/inputs/FormSwitch.tsx"],"names":["props","context","cancellation","Cancellation","switchOperations","derive","fieldValuesMap","Map","shouldReload","onChangeCaseType","event","value","handler","getHandler","previousType","selectCaseForValue","chosenType","nextType","cases","get","target","set","type","updateValue","FieldValue","empty","onCaseInputMount","input","refToInput","first","isLoading","isAtomic","this","FormSwitchHandler","Error","dataState","DataState","Loading","Ready","componentDidMount","tryLoadSwitch","componentWillReceiveProps","nextProps","componentWillUnmount","cancelAll","loadSwitch","deriveAndCancel","asRdfNode","isIri","typeDefinition","map","queryValues","selectPattern","observe","types","typeSet","Immutable","Set","foundType","find","caseType","has","v","replaceError","kind","ErrorKind","message","t","toString","join","Configuration","switchOnField","render","Spinner","selectedCase","className","renderSwitch","renderCase","currentType","size","CLASS_NAME","onChange","toArray","key","label","baseUpdateValue","discriminator","definition","transferredProps","reducer","previous","updated","isComposite","CompositeValue","ref","React","cloneElement","composite","makeHandler","inputKind","InputKind","FormSwitch","SingleValueInput","baseInputProps","computeCases","OrderedMap","withMutations","Children","forEach","children","child","componentHasType","childType","undefined","caseInput","assertCaseCompositeInput","targetFieldName","count","caseChild","only","CompositeInput","for","id","caseKey","findSwitchedOnHiddenInput","switchedOnFieldName","compositeChildren","hiddenInput","foundMultiple","defaultValue","Rdf","iri","getHandlerOrDefault","getTypeDefinition","fields","field","normalizeFieldDefinition","defaultCase","console","warn","validate","defaultHandler","finalize","owner","assertStatic"],"mappings":"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","file":"semantic-form-switch-f0561efedbb483a63f99.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport * as React from 'react';\nimport * as Immutable from 'immutable';\nimport { Cancellation } from 'platform/api/async';\nimport { FieldDefinition, normalizeFieldDefinition } from '../FieldDefinition';\n\nimport {\n  SingleValueInput,\n  SingleValueInputProps,\n  SingleValueHandler,\n  SingleValueHandlerProps,\n} from '../inputs/SingleValueInput';\nimport { CompositeInput, CompositeInputProps } from '../inputs/CompositeInput';\n\nimport { componentHasType } from 'platform/components/utils';\nimport FormSwitchCase, { FormSwitchCaseProps } from './FormSwitchCase';\nimport { FieldValue, DataState, CompositeValue, EmptyValue, ErrorKind } from '../FieldValues';\nimport HiddenInput, { HiddenInputProps } from '../inputs/HiddenInput';\nimport { queryValues } from '../QueryValues';\nimport { Rdf } from 'platform/api/rdf';\nimport { Spinner } from 'platform/components/ui/spinner';\nimport { InputKind } from './InputCommpons';\n\nexport interface FormSwitchProps extends SingleValueInputProps {\n  switchOnField: string;\n  children: React.ReactElement<FormSwitchCaseProps>;\n}\n\nconst CLASS_NAME = 'form-switch';\n\n/**\n * The component FormSwitch allows the end users to select different forms depending\n * on the one type of an object, but with different realizes. For example: There is\n * an object which has a type \"event\". Events for an artefact: repatriation, sale,\n * excavation, theft, ect. Every event has an own realise.\n *\n * \"general-switch-type\" - the field which define a general type of switch i.e.\n * define a type of each composite-input.\n *\n * \"switch-on-field=switch-case-type\" - the field which define types\n * of switch cases. This is a service field. It works only with\n * \"default-value=iri:special-type\" of hidden-input.\n *\n * \"label\" - label for a list of types.\n *\n * @example\n * <semantic-form-switch for='{general-switch-type}'\n *  switch-on-field='switch-case-type'>\n *    <semantic-form-switch-case label='case label 1'>\n *      <semantic-form-composite-input\n *        for='{general-switch-type}'\n *        new-subject-template='template'\n *        fields='[{fieldDefinitions}]'>\n *        <semantic-form-hidden-input for='{switch-case-type}'\n *          default-value='http://www.example.com/spec-type-1'>\n *        </semantic-form-hidden-input>\n *        ... child inputs ...\n *      </semantic-form-composite-input>\n *    </semantic-form-switch-case>\n *    <semantic-form-switch-case label='case label 2'>\n *      <semantic-form-composite-input\n *        for='{general-switch-type}'\n *        new-subject-template='template'\n *        fields='[{fieldDefinitions}]'>\n *        <semantic-form-hidden-input for='{switch-case-type}'\n *          default-value='http://www.example.com/spec-type-2'>\n *        </semantic-form-hidden-input>\n *          ... another child inputs ...\n *        </semantic-form-composite-input>\n *      </semantic-form-switch-case>\n *  </semantic-form-switch>\n */\nexport class FormSwitch extends SingleValueInput<FormSwitchProps, {}> {\n  public static readonly inputKind = InputKind.FormSwitch;\n\n  private readonly cancellation = new Cancellation();\n\n  private switchOperations = this.cancellation.derive();\n  private fieldValuesMap = new Map<string, FieldValue>();\n  private refToInput: CompositeInput | null;\n  private chosenType: SwitchCaseType;\n  private isLoading: boolean;\n  private shouldReload = false;\n\n  constructor(props: FormSwitchProps, context: any) {\n    super(props, context);\n    this.chosenType = this.getHandler().cases.first();\n    this.isLoading = FieldValue.isAtomic(props.value);\n  }\n\n  private getHandler(): FormSwitchHandler {\n    if (!(this.props.handler instanceof FormSwitchHandler)) {\n      throw new Error('Invalid value handler for FormSwitch');\n    }\n    return this.props.handler;\n  }\n\n  dataState(): DataState {\n    if (this.isLoading) {\n      return DataState.Loading;\n    }\n    if (this.refToInput) {\n      return this.refToInput.dataState();\n    }\n    return DataState.Ready;\n  }\n\n  componentDidMount() {\n    if (FieldValue.isAtomic(this.props.value)) {\n      this.shouldReload = true;\n    }\n    this.tryLoadSwitch(this.props);\n  }\n\n  componentWillReceiveProps(nextProps: FormSwitchProps) {\n    if (this.props.value !== nextProps.value) {\n      this.shouldReload = true;\n    }\n    this.tryLoadSwitch(nextProps);\n  }\n\n  componentWillUnmount() {\n    this.cancellation.cancelAll();\n  }\n\n  private tryLoadSwitch(props: FormSwitchProps) {\n    if (props.dataState !== DataState.Ready) {\n      return;\n    }\n    if (this.shouldReload) {\n      this.shouldReload = false;\n      this.loadSwitch(props);\n    }\n  }\n\n  private loadSwitch(props: FormSwitchProps) {\n    this.switchOperations = this.cancellation.deriveAndCancel(this.switchOperations);\n    if (FieldValue.isAtomic(props.value)) {\n      const node = FieldValue.asRdfNode(props.value);\n      const handler = this.getHandler();\n      if (!node.isIri()) {\n        this.props.updateValue((v) =>\n          FieldValue.replaceError(v, {\n            kind: ErrorKind.Loading,\n            message: `Cannot choose a switch case for non-IRI value ${node}`,\n          })\n        );\n      } else if (!handler.typeDefinition) {\n        this.props.updateValue((v) =>\n          FieldValue.replaceError(v, {\n            kind: ErrorKind.Configuration,\n            message: `Failed find a definition for switch-on-field \"${this.props.switchOnField}\"`,\n          })\n        );\n      } else {\n        this.isLoading = true;\n        this.switchOperations.map(queryValues(handler.typeDefinition.selectPattern, node)).observe({\n          value: (types) => {\n            const typeSet = Immutable.Set(types.map((type) => type.value));\n            const foundType = handler.cases.find((caseType) => typeSet.has(caseType.type));\n            if (foundType) {\n              this.isLoading = false;\n              this.chosenType = foundType;\n            }\n            this.props.updateValue((v) => {\n              return foundType\n                ? v\n                : FieldValue.replaceError(v, {\n                    kind: ErrorKind.Loading,\n                    message:\n                      `Cannot choose an switch case for set of types ` +\n                      types.map((t) => t.value.toString()).join(', '),\n                  });\n            });\n          },\n        });\n      }\n    } else if (this.isLoading) {\n      this.isLoading = false;\n      this.props.updateValue((v) => v);\n    }\n  }\n\n  render() {\n    if (this.isLoading) {\n      return <Spinner />;\n    }\n    const { value } = this.props;\n    const handler = this.getHandler();\n    const selectedCase = handler.selectCaseForValue(value, this.chosenType);\n    return (\n      <div className={CLASS_NAME}>\n        {this.renderSwitch(selectedCase)}\n        {this.renderCase(selectedCase)}\n      </div>\n    );\n  }\n\n  private renderSwitch(currentType: SwitchCaseType) {\n    const handler = this.getHandler();\n    if (handler.cases.size === 0) {\n      return;\n    }\n    return (\n      <div className={`${CLASS_NAME}__content`}>\n        <select className={`${CLASS_NAME}__select`} onChange={this.onChangeCaseType} value={currentType.type.value}>\n          {handler.cases.toArray().map((caseType) => (\n            <option key={caseType.type.value} value={caseType.type.value}>\n              {caseType.label}\n            </option>\n          ))}\n        </select>\n      </div>\n    );\n  }\n\n  private onChangeCaseType = (event: React.ChangeEvent<HTMLSelectElement>) => {\n    const { value } = this.props;\n    const handler = this.getHandler();\n    const previousType = handler.selectCaseForValue(value, this.chosenType);\n    const nextType = handler.cases.get(event.target.value);\n    this.chosenType = nextType;\n    this.fieldValuesMap.set(previousType.type.value, this.props.value);\n    this.props.updateValue(() => {\n      return this.fieldValuesMap.get(nextType.type.value) || FieldValue.empty;\n    });\n  };\n\n  private renderCase(caseType: SwitchCaseType): JSX.Element {\n    const handler = this.getHandler();\n    if (handler.cases.size === 0) {\n      return;\n    }\n    const { dataState, definition, updateValue, value } = this.props;\n    const transferredProps: Partial<CompositeInputProps> & React.Props<CompositeInput> = {\n      value: value,\n      handler: caseType.handler,\n      dataState: dataState,\n      definition: definition,\n      updateValue: makeAttachingDiscriminatorUpdater(updateValue, caseType.type),\n      key: caseType.type.value,\n      ref: this.onCaseInputMount,\n    };\n    return React.cloneElement(caseType.composite, transferredProps);\n  }\n\n  private onCaseInputMount = (input: CompositeInput | null) => {\n    this.refToInput = input;\n  };\n\n  static makeHandler(props: SingleValueHandlerProps<FormSwitchProps>): SingleValueHandler {\n    return new FormSwitchHandler(props);\n  }\n}\n\n/**\n * Creates a field updater function which ensures that field value always has discriminator.\n */\nfunction makeAttachingDiscriminatorUpdater(\n  baseUpdateValue: SingleValueInputProps['updateValue'],\n  discriminator: Rdf.Node\n): SingleValueInputProps['updateValue'] {\n  return (reducer) => {\n    baseUpdateValue((previous) => {\n      const updated = reducer(previous);\n      return FieldValue.isComposite(updated) ? CompositeValue.set(updated, { discriminator }) : updated;\n    });\n  };\n}\n\nclass FormSwitchHandler implements SingleValueHandler {\n  readonly switchOnField: string;\n  readonly typeDefinition: FieldDefinition | undefined;\n  readonly cases: Immutable.OrderedMap<string, SwitchCaseType>;\n\n  constructor(props: SingleValueHandlerProps<FormSwitchProps>) {\n    this.switchOnField = props.baseInputProps.switchOnField;\n    this.cases = computeCases(props);\n    this.typeDefinition = this.getTypeDefinition();\n  }\n\n  private getTypeDefinition() {\n    for (const field of this.cases.first().composite.props.fields) {\n      if (field.id === this.switchOnField) {\n        return normalizeFieldDefinition(field);\n      }\n    }\n    return undefined;\n  }\n\n  selectCaseForValue(value: FieldValue, defaultCase: SwitchCaseType) {\n    if (this.cases.size === 0 || !FieldValue.isComposite(value) || !value.discriminator) {\n      return defaultCase;\n    }\n    const foundType = this.cases.get(value.discriminator.value);\n    if (!foundType) {\n      console.warn('Trying to render form switch value with unknown discriminator: ' + value.discriminator);\n    }\n    return foundType || defaultCase;\n  }\n\n  validate(value: FieldValue): FieldValue {\n    if (!FieldValue.isComposite(value)) {\n      return SingleValueInput.defaultHandler.validate(value);\n    }\n    const caseType = this.selectCaseForValue(value, this.cases.first());\n    return caseType.handler.validate(value);\n  }\n\n  finalize(value: FieldValue, owner: EmptyValue | CompositeValue) {\n    if (!FieldValue.isComposite(value)) {\n      return SingleValueInput.defaultHandler.finalize(value, owner);\n    }\n    const caseType = this.selectCaseForValue(value, this.cases.first());\n    return caseType.handler.finalize(value, owner);\n  }\n}\n\ninterface SwitchCaseType {\n  readonly type: Rdf.Iri;\n  readonly label: string;\n  readonly handler: SingleValueHandler;\n  readonly composite: React.ReactElement<CompositeInputProps>;\n}\n\nfunction computeCases({\n  definition,\n  baseInputProps,\n}: SingleValueHandlerProps<FormSwitchProps>): Immutable.OrderedMap<string, SwitchCaseType> {\n  return Immutable.OrderedMap<string, SwitchCaseType>().withMutations((cases) => {\n    React.Children.forEach(baseInputProps.children, (child) => {\n      if (!componentHasType(child, FormSwitchCase)) {\n        const childType = typeof child === 'object' ? (child as React.ReactElement<unknown>).type : undefined;\n        throw new Error(`Invalid type of component: ${childType || typeof child}`);\n      }\n      const caseInput = assertCaseCompositeInput(definition.id, child);\n      const switchedOnInput = findSwitchedOnHiddenInput(baseInputProps.switchOnField, caseInput.props.children);\n      const caseKey = switchedOnInput.props.defaultValue;\n      cases.set(caseKey, {\n        type: Rdf.iri(caseKey),\n        label: child.props.label,\n        handler: SingleValueInput.getHandlerOrDefault(caseInput.type as any, {\n          definition,\n          baseInputProps: caseInput.props,\n        }),\n        composite: caseInput,\n      });\n    });\n  });\n}\n\nfunction assertCaseCompositeInput(\n  targetFieldName: string,\n  child: React.ReactElement<FormSwitchCaseProps>\n): React.ReactElement<CompositeInputProps> {\n  if (React.Children.count(child.props.children) !== 1) {\n    throw new Error(`Expected only a single child for <semantic-form-switch-case>`);\n  }\n  const caseChild = React.Children.only(child.props.children);\n  if (!componentHasType(caseChild, CompositeInput)) {\n    throw new Error(`Expected a single <semantic-form-composite-input> as a child`);\n  }\n  if (caseChild.props.for !== targetFieldName) {\n    throw new Error(`Expected child <semantic-form-composite-input> to have property ref='${targetFieldName}'`);\n  }\n  return caseChild;\n}\n\nfunction findSwitchedOnHiddenInput(\n  switchedOnFieldName: string,\n  compositeChildren: React.ReactNode\n): React.ReactElement<HiddenInputProps> {\n  let hiddenInput: React.ReactElement<HiddenInputProps> | undefined;\n  let foundMultiple = false;\n  React.Children.forEach(compositeChildren, (child) => {\n    if (componentHasType(child, HiddenInput)) {\n      if (child.props.for === switchedOnFieldName && child.props.defaultValue) {\n        foundMultiple = hiddenInput !== undefined;\n        hiddenInput = child;\n      }\n    }\n  });\n  if (!hiddenInput || foundMultiple) {\n    const errorMessage =\n      `Expected single input for ` +\n      `<semantic-form-hidden-input for='${switchedOnFieldName}' ` +\n      `default-value='special type'></semantic-form-hidden-input>`;\n    throw new Error(errorMessage);\n  }\n  return hiddenInput;\n}\n\nSingleValueInput.assertStatic(FormSwitch);\n\nexport default FormSwitch;\n"],"sourceRoot":""}