{"version":3,"sources":["webpack:///./node_modules/ol-ext/layer/AnimatedCluster.js"],"names":["ol_layer_AnimatedCluster","opt_options","options","call","this","oldcluster","clusters","animation","start","set","animationDuration","animationMethod","easeOut","getSource","on","saveCluster","animate","postanimate","inherits","prototype","clear","get","features","getFeatures","length","addFeatures","slice","sourceChanged","getClusterForFeature","f","cluster","j","f2","k","stopAnimation","cA","cB","e","duration","resolution","frameState","viewState","a","time","extent","buffer","getFeaturesInExtent","revers","c0","i","c","push","pt","getGeometry","getCoordinates","Date","getTime","vectorContext","d","style","getStyle","stylefn","context","save","globalAlpha","getOpacity","ratio","pixelRatio","dx","dy","s","st","geo","sc","imgs","getFeaturesAtPixel","getImage","getScale","setScale","setStyle","drawGeometry","drawFeature","setImageStyle","setTextStyle","getText","drawPointGeometry","restore","beginPath","rect","clip","clip_"],"mappings":"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","file":"npm.ol-ext-002f7e277b681882f574.js","sourcesContent":["/*\n\tCopyright (c) 2015 Jean-Marc VIGLINO, \n\treleased under the CeCILL-B license (http://www.cecill.info/).\n\t\n\tol_layer_AnimatedCluster is a vector layer that animate cluster \n\t\n*/\nimport ol from 'ol'\nimport ol_layer_Vector from 'ol/layer/vector'\nimport ol_source_Vector from 'ol/source/vector'\nimport ol_easing from 'ol/easing'\nimport ol_extent from 'ol/extent'\nimport ol_geom_Point from 'ol/geom/point'\nimport ol_Map from 'ol/map'\n\n/**\n *  A vector layer for animated cluster\n * @constructor \n * @extends {ol.layer.Vector}\n * @param {olx.layer.AnimatedClusterOptions=} options extend olx.layer.Options\n * \t@param {Number} options.animationDuration animation duration in ms, default is 700ms \n * \t@param {ol.easingFunction} animationMethod easing method to use, default ol.easing.easeOut\n */\nvar ol_layer_AnimatedCluster = function(opt_options)\n{\tvar options = opt_options || {};\n\n\tol_layer_Vector.call (this, options);\n\t\n\tthis.oldcluster = new ol_source_Vector();\n\tthis.clusters = [];\n\tthis.animation={start:false};\n\tthis.set('animationDuration', typeof(options.animationDuration)=='number' ? options.animationDuration : 700);\n\tthis.set('animationMethod', options.animationMethod || ol_easing.easeOut);\n\n\t// Save cluster before change\n\tthis.getSource().on('change', this.saveCluster, this);\n\t// Animate the cluster\n\tthis.on('precompose', this.animate, this);\n\tthis.on('postcompose', this.postanimate, this);\n};\nol.inherits (ol_layer_AnimatedCluster, ol_layer_Vector);\n\n/** save cluster features before change\n * @private\n */\nol_layer_AnimatedCluster.prototype.saveCluster = function()\n{\tthis.oldcluster.clear();\n\tif (!this.get('animationDuration')) return;\n\tvar features = this.getSource().getFeatures();\n\tif (features.length && features[0].get('features'))\n\t{\tthis.oldcluster.addFeatures (this.clusters);\n\t\tthis.clusters = features.slice(0);\n\t\tthis.sourceChanged = true;\n\t}\n};\n\n/** \n * Get the cluster that contains a feature\n * @private\n*/\nol_layer_AnimatedCluster.prototype.getClusterForFeature = function(f, cluster)\n{\tfor (var j=0, c; c=cluster[j]; j++)\n\t{\tvar features = cluster[j].get('features');\n\t\tif (features && features.length) \n\t\t{\tfor (var k=0, f2; f2=features[k]; k++)\n\t\t\t{\tif (f===f2) \n\t\t\t\t{\treturn cluster[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n};\n\n/** \n * Stop animation \n * @private \n */\nol_layer_AnimatedCluster.prototype.stopAnimation = function()\n{\tthis.animation.start = false;\n\tthis.animation.cA = [];\n\tthis.animation.cB = [];\n};\n\n/** \n * animate the cluster\n * @private\n */\nol_layer_AnimatedCluster.prototype.animate = function(e)\n{\tvar duration = this.get('animationDuration');\n\tif (!duration) return;\n\tvar resolution = e.frameState.viewState.resolution;\n\tvar a = this.animation;\n\tvar time = e.frameState.time;\n\n\t// Start a new animation, if change resolution and source has changed\n\tif (a.resolution != resolution && this.sourceChanged)\n\t{\tvar extent = e.frameState.extent;\n\t\tif (a.resolution < resolution)\n\t\t{\textent = ol_extent.buffer(extent, 100*resolution);\n\t\t\ta.cA = this.oldcluster.getFeaturesInExtent(extent);\n\t\t\ta.cB = this.getSource().getFeaturesInExtent(extent);\n\t\t\ta.revers = false;\n\t\t}\n\t\telse\n\t\t{\textent = ol_extent.buffer(extent, 100*resolution);\n\t\t\ta.cA = this.getSource().getFeaturesInExtent(extent);\n\t\t\ta.cB = this.oldcluster.getFeaturesInExtent(extent);\n\t\t\ta.revers = true;\n\t\t}\n\t\ta.clusters = [];\n\t\tfor (var i=0, c0; c0=a.cA[i]; i++)\n\t\t{\tvar f = c0.get('features');\n\t\t\tif (f && f.length) \n\t\t\t{\tvar c = this.getClusterForFeature (f[0], a.cB);\n\t\t\t\tif (c) a.clusters.push({ f:c0, pt:c.getGeometry().getCoordinates() });\n\t\t\t}\n\t\t}\n\t\t// Save state\n\t\ta.resolution = resolution;\n\t\tthis.sourceChanged = false;\n\n\t\t// No cluster or too much to animate\n\t\tif (!a.clusters.length || a.clusters.length>1000) \n\t\t{\tthis.stopAnimation();\n\t\t\treturn;\n\t\t}\n\t\t// Start animation from now\n\t\ttime = a.start = (new Date()).getTime();\n\t}\n\n\t// Run animation\n\tif (a.start)\n\t{\tvar vectorContext = e.vectorContext;\n\t\tvar d = (time - a.start) / duration;\n\t\t// Animation ends\n\t\tif (d > 1.0) \n\t\t{\tthis.stopAnimation();\n\t\t\td = 1;\n\t\t}\n\t\td = this.get('animationMethod')(d);\n\t\t// Animate\n\t\tvar style = this.getStyle();\n\t\tvar stylefn = (typeof(style) == 'function') ? style : style.length ? function(){ return style; } : function(){ return [style]; } ;\n\t\t// Layer opacity\n\t\te.context.save();\n\t\te.context.globalAlpha = this.getOpacity();\n\t\t// Retina device\n\t\tvar ratio = e.frameState.pixelRatio;\n\t\tfor (var i=0, c; c=a.clusters[i]; i++)\n\t\t{\tvar pt = c.f.getGeometry().getCoordinates();\n\t\t\tvar dx = pt[0]-c.pt[0];\n\t\t\tvar dy = pt[1]-c.pt[1];\n\t\t\tif (a.revers)\n\t\t\t{\tpt[0] = c.pt[0] + d * dx;\n\t\t\t\tpt[1] = c.pt[1] + d * dy;\n\t\t\t}\n\t\t\telse\n\t\t\t{\tpt[0] = pt[0] - d * dx;\n\t\t\t\tpt[1] = pt[1] - d * dy;\n\t\t\t}\n\t\t\t// Draw feature\n\t\t\tvar st = stylefn(c.f, resolution, true);\n\t\t\t// Preserve pixel ration on retina\n\t\t\tvar geo = new ol_geom_Point(pt);\n\t\t\tfor (var k=0, s; s=st[k]; k++)\n\t\t\t{\tvar sc;\n\t\t\t\t// OL < v4.3 : setImageStyle doesn't check retina\n\t\t\t\tvar imgs = ol_Map.prototype.getFeaturesAtPixel ? false : s.getImage();\n\t\t\t\tif (imgs)\n\t\t\t\t{\tsc = imgs.getScale(); \n\t\t\t\t\timgs.setScale(sc*ratio); \n\t\t\t\t}\n\t\t\t\t// OL3 > v3.14\n\t\t\t\tif (vectorContext.setStyle)\n\t\t\t\t{\t// If one feature: draw the feature\n\t\t\t\t\tif (c.f.get(\"features\").length===1 && !dx && !dy) {\n\t\t\t\t\t\tvectorContext.drawFeature(c.f.get(\"features\")[0], s);\n\t\t\t\t\t}\n\t\t\t\t\t// else draw a point\n\t\t\t\t\telse {\n\t\t\t\t\t\tvectorContext.setStyle(s);\n\t\t\t\t\t\tvectorContext.drawGeometry(geo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// older version\n\t\t\t\telse\n\t\t\t\t{\tvectorContext.setImageStyle(imgs);\n\t\t\t\t\tvectorContext.setTextStyle(s.getText());\n\t\t\t\t\tvectorContext.drawPointGeometry(geo);\n\t\t\t\t}\n\t\t\t\tif (imgs) imgs.setScale(sc);\n\t\t\t}\n\t\t}\n\t\te.context.restore();\n\t\t// tell OL3 to continue postcompose animation\n\t\te.frameState.animate = true;\n\n\t\t// Prevent layer drawing (clip with null rect)\n\t\te.context.save();\n\t\te.context.beginPath();\n\t\te.context.rect(0,0,0,0);\n\t\te.context.clip();\n\t\tthis.clip_ = true;\n\t}\n\n\treturn;\n};\n\n/**  \n * remove clipping after the layer is drawn\n * @private\n */\nol_layer_AnimatedCluster.prototype.postanimate = function(e)\n{\tif (this.clip_)\n\t{\te.context.restore();\n\t\tthis.clip_ = false;\n\t}\n};\n\nexport default ol_layer_AnimatedCluster\n"],"sourceRoot":""}