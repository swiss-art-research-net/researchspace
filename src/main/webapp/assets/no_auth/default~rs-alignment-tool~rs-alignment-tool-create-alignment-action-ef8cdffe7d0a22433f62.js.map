{"version":3,"sources":["webpack:///./src/main/web/components/alignment/AlignmentNodeModel.ts","webpack:///./src/main/web/components/alignment/Serialization.ts","webpack:///./src/main/web/components/alignment/AlignmentService.ts"],"names":["AlignKind","AlignmentNode","set","node","props","rootKey","keyOf","base","Node","aligned","empty","alignKind","ExactMatch","excludeFromAlignment","Immutable","Set","children","readyToLoadBaseForest","KeyedForest","create","readyToLoadRoot","getMatchTarget","forest","getParent","setExactMatch","target","match","filter","child","mergeChildren","asMatchChildren","addNarrowMatches","matches","unalign","undefined","MatchChild","NarrowerMatch","params","baseModel","alignedModel","baseNodeQuery","alignNodeQuery","this","hasMoreChildren","loadMoreChildren","parent","Kefir","combine","reachedLimit","constant","map","loaded","result","baseChildren","asBaseNode","matchChildren","error","flatMapErrors","take","toProperty","loadState","state","targetsToLoad","keySeq","toArray","Rdf","iri","sourcesToLoad","forEach","push","length","source","sourceData","loadSkeleton","iris","useBaseModel","targetData","tree","matchTargetNodes","targetTree","sourceLeafs","targetKey","exact","find","kind","narrow","nodes","get","updateNode","getKeyPath","value","excluded","asNarrowMatch","leafs","model","nodeQuery","loadNodesUsingNodeQuery","sparqlOptions","parameters","item","parametrized","SparqlClient","prepareParsedQuery","select","nodesFromQueryResult","Map","flatMap","loadFromLeafs","transitiveReduction","has","oldNodes","newNodes","mergeRemovingDuplicates","sort","compareAlignmentNodesByLabel","first","second","getNodeLabel","localeCompare","inner","label","AlignmentNodeModel","unalignAll","sourceKey","findFirstAlignmentTarget","emptyNodes","narrowMatch","unaligned","path","removeNode","validateAlignment","targetPath","valid","findExcludedChildren","root","selectionRoot","selection","withMutations","visit","selected","TreeSelection","isTerminal","key","index","getChildIndex","selectionChild","add","rdfs","rdf","groupMatches","matchesByTarget","targetAligned","update","matchesBySource","existing","targetBase","exportAlignment","metadata","values","toMap","serializeAlignment","getOrElse","BASE_IRI","triples","targetIri","matchPointer","bnode","matchPredicate","rso","PX_exact_match","PX_narrow_match","triple","PX_match_target","excludedChild","PX_match_excludes","type","Alignment","literal","comment","description","PX_source_terminology","PX_target_terminology","graph","deserializeAlignment","allMatches","asMutable","s","p","o","isMatch","equals","isIri","pg","targets","getValuesFromPropertyPath","console","warn","Maybe","Just","asImmutable","context","AlignmentContainer","LdpService","AlignmentService"],"mappings":"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","file":"default~rs-alignment-tool~rs-alignment-tool-create-alignment-action-ef8cdffe7d0a22433f62.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2015-2020, © Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\nimport * as Immutable from 'immutable';\nimport * as SparqlJs from 'sparqljs';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { SparqlClient } from 'platform/api/sparql';\n\nimport {\n  KeyedForest,\n  KeyPath,\n  TreeNode,\n  Node,\n  SparqlNodeModel,\n  TreeSelection,\n  Traversable,\n  SelectionNode,\n  nodesFromQueryResult,\n  mergeRemovingDuplicates,\n} from 'platform/components/semantic/lazy-tree';\n\nexport enum AlignKind {\n  ExactMatch = 1,\n  NarrowerMatch,\n  MatchChild,\n}\n\nexport interface AlignmentNode extends TreeNode {\n  readonly children: ReadonlyArray<AlignmentNode>;\n  readonly base?: Node;\n  readonly aligned?: Node;\n  readonly alignKind: AlignKind;\n  /** Keys of excluded from aligned subtree nodes. */\n  readonly excludeFromAlignment: Immutable.Set<string>;\n  /**\n   * True if node is an ancestor of either aligned or decorated as aligned child.\n   * (\"Term has aligned descedants.\")\n   */\n  readonly decorateAlignParent?: boolean;\n  /** Corresponding target node for nodes in source tree. */\n  readonly matchedTargetNode?: Node;\n  /** True if node is a matched child in the source tree. */\n  readonly decorateAlignChild?: boolean;\n}\n\nexport namespace AlignmentNode {\n  export const rootKey = 'AlignmentNode:root';\n  export const keyOf = (node: AlignmentNode) => {\n    return node.base ? Node.keyOf(node.base) : node.aligned ? Node.keyOf(node.aligned) : rootKey;\n  };\n  export const empty: AlignmentNode = {\n    alignKind: AlignKind.ExactMatch,\n    excludeFromAlignment: Immutable.Set<string>(),\n    children: [],\n  };\n  export const readyToLoadBaseForest = KeyedForest.create(AlignmentNode.keyOf, {\n    ...empty,\n    base: Node.readyToLoadRoot,\n  });\n\n  export function set(node: AlignmentNode, props: Partial<AlignmentNode>): AlignmentNode {\n    return { ...node, ...props };\n  }\n\n  export function getMatchTarget(node: AlignmentNode, forest: KeyedForest<AlignmentNode>) {\n    return node.alignKind === AlignKind.ExactMatch ? node : forest.getParent(node);\n  }\n\n  export function setExactMatch(\n    target: AlignmentNode,\n    match: Node,\n    excludeFromAlignment: Immutable.Set<string>\n  ): AlignmentNode {\n    let children = target.children.filter((child) => child.base);\n    if (match.children) {\n      const narrowerMatches = asMatchChildren(match.children, excludeFromAlignment);\n      children = mergeChildren(children, narrowerMatches);\n    }\n    return set(target, { aligned: match, excludeFromAlignment, children });\n  }\n\n  export function addNarrowMatches(target: AlignmentNode, matches: ReadonlyArray<AlignmentNode>): AlignmentNode {\n    const children = mergeChildren(target.children, matches);\n    return set(target, { children });\n  }\n\n  export function unalign(node: AlignmentNode): AlignmentNode | undefined {\n    if (node.aligned) {\n      if (node.alignKind === AlignKind.ExactMatch) {\n        return AlignmentNode.set(node, {\n          aligned: undefined,\n          children: node.children.filter((child) => child.alignKind !== AlignKind.MatchChild),\n        });\n      } else if (node.alignKind === AlignKind.NarrowerMatch) {\n        return undefined;\n      }\n    }\n    return node;\n  }\n}\n\nexport interface AlignmentMatch {\n  kind: AlignKind.ExactMatch | AlignKind.NarrowerMatch;\n  iri: Rdf.Iri;\n  excluded: Immutable.Set<string>;\n}\n\nexport interface AlignmentState {\n  readonly matches: Immutable.Map<string, ReadonlyArray<AlignmentMatch>>;\n  readonly metadata: AlignmentMetadata;\n}\n\nexport interface AlignmentMetadata {\n  iri: Data.Maybe<Rdf.Iri>;\n  source: Rdf.Iri;\n  target: Rdf.Iri;\n  label: string;\n  description: string;\n}\n\nexport interface LoadedState {\n  source: KeyedForest<AlignmentNode>;\n  target: KeyedForest<AlignmentNode>;\n}\n\nexport class AlignmentNodeModel {\n  private readonly baseModel: SparqlNodeModel;\n  private readonly alignedModel: SparqlNodeModel;\n\n  private readonly baseNodeQuery: SparqlJs.SelectQuery | undefined;\n  private readonly alignNodeQuery: SparqlJs.SelectQuery | undefined;\n\n  constructor(params: {\n    baseModel: SparqlNodeModel;\n    alignedModel: SparqlNodeModel;\n    /**\n     * Node info query with [?item] inputs through VALUES(...) clause\n     * and [?item, ?label, ?hasChildren] output variables.\n     */\n    baseNodeQuery?: SparqlJs.SelectQuery;\n    alignNodeQuery?: SparqlJs.SelectQuery;\n  }) {\n    const { baseModel, alignedModel, baseNodeQuery, alignNodeQuery } = params;\n    this.baseModel = baseModel;\n    this.alignedModel = alignedModel;\n    this.baseNodeQuery = baseNodeQuery;\n    this.alignNodeQuery = alignNodeQuery;\n  }\n\n  hasMoreChildren(node: AlignmentNode): boolean {\n    return (\n      (node.base && this.baseModel.hasMoreChildren(node.base)) ||\n      (node.aligned && this.alignedModel.hasMoreChildren(node.aligned))\n    );\n  }\n\n  loadMoreChildren(parent: AlignmentNode): Kefir.Property<AlignmentNode> {\n    const { base, aligned } = parent;\n    if (!base && !aligned) {\n      return Kefir.constant(parent);\n    }\n\n    return Kefir.combine({\n      base: base && !base.reachedLimit ? this.baseModel.loadMoreChildren(base) : Kefir.constant(undefined),\n      aligned:\n        aligned && !aligned.reachedLimit ? this.alignedModel.loadMoreChildren(aligned) : Kefir.constant(undefined),\n    })\n      .map((loaded) => {\n        let result = parent;\n\n        if (loaded.base) {\n          const baseChildren = loaded.base.children.map(asBaseNode);\n          result = AlignmentNode.set(result, {\n            base: loaded.base,\n            children: mergeChildren(result.children, baseChildren),\n          });\n        }\n\n        if (loaded.aligned) {\n          const matchChildren = asMatchChildren(loaded.aligned.children, parent.excludeFromAlignment);\n          result = AlignmentNode.set(result, {\n            aligned: loaded.aligned,\n            children: mergeChildren(result.children, matchChildren),\n          });\n        }\n\n        const error = (result.base && result.base.error) || (result.aligned && result.aligned.error) || undefined;\n        result = AlignmentNode.set(result, { error });\n\n        return result;\n      })\n      .flatMapErrors((error) => Kefir.constant(AlignmentNode.set(parent, { error })))\n      .take(1)\n      .toProperty();\n  }\n\n  loadState(state: AlignmentState): Kefir.Property<LoadedState> {\n    const targetsToLoad = state.matches.keySeq().toArray().map(Rdf.iri);\n    const sourcesToLoad: Rdf.Iri[] = [];\n    state.matches.forEach((matches) => {\n      matches.forEach((match) => sourcesToLoad.push(match.iri));\n    });\n\n    if (sourcesToLoad.length === 0) {\n      return Kefir.constant({\n        source: AlignmentNode.readyToLoadBaseForest,\n        target: AlignmentNode.readyToLoadBaseForest,\n      });\n    }\n\n    function matchTargetNodes(targetTree: AlignmentNode, sourceLeafs: Immutable.Map<string, Node>) {\n      let result = KeyedForest.create(AlignmentNode.keyOf, targetTree);\n      state.matches.forEach((matches, targetKey) => {\n        const exact = matches.find((match) => match.kind === AlignKind.ExactMatch);\n        const narrow = matches.filter((match) => match.kind === AlignKind.NarrowerMatch);\n        result.nodes.get(targetKey).forEach((target) => {\n          result = result.updateNode(result.getKeyPath(target), (node) => {\n            let aligned = node;\n            if (exact) {\n              aligned = AlignmentNode.setExactMatch(aligned, sourceLeafs.get(exact.iri.value), exact.excluded);\n            }\n            aligned = AlignmentNode.addNarrowMatches(\n              aligned,\n              narrow.map((match) => asNarrowMatch(sourceLeafs.get(match.iri.value), match.excluded))\n            );\n            return aligned;\n          });\n        });\n      });\n      return result;\n    }\n\n    return Kefir.combine({\n      sourceData: this.loadSkeleton({ iris: sourcesToLoad, useBaseModel: false }),\n      targetData: this.loadSkeleton({ iris: targetsToLoad, useBaseModel: true }),\n    })\n      .map(({ sourceData, targetData }) => {\n        const source = KeyedForest.create(AlignmentNode.keyOf, sourceData.tree);\n        const target = matchTargetNodes(targetData.tree, sourceData.leafs);\n        return { source, target };\n      })\n      .toProperty();\n  }\n\n  private loadSkeleton(params: { iris: ReadonlyArray<Rdf.Iri>; useBaseModel: boolean }) {\n    const model = params.useBaseModel ? this.baseModel : this.alignedModel;\n    const nodeQuery = params.useBaseModel ? this.baseNodeQuery : this.alignNodeQuery;\n    return loadNodesUsingNodeQuery(params.iris, nodeQuery, model.sparqlOptions()).flatMap((leafs) => {\n      return model\n        .loadFromLeafs(leafs.toArray(), { transitiveReduction: false })\n        .map(asBaseNode)\n        .map((tree) => ({ leafs, tree }));\n    });\n  }\n}\n\nfunction loadNodesUsingNodeQuery(\n  iris: ReadonlyArray<Rdf.Iri>,\n  nodeQuery: SparqlJs.SelectQuery,\n  sparqlOptions: SparqlClient.SparqlOptions\n): Kefir.Property<Immutable.Map<string, Node>> {\n  const parameters = iris.map((iri) => ({ item: iri }));\n  const parametrized = SparqlClient.prepareParsedQuery(parameters)(nodeQuery);\n  return SparqlClient.select(parametrized, sparqlOptions).map((result) => {\n    const nodes = nodesFromQueryResult(result);\n    return Immutable.Map(nodes.map((node) => [node.iri.value, node] as [string, Node]));\n  });\n}\n\nexport function unalignAll(\n  forest: KeyedForest<AlignmentNode>,\n  sourceKey: string,\n  targetKey: string\n): KeyedForest<AlignmentNode> {\n  let result = forest;\n  while (true) {\n    const target = findFirstAlignmentTarget(result, sourceKey, targetKey);\n    if (!target) {\n      break;\n    }\n    const unaligned = AlignmentNode.unalign(target);\n    const path = result.getKeyPath(target);\n    result = unaligned ? result.updateNode(path, () => unaligned) : result.removeNode(path);\n  }\n  return result;\n}\n\nfunction findFirstAlignmentTarget(forest: KeyedForest<AlignmentNode>, sourceKey: string, targetKey: string) {\n  const emptyNodes = Immutable.Set<AlignmentNode>();\n  const narrowMatch = forest.nodes\n    .get(sourceKey, emptyNodes)\n    .find((node) => node.alignKind === AlignKind.NarrowerMatch);\n  if (narrowMatch) {\n    return narrowMatch;\n  }\n  const exactMatch = forest.nodes\n    .get(targetKey, emptyNodes)\n    .find((node) => node.aligned && Node.keyOf(node.aligned) === sourceKey && node.alignKind === AlignKind.ExactMatch);\n  return exactMatch;\n}\n\nexport interface AlignValidationResult {\n  valid: boolean;\n  message?: string;\n}\n\nexport function validateAlignment(\n  forest: KeyedForest<AlignmentNode>,\n  targetPath: KeyPath,\n  source: Node,\n  kind: AlignKind\n): AlignValidationResult {\n  // const target = forest.fromKeyPath(targetPath);\n  // TODO\n  return { valid: true };\n}\n\nfunction asBaseNode(node: Node): AlignmentNode {\n  return AlignmentNode.set(AlignmentNode.empty, {\n    base: node,\n    children: (node.children || []).map(asBaseNode),\n  });\n}\n\nfunction asMatchChildren(\n  children: ReadonlyArray<Node> | undefined,\n  excludeFromAlignment: Immutable.Set<string>\n): ReadonlyArray<AlignmentNode> {\n  return (children || [])\n    .filter((node) => !excludeFromAlignment.has(Node.keyOf(node)))\n    .map((node) =>\n      AlignmentNode.set(AlignmentNode.empty, {\n        aligned: node,\n        alignKind: AlignKind.MatchChild,\n        excludeFromAlignment,\n        children: asMatchChildren(node.children, excludeFromAlignment),\n      })\n    );\n}\n\nexport function asNarrowMatch(node: Node, excludeFromAlignment: Immutable.Set<string>) {\n  return AlignmentNode.set(AlignmentNode.empty, {\n    aligned: node,\n    alignKind: AlignKind.NarrowerMatch,\n    children: asMatchChildren(node.children, excludeFromAlignment),\n    excludeFromAlignment,\n  });\n}\n\nfunction mergeChildren(oldNodes: ReadonlyArray<AlignmentNode>, newNodes: ReadonlyArray<AlignmentNode>) {\n  const result = mergeRemovingDuplicates(AlignmentNode.keyOf, oldNodes, newNodes);\n  result.sort(compareAlignmentNodesByLabel);\n  return result;\n}\n\nexport function findExcludedChildren<T extends Traversable<T>>(\n  root: T,\n  selectionRoot: SelectionNode<T>,\n  selection: TreeSelection<T>\n) {\n  const keyOf = selection.keyOf as (node: T) => string;\n  return Immutable.Set<string>().withMutations((excluded) => {\n    const visit = (node: T, selected: SelectionNode<T>) => {\n      if (TreeSelection.isTerminal(selected)) {\n        return;\n      }\n      for (const child of node.children) {\n        const key = keyOf(child);\n        const index = selection.getChildIndex(selected, key);\n        if (typeof index === 'number') {\n          const selectionChild = selected.children[index] as SelectionNode<T>;\n          visit(child, selectionChild);\n        } else {\n          excluded.add(key);\n        }\n      }\n    };\n    visit(root, selectionRoot);\n  });\n}\n\nfunction compareAlignmentNodesByLabel(first: AlignmentNode, second: AlignmentNode) {\n  return getNodeLabel(first).localeCompare(getNodeLabel(second));\n}\n\nfunction getNodeLabel(node: AlignmentNode): string {\n  const inner = node.base || node.aligned;\n  return inner && inner.label ? inner.label.value : '';\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, © Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Immutable from 'immutable';\nimport * as Maybe from 'data.maybe';\n\nimport { Rdf, vocabularies } from 'platform/api/rdf';\nconst { rdfs, rdf } = vocabularies;\nimport { rso } from 'platform/data/vocabularies';\n\nimport { KeyedForest } from 'platform/components/semantic/lazy-tree';\n\nimport { AlignmentNode, AlignmentState, AlignmentMatch, AlignKind, AlignmentMetadata } from './AlignmentNodeModel';\n\nexport interface MatchEntry {\n  kind: AlignKind.ExactMatch | AlignKind.NarrowerMatch;\n  targetBase: AlignmentNode;\n  targetAligned: AlignmentNode;\n}\n\n/**\n * Groups match entries by target key then source key, e.g.:\n * ```\n * targetKey -> sourceKey -> MatchEntry\n * ```\n */\nexport function groupMatches(\n  forest: KeyedForest<AlignmentNode>\n): Immutable.Map<string, Immutable.Map<string, MatchEntry>> {\n  return Immutable.Map<string, Immutable.Map<string, MatchEntry>>().withMutations((matchesByTarget) => {\n    forest.nodes.forEach((nodes, key) => {\n      nodes.forEach((targetAligned) => {\n        const kind = targetAligned.alignKind;\n        if (targetAligned.aligned && (kind === AlignKind.ExactMatch || kind === AlignKind.NarrowerMatch)) {\n          const targetBase = AlignmentNode.getMatchTarget(targetAligned, forest);\n          const targetKey = targetBase.base.iri.value;\n          matchesByTarget.update(targetKey, (matchesBySource) => {\n            const existing = matchesBySource || Immutable.Map<string, MatchEntry>();\n            const sourceKey = targetAligned.aligned.iri.value;\n            if (existing.has(sourceKey)) {\n              return existing;\n            }\n            return existing.set(sourceKey, { kind, targetAligned, targetBase });\n          });\n        }\n      });\n    });\n  });\n}\n\nexport function exportAlignment(forest: KeyedForest<AlignmentNode>, metadata: AlignmentMetadata): AlignmentState {\n  const matches = groupMatches(forest)\n    .map((values) =>\n      values\n        .map(\n          ({ kind, targetAligned }): AlignmentMatch => ({\n            kind,\n            iri: targetAligned.aligned.iri,\n            excluded: targetAligned.excludeFromAlignment,\n          })\n        )\n        .toArray()\n    )\n    .toMap();\n  return { matches, metadata };\n}\n\nexport function serializeAlignment(state: AlignmentState): Rdf.Graph {\n  const iri = state.metadata.iri.getOrElse(Rdf.BASE_IRI);\n  const triples: Rdf.Triple[] = [];\n  state.matches.forEach((matches, targetIri) => {\n    const target = Rdf.iri(targetIri);\n    for (const match of matches) {\n      const matchPointer = Rdf.bnode();\n      const matchPredicate = match.kind === AlignKind.ExactMatch ? rso.PX_exact_match : rso.PX_narrow_match;\n      triples.push(Rdf.triple(match.iri, matchPredicate, matchPointer));\n      triples.push(Rdf.triple(matchPointer, rso.PX_match_target, target));\n      match.excluded.forEach((excludedChild) => {\n        triples.push(Rdf.triple(matchPointer, rso.PX_match_excludes, Rdf.iri(excludedChild)));\n      });\n    }\n  });\n  triples.push(\n    Rdf.triple(iri, rdf.type, rso.Alignment),\n    Rdf.triple(iri, rdfs.label, Rdf.literal(state.metadata.label)),\n    Rdf.triple(iri, rdfs.comment, Rdf.literal(state.metadata.description)),\n    Rdf.triple(iri, rso.PX_source_terminology, state.metadata.source),\n    Rdf.triple(iri, rso.PX_target_terminology, state.metadata.target)\n  );\n  return Rdf.graph(triples);\n}\n\nexport function deserializeAlignment(graph: Rdf.Graph): AlignmentState {\n  const allMatches = Immutable.Map<string, Array<AlignmentMatch>>().asMutable();\n  const metadata: AlignmentMetadata = {} as any;\n\n  graph.triples.forEach(({ s, p, o }) => {\n    const isMatch = p.equals(rso.PX_exact_match) || p.equals(rso.PX_narrow_match);\n    if (s.isIri() && isMatch) {\n      const match = Rdf.pg(o, graph);\n      const kind = p.equals(rso.PX_exact_match) ? AlignKind.ExactMatch : AlignKind.NarrowerMatch;\n      const targets = Rdf.getValuesFromPropertyPath([rso.PX_match_target], match);\n      if (targets.length !== 1) {\n        console.warn(`Skipping alignment match source ${s} with multiple target nodes.`);\n        return;\n      }\n      const excluded = Immutable.Set(\n        Rdf.getValuesFromPropertyPath([rso.PX_match_excludes], match)\n          .filter((node) => node.isIri())\n          .map((node) => node.value)\n      );\n      allMatches.update(targets[0].value, (matches) => {\n        const result = matches || [];\n        result.push({ kind, iri: s, excluded });\n        return result;\n      });\n    } else if (p.equals(rdfs.label) && s.isIri()) {\n      metadata.iri = Maybe.Just(s);\n      metadata.label = o.value;\n    } else if (p.equals(rdfs.comment)) {\n      metadata.description = o.value;\n    } else if (p.equals(rso.PX_source_terminology) && o.isIri()) {\n      metadata.source = o;\n    } else if (p.equals(rso.PX_target_terminology) && o.isIri()) {\n      metadata.target = o;\n    }\n  });\n\n  return { matches: allMatches.asImmutable(), metadata };\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, © Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { LdpService, LdpServiceContext } from 'platform/api/services/ldp';\n\nimport { rso } from 'platform/data/vocabularies';\n\nexport class AlignmentService extends LdpService {\n  constructor(context?: LdpServiceContext) {\n    super(rso.AlignmentContainer.value);\n  }\n}\n"],"sourceRoot":""}