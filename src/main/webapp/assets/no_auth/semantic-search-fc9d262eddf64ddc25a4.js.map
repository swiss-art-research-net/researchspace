{"version":3,"sources":["webpack:///./src/main/web/components/semantic/search/web-components/SemanticSearch.ts","webpack:///./src/main/web/components/semantic/search/data/profiles/SearchProfileStore.ts","webpack:///./src/main/web/components/semantic/search/data/profiles/SearchProfileService.ts"],"names":["props","context","cancellation","Cancellation","savingState","derive","loadingResults","activeResultOperations","getDefaultDatasets","availableDatasets","_","filter","d","isDefault","getDefaultAlignments","alignments","map","find","a","isEmpty","Maybe","Nothing","Just","head","mapAlignemnts","iri","label","Rdf","useInExtendedFcFrSearch","item","setState","extendedSearch","facetStructure","setBaseQuery","query","state","listenForResultsLoading","baseQuery","getOrElse","hasFacet","isJust","resultQuery","resultsLoaded","isConfigurationEditable","setBaseQueryStructure","baseQueryStructure","queryStructure","cloneDeep","get","resultState","saveStateIntoHistory","search","facet","result","datasets","selectedDatasets","alignment","selectedAlignment","graphScopeSearch","graphScopeStructure","clearCurrentHistoryItem","setFacetStructure","facetAstCopy","undefined","setFacetedQuery","setFacetActions","actions","facetActions","setDomain","domain","setAvailableDomains","domains","availableDomains","setSelectedDatasets","setSelectedAlignment","setVisualizationContext","visualizationContext","setSearchProfileStore","profileStore","searchProfileStore","setGraphScopeStructure","setGraphScopeResults","graphScopeResults","getStateFromHistory","params","compressed","reload","serializedState","getCurrentUrl","packedJson","decompressFromEncodedURIComponent","packed","JSON","parse","serialized","unpackState","raw","Deserializer","deserializeState","error","addNotification","level","message","console","previousState","store","serializeSearch","s","cancelAll","currentUrl","clone","removeSearch","addSearch","Kefir","constant","onValue","url","window","history","replaceState","toString","notifyResultLoading","operation","task","observe","value","type","resultCount","updateResultState","componentId","stateChange","makeSearchContext","this","resultsStatus","loaded","count","fromNullable","baseConfig","bindings","componentDidMount","searchProfile","createSearchProfileStore","savedState","chain","orElse","trigger","eventType","BuiltInEvents","ComponentLoaded","source","id","componentWillUnmount","datasetsConfig","dc","silent","datasetIri","deriveAndCancel","render","React","createElement","SemanticSearchContext","Provider","D","div","children","currentUri","removeQuery","defaultProps","optimizer","categories","SearchDefaults","DefaultTextPattern","categoriesQuery","DefaultSearchProfileCategoriesQuery","relationsQuery","DefaultSearchProfileRelationsQuery","defaultProfile","DefaultProfile","limit","ResultLimit","selectorMode","Component","SemanticSearch","config","profiles","rangesFor","category","relations","some","relation","hasDomain","equals","hasRange","includes","getCategoryTypes","_config","_availableProfiles","_profile","availableProfiles","first","isQuerySearchProfileConfig","profileConfig","fullIri","filterCategories","rel","relationsFor","range","domainMatch","rangeMatch","r","getCategory","SearchProfileStore","fetchSearchProfilesQuery","ps","fetchSearchProfilesInline","constructCategoryFromInline","inlineConfig","thumbnail","color","description","tuple","literal","constructCategoriesFromBindings","constructCategoryBromBinding","groupBy","toOrderedMap","cs","binding","RELATION_PROFILE_VARIABLES","THUMBNAIL_PROJECTION_VAR","CATEGORY_PROJECTION_VAR","LABEL_PROJECTION_VAR","DESCRIPTION_PROJECTION_VAR","combine","SparqlClient","select","categoriesBindings","relationsBindings","profilesCategories","constructCategories","List","PROFILE_PROJECTION_VAR","toMap","results","profilesRelations","constructRelations","profileBindings","profile","constructRelationsFromBindings","constructRelationBromBinding","RELATION_PROJECTION_VAR","RELATION_RANGE_PROJECTION_VAR","RELATION_DOMAIN_PROJECTION_VAR","hashCode","other","RelationKey","key","rs","mapEntries","toProperty","constructCategoriesFromInline","inlineConfigs","constructRelationsFromInline","inlineRelation","constructRelationFromInline","dummyProfile","DefaultInlineProfile","theProfile","Map"],"mappings":"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","file":"semantic-search-fc9d262eddf64ddc25a4.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as React from 'react';\nimport * as D from 'react-dom-factories';\nimport * as _ from 'lodash';\nimport * as Kefir from 'kefir';\nimport * as Maybe from 'data.maybe';\nimport { decompressFromEncodedURIComponent } from 'lz-string';\nimport * as SparqlJs from 'sparqljs';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { Cancellation } from 'platform/api/async';\nimport { getCurrentUrl } from 'platform/api/navigation';\nimport { Component } from 'platform/api/components';\nimport { trigger, BuiltInEvents } from 'platform/api/events';\nimport { addNotification } from 'platform/components/ui/notification';\n\nimport { SemanticSearchConfig, DatasetAlignmentConfig } from '../config/SearchConfig';\nimport * as SearchDefaults from '../config/Defaults';\nimport * as Model from '../data/search/Model';\nimport { RawState, Deserializer, unpackState, serializeSearch } from '../data/search/Serialization';\nimport * as FacetModel from '../data/facet/Model';\nimport { Dataset, Alignment } from '../data/datasets/Model';\nimport { SemanticSearchContext, ResultOperation, ExtendedSearchValue } from './SemanticSearchApi';\nimport { SearchProfileStore, createSearchProfileStore } from '../data/profiles/SearchProfileStore';\n\nexport interface Props extends React.Props<SemanticSearch>, SemanticSearchConfig {}\ninterface State {\n  domain?: Data.Maybe<Model.Category>;\n  availableDomains?: Data.Maybe<Model.AvailableDomains>;\n  baseQuery?: Data.Maybe<SparqlJs.SelectQuery>;\n  baseQueryStructure?: Data.Maybe<Model.Search>;\n  facetStructure?: FacetModel.Ast;\n  facetActions?: FacetModel.Actions;\n  extendedSearch?: Data.Maybe<{ value: ExtendedSearchValue; range: Model.Category }>;\n  resultQuery?: Data.Maybe<SparqlJs.SelectQuery>;\n  searchProfileStore?: Data.Maybe<SearchProfileStore>;\n  hasFacet?: boolean;\n  resultsLoaded?: boolean;\n  resultState?: { [componentId: string]: object };\n  availableDatasets?: Array<Dataset>;\n  selectedDatasets?: Array<Dataset>;\n  selectedAlignment?: Data.Maybe<Alignment>;\n  isConfigurationEditable?: boolean;\n  visualizationContext?: Data.Maybe<Model.Relation>;\n  graphScopeStructure?: Data.Maybe<Model.GraphScopeSearch>;\n  graphScopeResults?: Data.Maybe<Model.GraphScopeResults>;\n}\n\nconst SAVED_STATE_QUERY_KEY = 'semanticSearch';\n\nexport class SemanticSearch extends Component<Props, State> {\n  static defaultProps: Partial<Props> = {\n    optimizer: 'blazegraph',\n    categories: SearchDefaults.DefaultTextPattern(),\n    searchProfile: {\n      categoriesQuery: SearchDefaults.DefaultSearchProfileCategoriesQuery,\n      relationsQuery: SearchDefaults.DefaultSearchProfileRelationsQuery,\n      defaultProfile: SearchDefaults.DefaultProfile,\n    },\n    limit: SearchDefaults.ResultLimit,\n    selectorMode: 'stack',\n  };\n\n  private readonly cancellation = new Cancellation();\n\n  private savingState = this.cancellation.derive();\n  private serializedState: string;\n\n  private loadingResults = this.cancellation.derive();\n  private activeResultOperations = 0;\n  private resultCount: number | undefined;\n\n  constructor(props: Props, context: any) {\n    super(props, context);\n    const availableDatasets = this.availableDatasets(props);\n    this.state = {\n      domain: Maybe.Nothing<Model.Category>(),\n      availableDomains: Maybe.Nothing<Model.AvailableDomains>(),\n      baseQuery: Maybe.Nothing<SparqlJs.SelectQuery>(),\n      baseQueryStructure: Maybe.Nothing<Model.Search>(),\n      resultQuery: Maybe.Nothing<SparqlJs.SelectQuery>(),\n      searchProfileStore: Maybe.Nothing<SearchProfileStore>(),\n      extendedSearch: Maybe.Nothing<{\n        value: ExtendedSearchValue;\n        range: Model.Category;\n      }>(),\n      hasFacet: false,\n      resultState: {},\n      availableDatasets: availableDatasets,\n      selectedDatasets: this.getDefaultDatasets(availableDatasets),\n      selectedAlignment: this.getDefaultAlignments(availableDatasets),\n      isConfigurationEditable: true,\n      visualizationContext: Maybe.Nothing<Model.Relation>(),\n      graphScopeStructure: Maybe.Nothing<Model.GraphScopeSearch>(),\n      graphScopeResults: Maybe.Nothing<Model.GraphScopeResults>(),\n    };\n  }\n\n  private makeSearchContext(): SemanticSearchContext {\n    return {\n      baseQuery: this.state.baseQuery,\n      useInExtendedFcFrSearch: this.useInExtendedFcFrSearch,\n      extendedSearch: this.state.extendedSearch,\n      baseQueryStructure: this.state.baseQueryStructure,\n      resultsStatus: { loaded: this.state.resultsLoaded, count: this.resultCount },\n      facetStructure: Maybe.fromNullable(this.state.facetStructure),\n      facetActions: Maybe.fromNullable(this.state.facetActions),\n      baseConfig: this.props,\n      domain: this.state.domain,\n      availableDomains: this.state.availableDomains,\n      setDomain: this.setDomain,\n      setAvailableDomains: this.setAvailableDomains,\n      setBaseQuery: this.setBaseQuery,\n      setBaseQueryStructure: this.setBaseQueryStructure,\n      setSearchProfileStore: this.setSearchProfileStore,\n      setFacetStructure: this.setFacetStructure,\n      setFacetedQuery: this.setFacetedQuery,\n      setFacetActions: this.setFacetActions,\n      resultQuery: this.state.resultQuery,\n      searchProfileStore: this.state.searchProfileStore,\n      bindings: {},\n      notifyResultLoading: this.notifyResultLoading,\n      resultState: this.state.resultState,\n      updateResultState: this.updateResultState,\n      selectedDatasets: this.state.selectedDatasets,\n      selectedAlignment: this.state.selectedAlignment,\n      setSelectedDatasets: this.setSelectedDatasets,\n      setSelectedAlignment: this.setSelectedAlignment,\n      isConfigurationEditable: this.state.isConfigurationEditable,\n      availableDatasets: this.state.availableDatasets,\n      visualizationContext: this.state.visualizationContext,\n      setVisualizationContext: this.setVisualizationContext,\n      graphScopeStructure: this.state.graphScopeStructure,\n      setGraphScopeStructure: this.setGraphScopeStructure,\n      graphScopeResults: this.state.graphScopeResults,\n      setGraphScopeResults: this.setGraphScopeResults,\n    };\n  }\n\n  componentDidMount() {\n    if (this.props.searchProfile) {\n      this.cancellation.map(createSearchProfileStore(this.props, this.props.searchProfile)).onValue((store) => {\n        const savedState = this.getStateFromHistory(store, { reload: true });\n        this.setState((s: State) => ({\n          selectedDatasets: savedState.map((state) => state.datasets).getOrElse(s.selectedDatasets),\n          selectedAlignment: savedState.chain((state) => state.alignment).orElse(() => s.selectedAlignment),\n          searchProfileStore: Maybe.Just(store),\n          baseQueryStructure: savedState.chain((state) => Maybe.fromNullable(state.search)),\n          facetStructure: savedState.chain((state) => Maybe.fromNullable(state.facet)).getOrElse(undefined),\n          resultState: savedState.map((state) => state.result).getOrElse({}),\n          graphScopeStructure: savedState.map((state) => state.graphScopeSearch).getOrElse(s.graphScopeStructure),\n        }));\n      });\n    }\n    trigger({ eventType: BuiltInEvents.ComponentLoaded, source: this.props.id });\n  }\n\n  componentWillUnmount() {\n    this.cancellation.cancelAll();\n  }\n\n  private getDefaultDatasets = (availableDatasets: Array<Dataset>) => _.filter(availableDatasets, (d) => d.isDefault);\n\n  private getDefaultAlignments = (availableDatasets: Array<Dataset>) => {\n    const alignments = _.map(this.getDefaultDatasets(availableDatasets), (d) =>\n      _.find(d.alignments, (a) => a.isDefault)\n    );\n    if (_.isEmpty(alignments)) {\n      return Maybe.Nothing<Alignment>();\n    } else {\n      return Maybe.Just(_.head(alignments));\n    }\n  };\n\n  private availableDatasets(props: Props) {\n    const datasets = Maybe.fromNullable(props.datasetsConfig)\n      .map((dc) => dc.datasets)\n      .getOrElse([]);\n    return datasets.map(({ iri, label, silent, alignments, isDefault }) => {\n      const datasetIri = iri || 'http://www.researchspace.org/ontology#default';\n      return {\n        iri: Rdf.iri(datasetIri),\n        alignments: this.mapAlignemnts(alignments),\n        silent: silent || false,\n        label,\n        isDefault,\n      };\n    });\n  }\n\n  private mapAlignemnts = (alignments: Array<DatasetAlignmentConfig>): Array<Alignment> =>\n    alignments.map(({ iri, label, isDefault }) => ({ iri: Rdf.iri(iri), label, isDefault }));\n\n  private useInExtendedFcFrSearch = (item: { value: ExtendedSearchValue; range: Model.Category }) =>\n    this.setState({\n      extendedSearch: Maybe.Just(item),\n      facetStructure: null, // reset facet when creating extended search\n    });\n\n  private setBaseQuery = (query: Data.Maybe<SparqlJs.SelectQuery>) => {\n    this.setState(\n      (state): State => {\n        this.listenForResultsLoading();\n        return {\n          baseQuery: query,\n          // reset facet when base query is also reset\n          facetStructure: query.map((_) => state.facetStructure).getOrElse(null),\n          hasFacet: query.isJust ? state.hasFacet : false,\n          resultQuery: query,\n          resultsLoaded: false,\n          isConfigurationEditable: query.isJust ? false : true,\n        };\n      }\n    );\n  };\n\n  private setBaseQueryStructure = (baseQueryStructure: Data.Maybe<Model.Search>) => {\n    if (baseQueryStructure === this.state.baseQueryStructure) {\n      return;\n    }\n\n    if (baseQueryStructure.isJust) {\n      const queryStructure = _.cloneDeep(baseQueryStructure.get());\n      this.setState({\n        baseQueryStructure: Maybe.Just(queryStructure),\n        resultState: {},\n      });\n      this.saveStateIntoHistory({\n        search: queryStructure,\n        facet: this.state.facetStructure,\n        result: {},\n        datasets: this.state.selectedDatasets,\n        alignment: this.state.selectedAlignment,\n        graphScopeSearch: this.state.graphScopeStructure,\n      });\n    } else {\n      this.setState({\n        baseQueryStructure: Maybe.Nothing<Model.Search>(),\n        isConfigurationEditable: true,\n      });\n      this.clearCurrentHistoryItem();\n    }\n  };\n\n  private setFacetStructure = (facetStructure: FacetModel.Ast) => {\n    const facetAstCopy = _.cloneDeep(facetStructure);\n    this.setState({ facetStructure: facetAstCopy });\n    this.saveStateIntoHistory({\n      search: this.state.baseQueryStructure.getOrElse(undefined),\n      facet: facetAstCopy,\n      result: this.state.resultState,\n      datasets: this.state.selectedDatasets,\n      alignment: this.state.selectedAlignment,\n      graphScopeSearch: this.state.graphScopeStructure,\n    });\n  };\n\n  private setFacetedQuery = (query: SparqlJs.SelectQuery) => {\n    this.listenForResultsLoading();\n    this.setState({\n      resultQuery: Maybe.Just(query),\n      hasFacet: true,\n      resultsLoaded: false,\n    });\n  };\n\n  private setFacetActions = (actions: FacetModel.Actions) => {\n    this.setState({ facetActions: actions });\n  };\n\n  private setDomain = (domain: Model.Category) => {\n    this.setState({ domain: Maybe.Just(domain) });\n  };\n\n  private setAvailableDomains = (domains: Model.AvailableDomains) => {\n    this.setState({ availableDomains: Maybe.Just(domains) });\n  };\n\n  private setSelectedDatasets = (datasets: Array<Dataset>) => this.setState({ selectedDatasets: datasets });\n\n  private setSelectedAlignment = (alignment: Data.Maybe<Alignment>) => this.setState({ selectedAlignment: alignment });\n\n  private setVisualizationContext = (visualizationContext: Data.Maybe<Model.Relation>) =>\n    this.setState({ visualizationContext });\n\n  private setSearchProfileStore = (profileStore: SearchProfileStore) => {\n    this.setState({ searchProfileStore: Maybe.Just(profileStore) });\n  };\n\n  private setGraphScopeStructure = (graphScopeStructure: Data.Maybe<Model.GraphScopeSearch>) => {\n    this.setState({ graphScopeStructure });\n    this.saveStateIntoHistory({\n      search: this.state.baseQueryStructure.getOrElse(undefined),\n      facet: this.state.facetStructure,\n      result: this.state.resultState,\n      datasets: this.state.selectedDatasets,\n      alignment: this.state.selectedAlignment,\n      graphScopeSearch: graphScopeStructure,\n    });\n  };\n\n  private setGraphScopeResults = (graphScopeResults: Data.Maybe<Model.GraphScopeResults>) => {\n    this.setState({ graphScopeResults });\n  };\n\n  private listenForResultsLoading() {\n    this.loadingResults = this.cancellation.deriveAndCancel(this.loadingResults);\n    this.activeResultOperations = 0;\n    this.resultCount = undefined;\n  }\n\n  render() {\n    return React.createElement(\n      SemanticSearchContext.Provider,\n      { value: this.makeSearchContext() },\n      D.div({}, this.props.children)\n    );\n  }\n\n  private getStateFromHistory = (\n    profileStore: SearchProfileStore,\n    params: { reload?: boolean } = {}\n  ): Data.Maybe<RawState> => {\n    const compressed =\n      params.reload || this.serializedState === undefined\n        ? getCurrentUrl().query(true)[SAVED_STATE_QUERY_KEY]\n        : this.serializedState;\n\n    if (typeof compressed === 'string') {\n      try {\n        const packedJson = decompressFromEncodedURIComponent(compressed);\n        const packed = JSON.parse(packedJson);\n        const serialized = unpackState(packed);\n        const raw = new Deserializer(profileStore).deserializeState(serialized);\n        return Maybe.Just(raw);\n      } catch (error) {\n        if (params.reload) {\n          addNotification({ level: 'warning', message: 'Error restoring search state' });\n        }\n        console.error('Error restoring search state: ', error);\n        return Maybe.Nothing<RawState>();\n      }\n    } else {\n      return Maybe.Nothing<RawState>();\n    }\n  };\n\n  private saveStateIntoHistory = (state: RawState) => {\n    const previousState = this.state.searchProfileStore\n      .map((store) => this.getStateFromHistory(store))\n      .getOrElse(Maybe.Nothing<RawState>());\n\n    const compressed = serializeSearch(\n      state.search || previousState.map((s) => s.search).getOrElse(undefined),\n      state.facet || previousState.map((s) => s.facet).getOrElse(undefined),\n      state.result,\n      state.datasets,\n      state.alignment,\n      state.graphScopeSearch\n    );\n\n    if (compressed === this.serializedState) {\n      return;\n    }\n    this.serializedState = compressed;\n\n    this.savingState.cancelAll();\n    this.savingState = this.cancellation.derive();\n\n    // when updating query string we need to make sure that we keep all\n    // other query parameters, e.g repository\n    const currentUrl = getCurrentUrl().clone();\n    currentUrl.removeSearch(SAVED_STATE_QUERY_KEY).addSearch({ [SAVED_STATE_QUERY_KEY]: compressed });\n    this.savingState.map(Kefir.constant(currentUrl)).onValue((url) => {\n      window.history.replaceState({}, '', url.toString());\n    });\n  };\n\n  private clearCurrentHistoryItem() {\n    this.savingState.cancelAll();\n    const currentUri = getCurrentUrl();\n    if (SAVED_STATE_QUERY_KEY in currentUri.query(true)) {\n      window.history.replaceState({}, '', currentUri.clone().removeQuery(SAVED_STATE_QUERY_KEY).toString());\n    }\n  }\n\n  private notifyResultLoading = (operation: ResultOperation) => {\n    this.activeResultOperations++;\n    const task: Kefir.Observable<number | void> = operation.task;\n    this.loadingResults.map(task).observe({\n      value: (result) => {\n        this.activeResultOperations--;\n        if (operation.type === 'count' && typeof result === 'number') {\n          this.resultCount = result;\n        }\n        if (this.activeResultOperations === 0) {\n          this.setState({ resultsLoaded: true });\n        }\n      },\n    });\n  };\n\n  private updateResultState = (componentId: string, stateChange: object) => {\n    this.setState(\n      ({ resultState }): State => ({\n        resultState: {\n          ...resultState,\n          [componentId]: { ...resultState[componentId], ...stateChange } as object,\n        },\n      }),\n      () =>\n        this.saveStateIntoHistory({\n          search: this.state.baseQueryStructure.getOrElse(undefined),\n          facet: this.state.facetStructure,\n          result: this.state.resultState,\n          datasets: this.state.selectedDatasets,\n          alignment: this.state.selectedAlignment,\n          graphScopeSearch: this.state.graphScopeStructure,\n        })\n    );\n  };\n}\n\nexport default SemanticSearch;\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as maybe from 'data.maybe';\nimport * as Kefir from 'kefir';\nimport * as _ from 'lodash';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { fetchSearchProfilesQuery, fetchSearchProfilesInline } from './SearchProfileService';\nimport {\n  SearchProfileConfig,\n  SemanticSearchConfig,\n  isQuerySearchProfileConfig,\n  QuerySearchProfileConfig,\n  InlineSearchProfileConfig,\n} from '../../config/SearchConfig';\nimport { getCategoryTypes } from '../search/ModelUtils';\nimport { Category, Categories, Relation, Relations, Profile, Profiles } from './Model';\n\n// refactor to search and edit store, + one generic store\nexport class SearchProfileStore {\n  _availableProfiles: Profiles;\n  _profile: Profile;\n  _config: SemanticSearchConfig;\n\n  constructor(config: SemanticSearchConfig, profiles: Profiles) {\n    this._availableProfiles = profiles;\n    this._profile = (this.availableProfiles as any).first();\n\n    if (isQuerySearchProfileConfig(config.searchProfile)) {\n      const profileConfig = config.searchProfile as QuerySearchProfileConfig;\n      if (profileConfig.defaultProfile) {\n        this._profile = this._availableProfiles.get(Rdf.fullIri(profileConfig.defaultProfile));\n      }\n    }\n    this._config = config;\n  }\n\n  public get availableProfiles(): Profiles {\n    return this._availableProfiles;\n  }\n\n  public get profile(): Profile {\n    return this._profile;\n  }\n\n  public get categories(): Categories {\n    return this._profile.categories;\n  }\n\n  public get domains(): Categories {\n    return this.filterCategories((rel) => rel.hasDomain);\n  }\n\n  public get relations(): Relations {\n    return this._profile.relations;\n  }\n\n  public get ranges(): Categories {\n    return this.filterCategories((rel) => rel.hasRange);\n  }\n\n  public rangesFor = (domain: Category): Categories => {\n    const ranges = this.categories.filter(\n      (category) =>\n        this.relations.some(\n          (relation) => relation.hasDomain.iri.equals(domain.iri) && relation.hasRange.iri.equals(category.iri)\n        ) || _.includes(getCategoryTypes(this._config, category), 'text')\n    ) as Categories;\n    return ranges;\n  };\n\n  public relationsFor({ domain = maybe.Nothing<Category>(), range = maybe.Nothing<Category>() }): Relations {\n    return this.relations.filter((rel) => {\n      const domainMatch = domain.map((d) => rel.hasDomain.iri.equals(d.iri)).getOrElse(true);\n      const rangeMatch = range.map((r) => rel.hasRange.iri.equals(r.iri)).getOrElse(true);\n      return domainMatch && rangeMatch;\n    }) as Relations;\n  }\n\n  private filterCategories(getCategory: (rel: Relation) => Category): Categories {\n    return this.categories.filter((category) =>\n      this.relations.some((rel) => getCategory(rel).iri.equals(category.iri))\n    ) as Categories;\n  }\n}\n\nexport function createSearchProfileStore(\n  config: SemanticSearchConfig,\n  profileConfig: SearchProfileConfig\n): Kefir.Property<SearchProfileStore> {\n  if (isQuerySearchProfileConfig(profileConfig)) {\n    return fetchSearchProfilesQuery(profileConfig).map((ps) => new SearchProfileStore(config, ps));\n  } else {\n    return fetchSearchProfilesInline(profileConfig).map((ps) => new SearchProfileStore(config, ps));\n  }\n}\n\nexport default SearchProfileStore;\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\nimport { Map, List } from 'immutable';\n\nimport {\n  QuerySearchProfileConfig,\n  InlineSearchProfileConfig,\n  RELATION_PROFILE_VARIABLES,\n  InlineCategory,\n  InlineRelation,\n} from '../../config/SearchConfig';\nimport { SparqlClient } from 'platform/api/sparql';\nimport { Rdf } from 'platform/api/rdf';\nimport { Category, Categories, Relation, Relations, RelationKey, Profiles, Profile } from './Model';\nimport * as SearchDefaults from '../../config/Defaults';\n\nexport function fetchSearchProfilesQuery(config: QuerySearchProfileConfig): Kefir.Property<Profiles> {\n  return Kefir.combine(\n    [SparqlClient.select(config.categoriesQuery), SparqlClient.select(config.relationsQuery)],\n    (categoriesBindings, relationsBindings) => {\n      const profilesCategories = constructCategories(categoriesBindings.results.bindings);\n      const profilesRelations = constructRelations(relationsBindings.results.bindings, profilesCategories);\n      const profiles = profilesCategories.mapEntries(([profile, categories]) => {\n        return [\n          profile,\n          {\n            iri: profile,\n            label: profile.value,\n            categories: categories,\n            relations: profilesRelations.get(profile),\n          },\n        ];\n      });\n      return profiles as any;\n    }\n  ).toProperty();\n}\n\nexport function fetchSearchProfilesInline(config: InlineSearchProfileConfig): Kefir.Property<Profiles> {\n  const categories: Categories = constructCategoriesFromInline(config.categories);\n  const relations: Relations = constructRelationsFromInline(config.relations, categories);\n  const dummyProfile = Rdf.fullIri(SearchDefaults.DefaultInlineProfile);\n  const theProfile: Profile = {\n    iri: dummyProfile,\n    label: dummyProfile.value,\n    description: dummyProfile.value,\n    tuple: { iri: dummyProfile },\n    categories: categories,\n    relations: relations,\n  };\n  const profiles = Map([[dummyProfile, theProfile]]);\n  return Kefir.constant(profiles);\n}\n\ntype ProfilesCategories = Map<Rdf.Iri, Categories>;\nfunction constructCategories(bindings: SparqlClient.Bindings): ProfilesCategories {\n  const categoriesByProfile = List(bindings).groupBy(\n    (binding) => binding[RELATION_PROFILE_VARIABLES.PROFILE_PROJECTION_VAR] as Rdf.Iri\n  );\n\n  return categoriesByProfile.map(constructCategoriesFromBindings).toMap();\n}\n\nfunction constructCategoriesFromInline(inlineConfigs: Array<InlineCategory>): Categories {\n  return List(inlineConfigs)\n    .map(constructCategoryFromInline)\n    .groupBy((category) => category.iri)\n    .toOrderedMap()\n    .map((cs) => cs.first()) as Categories;\n}\n\nfunction constructCategoryFromInline(inlineConfig: InlineCategory): Category {\n  return {\n    iri: Rdf.fullIri(inlineConfig.iri),\n    label: inlineConfig.label,\n    thumbnail: inlineConfig.thumbnail,\n    color: inlineConfig.color,\n    description: inlineConfig.label,\n    tuple: {\n      iri: Rdf.fullIri(inlineConfig.iri),\n      label: Rdf.literal(inlineConfig.label),\n      thumbnail: inlineConfig.thumbnail ? Rdf.literal(inlineConfig.thumbnail) : undefined,\n    },\n  };\n}\n\nfunction constructCategoriesFromBindings(bindings: List<SparqlClient.Binding>): Categories {\n  return bindings\n    .map(constructCategoryBromBinding)\n    .groupBy((category) => category.iri)\n    .toOrderedMap()\n    .map((cs) => cs.first()) as Categories;\n}\n\nfunction constructCategoryBromBinding(binding: SparqlClient.Binding): Category {\n  const thumbnail = binding[RELATION_PROFILE_VARIABLES.THUMBNAIL_PROJECTION_VAR];\n  return {\n    iri: binding[RELATION_PROFILE_VARIABLES.CATEGORY_PROJECTION_VAR] as Rdf.Iri,\n    label: binding[RELATION_PROFILE_VARIABLES.LABEL_PROJECTION_VAR].value,\n    description: binding[RELATION_PROFILE_VARIABLES.DESCRIPTION_PROJECTION_VAR].value,\n    thumbnail: thumbnail ? thumbnail.value : undefined,\n    tuple: binding,\n  };\n}\n\ntype ProfilesRelations = Map<Rdf.Iri, Relations>;\nfunction constructRelations(bindings: SparqlClient.Bindings, categories: ProfilesCategories): ProfilesRelations {\n  const relationsByProfile = List(bindings).groupBy(\n    (binding) => binding[RELATION_PROFILE_VARIABLES.PROFILE_PROJECTION_VAR] as Rdf.Iri\n  );\n\n  return relationsByProfile\n    .map((profileBindings: List<SparqlClient.Binding>, profile: Rdf.Iri) =>\n      constructRelationsFromBindings(profileBindings, categories.get(profile) as Categories)\n    )\n    .toMap();\n}\n\nfunction constructRelationsFromBindings(bindings: List<SparqlClient.Binding>, categories: Categories): Relations {\n  return bindings\n    .map((binding) => constructRelationBromBinding(binding, categories))\n    .groupBy(({ iri, hasDomain, hasRange }) => RelationKey.key({ iri, domain: hasDomain.iri, range: hasRange.iri }))\n    .toOrderedMap()\n    .map((rs) => rs.first()) as Relations;\n}\n\nfunction constructRelationBromBinding(binding: SparqlClient.Binding, categories: Categories): Relation {\n  const iri = binding[RELATION_PROFILE_VARIABLES.RELATION_PROJECTION_VAR] as Rdf.Iri;\n  return {\n    iri: iri,\n    label: binding[RELATION_PROFILE_VARIABLES.LABEL_PROJECTION_VAR].value,\n    description: binding[RELATION_PROFILE_VARIABLES.DESCRIPTION_PROJECTION_VAR].value,\n    hasRange: categories.get(binding[RELATION_PROFILE_VARIABLES.RELATION_RANGE_PROJECTION_VAR] as Rdf.Iri),\n    hasDomain: categories.get(binding[RELATION_PROFILE_VARIABLES.RELATION_DOMAIN_PROJECTION_VAR] as Rdf.Iri),\n    tuple: binding,\n    hashCode: () => iri.hashCode(),\n    equals: (other: Relation) => iri.equals(other.iri),\n  };\n}\n\nfunction constructRelationsFromInline(inlineConfigs: Array<InlineRelation>, categories: Categories): Relations {\n  return List(inlineConfigs)\n    .map((inlineRelation) => constructRelationFromInline(inlineRelation, categories))\n    .groupBy(({ iri, hasDomain, hasRange }) => RelationKey.key({ iri, domain: hasDomain.iri, range: hasRange.iri }))\n    .toOrderedMap()\n    .map((rs) => rs.first()) as Relations;\n}\n\nfunction constructRelationFromInline(inlineConfig: InlineRelation, categories: Categories): Relation {\n  const iri = Rdf.fullIri(inlineConfig.iri);\n  return {\n    iri: iri,\n    label: inlineConfig.label,\n    description: inlineConfig.label,\n    hasDomain: categories.get(Rdf.fullIri(inlineConfig.hasDomain)),\n    hasRange: categories.get(Rdf.fullIri(inlineConfig.hasRange)),\n    tuple: { iri: Rdf.fullIri(inlineConfig.iri), label: Rdf.literal(inlineConfig.label) },\n    hashCode: () => iri.hashCode(),\n    equals: (other: Relation) => iri.equals(other.iri),\n  };\n}\n"],"sourceRoot":""}