{"version":3,"sources":["webpack:///./node_modules/rbush/index.js"],"names":["module","exports","rbush","quickselect","maxEntries","format","this","_maxEntries","Math","max","_minEntries","ceil","_initFormat","clear","findItem","item","items","equalsFn","indexOf","i","length","calcBBox","node","toBBox","distBBox","children","k","p","destNode","createNode","minX","Infinity","minY","maxX","maxY","child","extend","leaf","a","b","min","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains","intersects","height","multiSelect","arr","left","right","n","compare","mid","stack","pop","push","prototype","all","_all","data","search","bbox","result","len","childBBox","nodesToSearch","collides","load","insert","_build","slice","_splitRoot","tmpNode","_insert","remove","parent","index","goingUp","path","indexes","splice","_condense","compareMinX","compareMinY","toJSON","fromJSON","apply","N","M","log","pow","j","right2","right3","N2","N1","sqrt","_chooseSubtree","level","targetNode","area","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","m","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","compareArr","Function","join"],"mappings":"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","file":"npm.rbush-4f301373f72e04c01e7a.js","sourcesContent":["'use strict';\n\nmodule.exports = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from stratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n"],"sourceRoot":""}