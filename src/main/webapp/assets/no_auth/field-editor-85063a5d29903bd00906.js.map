{"version":3,"sources":["webpack:///./src/main/web/components/forms/field-editor/FieldEditorRow.ts","webpack:///./src/main/web/components/forms/field-editor/FieldEditorState.ts","webpack:///./src/main/web/components/forms/field-editor/TreePatternsEditor.tsx","webpack:///./src/main/web/components/forms/field-editor/Validation.ts","webpack:///./src/main/web/components/forms/field-editor/FieldEditorLabel.tsx","webpack:///./src/main/web/components/forms/field-editor/FieldEditorComponent.ts"],"names":["row","createFactory","Row","col","Col","CLASS_NAME","block","bem","toggle","expand","props","expanded","onExpand","onCollapse","componentDidMount","this","expandOnMount","componentWillReceiveProps","nextProps","render","label","error","children","element","canBeCollapsed","className","toString","md","onClick","D","span","i","message","style","display","undefined","createElement","Button","bsSize","Component","FieldEditorRow","ValidatedTreeConfig","sp","field","rdf","rdfs","xsd","VocabPlatform","asValue","value","wrap","config","type","schemePattern","relationPattern","rootsQuery","childrenQuery","parentsQuery","searchQuery","unwrap","createFieldDefinitionGraph","properties","id","description","domain","xsdDatatype","range","min","max","order","defaultValues","testSubject","selectPattern","insertPattern","deletePattern","askPattern","valueSetPattern","autosuggestionPattern","categories","treePatterns","triples","Array","baseIri","Rdf","iri","push","triple","Field","forEach","lbl","length","comment","literal","_string","bInsert","bnode","insert_pattern","Query","text","xsd_datatype","min_occurs","max_occurs","default_value","isEmpty","category","bSelect","select_pattern","bAsk","ask_pattern","bDelete","delete_pattern","bValueset","valueset_pattern","bAuto","autosuggestion_pattern","testsubject","treePatternsJson","JSON","stringify","tree_patterns","SyntheticJsonDatatype","graph","getFieldDefitionState","fieldIri","createValue","getFieldDefinitionProp","map","fieldDef","preferredLanguages","lang","language","sort","a","b","indexOf","isArray","isLoading","fromNullable","minOccurs","maxOccurs","defaults","unwrapState","state","fields","mapped","mapValues","v","getOrElse","langLiteral","fullConfigDefaults","createDefaultTreeQueries","changeConfigType","event","newConfig","currentTarget","onChange","checked","renderSimpleEditor","renderFullEditor","key","Boolean","changeConfig","DefaultLightweightPatterns","SparqlEditor","syntaxErrorCheck","query","e","renderFullQuery","queryKey","defaultValue","previous","update","TreePatternsEditor","collectTreeConfigErrors","errors","collectError","validateQuery","params","queryInfo","patterns","variables","projection","Error","collectQueryInfo","SparqlUtil","parseQuery","parsePatterns","queryType","allVariables","projectionVariables","hasCorrectType","projectionSet","Set","hasEveryVariable","every","has","hasEveryProjection","visitor","variableTerm","variable","name","substr","add","insertDelete","operation","updateType","QueryVisitor","sparqlQuery","SparqlTypeGuards","isStarProjection","isTerm","p","pattern","collectStateErrors","validateIri","N3","Util","isIRI","validateLabel","validateMin","num","Number","isInteger","validateMax","validateOrder","validateInsert","validateDelete","validateSelect","validateAsk","validateValueSet","validateAutosuggestion","validateTreeConfig","isRequired","langOptions","onChangeLabelValue","onChangeLabelLang","onDeleteLabel","FormGroup","InputGroup","FormControl","placeholder","newLabelValue","fontSize","options","clearable","opt","React","FieldEditorLabel","btn","ReactBootstrap","bsrow","bscol","input","textarea","select","context","renderEditor","empty","Just","nothing","Nothing","languages","find","isLabelAlreadyExists","disabled","addLabel","validatedLabel","Validation","updateState","div","index","renderLabel","isJust","updateValues","getFormValue","get","isEditMode","renderCopyToClipboardButton","title","generateIRI","classnames","rows","SemanticTreeInput","categoryQueries","initialSelection","multipleSelection","onSelectionChanged","selection","TreeSelection","leafs","node","toArray","renderMultipleValuesInput","values","addButtonLabel","showAddButton","onAdd","onDelete","splice","multi","vocabularies","LIST_TYPES","labelKey","valueKey","step","defaultsUpToMax","isMaxSet","parseInt","validated","isValid","onSaveOrUpdate","marginLeft","navigateTo","newValue","updateLabelValue","newLang","button","CopyToClipboardComponent","local","encodeURIComponent","Date","now","getFieldInstanceIriBase","fieldInstanceBaseIri","RegisteredPrefixes","finalGraph","tryCreateFinalGraph","isNothing","ldp","LdpService","FieldDefinitionContainer","addResource","flatMap","newResourceIri","resourceIri","navigateToResource","onValue","window","location","reload","categoryScheme","scheme","ConfigHolder","getUIConfig","observe","setState","Spinner","maxInt","slice","labels","oldGeneratedId","generateIriFromLabel","validatedValue","generatedId","target","validate","validatedValues","Object","keys","reduce","acc","newState","defaultProps","component","FieldEditorComponent","factory"],"mappings":"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","file":"field-editor-85063a5d29903bd00906.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { createFactory, createElement, Component, ReactNode } from 'react';\nimport * as D from 'react-dom-factories';\nimport { Row, Col, Button } from 'react-bootstrap';\nimport * as bem from 'bem-cn';\n\nconst row = createFactory(Row);\nconst col = createFactory(Col);\n\nexport const CLASS_NAME = 'field-editor';\nconst block = bem(CLASS_NAME);\n\ninterface Props {\n  expandOnMount?: boolean;\n  expanded: boolean;\n  onExpand?: () => void;\n  onCollapse?: () => void;\n  label: string;\n  error?: Error;\n  element?: ReactNode;\n}\n\nexport class FieldEditorRow extends Component<Props, {}> {\n  componentDidMount() {\n    if (this.props.expandOnMount) {\n      this.toggle({ expand: true });\n    }\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (!this.props.expandOnMount && nextProps.expandOnMount) {\n      // expand if row becomes non-collapsible\n      this.toggle({ expand: true });\n    }\n  }\n\n  render() {\n    const { onCollapse, expanded, label, error } = this.props;\n    const children = this.props.element || this.props.children;\n    const canBeCollapsed = expanded && onCollapse;\n    return row(\n      { className: block('row').toString() },\n      col({ md: 3, onClick: () => this.toggle({ expand: true }) }, D.span({}, label)),\n      col(\n        { md: canBeCollapsed ? 8 : 9 },\n        row(\n          {},\n          expanded\n            ? children\n            : D.i(\n                {\n                  className: block('expand').toString(),\n                  onClick: () => this.toggle({ expand: true }),\n                },\n                `Click to add an optional ${label}.`\n              )\n        ),\n        error ? row({ className: block('error').toString() }, error.message) : null\n      ),\n      col(\n        { md: 1, style: { display: canBeCollapsed ? undefined : 'none' } },\n        createElement(\n          Button,\n          {\n            className: block('collapse').toString(),\n            bsSize: 'sm',\n            onClick: () => this.toggle({ expand: false }),\n          },\n          D.span({ className: 'fa fa-times' })\n        )\n      )\n    );\n  }\n\n  private toggle = ({ expand }: { expand: boolean }) => {\n    if (this.props.expanded === expand) {\n      return;\n    }\n\n    if (expand && this.props.onExpand) {\n      this.props.onExpand();\n    } else if (!expand && this.props.onCollapse) {\n      this.props.onCollapse();\n    }\n  };\n}\n\nexport default createFactory(FieldEditorRow);\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\nimport { mapValues, isEmpty, forEach } from 'lodash';\nimport { fromNullable } from 'data.maybe';\n\nimport { ConfigHolder } from 'platform/api/services/config-holder';\nimport { getFieldDefinitionProp } from 'platform/api/services/ldp-field';\nimport { Rdf, vocabularies } from 'platform/api/rdf';\nconst { sp, field, rdf, rdfs, xsd, VocabPlatform } = vocabularies;\n\nimport { TreeQueriesConfig } from 'platform/components/forms';\nimport { ComplexTreePatterns } from 'platform/components/semantic/lazy-tree';\n\n/**\n * Component state interface as used by the {@FieldEditorComponent}\n */\nexport interface State {\n  id?: Data.Maybe<Value>;\n  label?: ReadonlyArray<LocalizedValue>;\n  description?: Data.Maybe<Value>;\n  categories?: ReadonlyArray<Rdf.Iri>;\n  domain?: ReadonlyArray<Value>;\n  xsdDatatype?: Data.Maybe<Value>;\n  range?: ReadonlyArray<Value>;\n  min?: Data.Maybe<Value>;\n  max?: Data.Maybe<Value>;\n  order?: Data.Maybe<Value>;\n  defaults?: ReadonlyArray<Value>;\n  testSubject?: Data.Maybe<Value>;\n\n  selectPattern?: Data.Maybe<Value>;\n  insertPattern?: Data.Maybe<Value>;\n  deletePattern?: Data.Maybe<Value>;\n  askPattern?: Data.Maybe<Value>;\n  valueSetPattern?: Data.Maybe<Value>;\n  autosuggestionPattern?: Data.Maybe<Value>;\n  treePatterns?: Data.Maybe<ValidatedTreeConfig>;\n\n  isLoading?: boolean;\n  isValid?: boolean;\n  categoryQueries?: ComplexTreePatterns;\n}\n\n/**\n * Representation of an value as being hold by the {@State} fields.\n * A valid value is a value object without error.\n * Nothing is represented explicitly using data.maybe.\n */\nexport interface Value {\n  value: string;\n  error?: Error;\n}\n\nexport interface LocalizedValue {\n  value: Value;\n  lang: string;\n}\n\nexport type ValidatedTreeConfig = ValidatedSimpleTreeConfig | ValidatedFullTreeConfig;\n\nexport interface ValidatedSimpleTreeConfig {\n  readonly type: 'simple';\n  readonly schemePattern?: Value;\n  readonly relationPattern?: Value;\n}\n\nexport interface ValidatedFullTreeConfig {\n  readonly type: 'full';\n  readonly rootsQuery?: Value;\n  readonly childrenQuery?: Value;\n  readonly parentsQuery?: Value;\n  readonly searchQuery?: Value;\n}\n\nexport namespace ValidatedTreeConfig {\n  export function wrap(config: TreeQueriesConfig): ValidatedTreeConfig {\n    if (config.type === 'simple') {\n      return {\n        type: 'simple',\n        schemePattern: asValue(config.schemePattern),\n        relationPattern: asValue(config.relationPattern),\n      };\n    } else {\n      return {\n        type: 'full',\n        rootsQuery: asValue(config.rootsQuery),\n        childrenQuery: asValue(config.childrenQuery),\n        parentsQuery: asValue(config.parentsQuery),\n        searchQuery: asValue(config.searchQuery),\n      };\n    }\n  }\n\n  function asValue(value: string | object | undefined): Value | undefined {\n    return typeof value === 'string' ? { value } : undefined;\n  }\n\n  export function unwrap(config: ValidatedTreeConfig): TreeQueriesConfig {\n    if (config.type === 'simple') {\n      const { schemePattern, relationPattern } = config;\n      return {\n        type: 'simple',\n        schemePattern: schemePattern ? schemePattern.value : undefined,\n        relationPattern: relationPattern ? relationPattern.value : undefined,\n      };\n    } else {\n      const { rootsQuery, childrenQuery, parentsQuery, searchQuery } = config;\n      return {\n        type: 'full',\n        rootsQuery: rootsQuery.value,\n        childrenQuery: childrenQuery.value,\n        parentsQuery: parentsQuery.value,\n        searchQuery: searchQuery.value,\n      };\n    }\n  }\n}\n\n/**\n * Transforms supplied attributes of a field definition into a graph\n * (i.e. collection of triples) as a RDF based serialization of the field definition.\n *\n * @param  {string} id - full IRI string of the field defintion identifier\n * @param  {string} label - label string\n * @param  {string} insert - SPARQL insertPattern string\n * @param  {string} description - description string\n * @param  {string} xsdtype - xsdDatatype full IRI string\n * @param  {string} min - minOccurs\n * @param  {string} max - maxOccurs\n * @param  {string} order - order\n * @param  {string} defaults - defaultValues\n * @param  {string} selectPattern - SPARQL selectPattern string\n * @param  {string} del - SPARQL deletePattern string\n * @param  {string} ask - SPARQL askPattern string\n * @param  {string} valueset - SPARQL valuesetPattern string\n * @param  {string} auto - SPARQL autosuggestionPattern string\n * @param  {string} subject - test subject full IRI string\n * @return {Graph}\n */\nexport function createFieldDefinitionGraph(properties: {\n  id: string;\n  label: ReadonlyArray<Rdf.Literal>;\n  description: string | undefined;\n  categories: ReadonlyArray<Rdf.Iri>;\n  domain: ReadonlyArray<string>;\n  xsdDatatype: string | undefined;\n  range: ReadonlyArray<string>;\n  min: string | undefined;\n  max: string | undefined;\n  order: string | undefined;\n  defaultValues: ReadonlyArray<string>;\n  selectPattern: string | undefined;\n  insertPattern: string;\n  deletePattern: string | undefined;\n  askPattern: string | undefined;\n  valueSetPattern: string | undefined;\n  autosuggestionPattern: string | undefined;\n  treePatterns: TreeQueriesConfig | undefined;\n  testSubject: string | undefined;\n}): Rdf.Graph {\n  const {\n    id,\n    label,\n    description,\n    domain,\n    xsdDatatype,\n    range,\n    min,\n    max,\n    order,\n    defaultValues,\n    testSubject,\n    selectPattern,\n    insertPattern,\n    deletePattern,\n    askPattern,\n    valueSetPattern,\n    autosuggestionPattern,\n    categories,\n    treePatterns,\n  } = properties;\n\n  const triples = new Array<Rdf.Triple>();\n  // empty IRI will be resolved in LDP later through baseIRI\n  const baseIri = Rdf.iri('');\n  /*\n   * create field, basic information\n   */\n  triples.push(Rdf.triple(baseIri, rdf.type, field.Field));\n  label.forEach((lbl) => triples.push(Rdf.triple(baseIri, rdfs.label, lbl)));\n  if (description && description.length > 0) {\n    triples.push(Rdf.triple(baseIri, rdfs.comment, Rdf.literal(description, xsd._string)));\n  }\n  /*\n   * adding triples for insert pattern\n   */\n  const bInsert = Rdf.bnode();\n  triples.push(Rdf.triple(baseIri, field.insert_pattern, bInsert));\n  triples.push(Rdf.triple(bInsert, rdf.type, sp.Query));\n  triples.push(Rdf.triple(bInsert, sp.text, Rdf.literal(insertPattern, xsd._string)));\n  for (const value of domain) {\n    triples.push(Rdf.triple(baseIri, field.domain, Rdf.iri(value)));\n  }\n  if (xsdDatatype) {\n    triples.push(Rdf.triple(baseIri, field.xsd_datatype, Rdf.iri(xsdDatatype)));\n  }\n  for (const value of range) {\n    triples.push(Rdf.triple(baseIri, field.range, Rdf.iri(value)));\n  }\n  if (min) {\n    triples.push(Rdf.triple(baseIri, field.min_occurs, Rdf.literal(min, xsd._string)));\n  }\n  if (max) {\n    triples.push(Rdf.triple(baseIri, field.max_occurs, Rdf.literal(max, xsd._string)));\n  }\n  if (order) {\n    triples.push(Rdf.triple(baseIri, field.order, Rdf.literal(order, xsd._string)));\n  }\n  for (const value of defaultValues) {\n    triples.push(Rdf.triple(baseIri, field.default_value, Rdf.literal(value, xsd._string)));\n  }\n  if (categories && !isEmpty(categories)) {\n    forEach(categories, (category) => triples.push(Rdf.triple(baseIri, field.category, category)));\n  }\n  if (selectPattern && selectPattern.length > 0) {\n    const bSelect = Rdf.bnode();\n    triples.push(Rdf.triple(baseIri, field.select_pattern, bSelect));\n    triples.push(Rdf.triple(bSelect, rdf.type, sp.Query));\n    triples.push(Rdf.triple(bSelect, sp.text, Rdf.literal(selectPattern, xsd._string)));\n  }\n  if (askPattern && askPattern.length > 0) {\n    const bAsk = Rdf.bnode();\n    triples.push(Rdf.triple(baseIri, field.ask_pattern, bAsk));\n    triples.push(Rdf.triple(bAsk, rdf.type, sp.Query));\n    triples.push(Rdf.triple(bAsk, sp.text, Rdf.literal(askPattern, xsd._string)));\n  }\n  if (deletePattern && deletePattern.length > 0) {\n    const bDelete = Rdf.bnode();\n    triples.push(Rdf.triple(baseIri, field.delete_pattern, bDelete));\n    triples.push(Rdf.triple(bDelete, rdf.type, sp.Query));\n    triples.push(Rdf.triple(bDelete, sp.text, Rdf.literal(deletePattern, xsd._string)));\n  }\n  if (valueSetPattern && valueSetPattern.length > 0) {\n    const bValueset = Rdf.bnode();\n    triples.push(Rdf.triple(baseIri, field.valueset_pattern, bValueset));\n    triples.push(Rdf.triple(bValueset, rdf.type, sp.Query));\n    triples.push(Rdf.triple(bValueset, sp.text, Rdf.literal(valueSetPattern, xsd._string)));\n  }\n  if (autosuggestionPattern && autosuggestionPattern.length > 0) {\n    const bAuto = Rdf.bnode();\n    triples.push(Rdf.triple(baseIri, field.autosuggestion_pattern, bAuto));\n    triples.push(Rdf.triple(bAuto, rdf.type, sp.Query));\n    triples.push(Rdf.triple(bAuto, sp.text, Rdf.literal(autosuggestionPattern, xsd._string)));\n  }\n  if (testSubject) {\n    triples.push(Rdf.triple(baseIri, field.testsubject, Rdf.iri(testSubject)));\n  }\n  if (treePatterns) {\n    const treePatternsJson = JSON.stringify(treePatterns, null, 2);\n    triples.push(\n      Rdf.triple(baseIri, field.tree_patterns, Rdf.literal(treePatternsJson, VocabPlatform.SyntheticJsonDatatype))\n    );\n  }\n\n  return Rdf.graph(triples);\n}\n/**\n * De-serialized the supplied field definition graph into an state object for\n * the {@FieldEditorComponent}\n * @param  {Iri}   fieldIri IRI of the field definition\n * @param  {Graph} graph    Graph i.e. collection of statements with all field definition attributes\n * @return {State}\n */\nexport function getFieldDefitionState(fieldIri: Rdf.Iri): Kefir.Property<State> {\n  // shortcut function to convert a string to value object\n  const createValue = (value: string): Value => {\n    return { value: value };\n  };\n\n  return getFieldDefinitionProp(fieldIri).map(\n    (fieldDef): State => {\n      const { preferredLanguages } = ConfigHolder.getUIConfig();\n      const label: Array<LocalizedValue> = [];\n      if (fieldDef.label !== undefined) {\n        if (typeof fieldDef.label === 'string') {\n          label.push({ value: createValue(fieldDef.label), lang: '' });\n        } else {\n          fieldDef.label.forEach(({ value, language }) => label.push({ value: createValue(value), lang: language }));\n        }\n      }\n      label.sort((a, b) => {\n        const indexA = preferredLanguages.indexOf(a.lang);\n        const indexB = preferredLanguages.indexOf(b.lang);\n        return indexA - indexB;\n      });\n\n      let domain: ReadonlyArray<Value> = [];\n      let range: ReadonlyArray<Value> = [];\n\n      if (typeof fieldDef.domain === 'string') {\n        domain = [createValue(fieldDef.domain)];\n      } else if (Array.isArray(fieldDef.domain)) {\n        domain = fieldDef.domain.map(createValue) as ReadonlyArray<Value>;\n      }\n\n      if (typeof fieldDef.range === 'string') {\n        range = [createValue(fieldDef.range)];\n      } else if (Array.isArray(fieldDef.range)) {\n        range = fieldDef.range.map(createValue) as ReadonlyArray<Value>;\n      }\n      return {\n        isLoading: false,\n        id: fromNullable(fieldIri.value).map(createValue),\n        label,\n        description: fromNullable(fieldDef.description).map(createValue),\n        categories: fieldDef.categories as ReadonlyArray<Rdf.Iri>,\n        domain,\n        xsdDatatype: fromNullable(fieldDef.xsdDatatype).map(createValue),\n        range,\n        min: fromNullable(fieldDef.minOccurs as string).map(createValue),\n        max: fromNullable(fieldDef.maxOccurs as string).map(createValue),\n        order: fromNullable(fieldDef.order as string).map(createValue),\n        defaults: fieldDef.defaultValues.map(createValue) as ReadonlyArray<Value>,\n        testSubject: fromNullable(fieldDef.testSubject).map(createValue),\n        insertPattern: fromNullable(fieldDef.insertPattern).map(createValue),\n        selectPattern: fromNullable(fieldDef.selectPattern).map(createValue),\n        askPattern: fromNullable(fieldDef.askPattern).map(createValue),\n        deletePattern: fromNullable(fieldDef.deletePattern).map(createValue),\n        valueSetPattern: fromNullable(fieldDef.valueSetPattern).map(createValue),\n        autosuggestionPattern: fromNullable(fieldDef.autosuggestionPattern).map(createValue),\n        treePatterns: fromNullable(fieldDef.treePatterns).map(ValidatedTreeConfig.wrap),\n      };\n    }\n  );\n}\n\nexport function unwrapState(state: State) {\n  const {\n    id,\n    label,\n    description,\n    categories,\n    domain,\n    xsdDatatype,\n    range,\n    min,\n    max,\n    order,\n    defaults,\n    testSubject,\n    selectPattern,\n    insertPattern,\n    deletePattern,\n    askPattern,\n    valueSetPattern,\n    autosuggestionPattern,\n    treePatterns,\n  } = state;\n  const fields = {\n    id,\n    description,\n    xsdDatatype,\n    min,\n    max,\n    order,\n    testSubject,\n    selectPattern,\n    insertPattern,\n    deletePattern,\n    askPattern,\n    valueSetPattern,\n    autosuggestionPattern,\n  };\n  type Unwrapped = { [K in keyof typeof fields]: string | undefined } & {\n    label: ReadonlyArray<Rdf.Literal>;\n    categories: ReadonlyArray<Rdf.Iri>;\n    domain: ReadonlyArray<string>;\n    range: ReadonlyArray<string>;\n    defaultValues: ReadonlyArray<string>;\n    treePatterns: TreeQueriesConfig;\n  };\n  const mapped = mapValues(fields, (value) => value.map((v) => v.value).getOrElse(undefined)) as unknown as Unwrapped;\n  mapped.label = label.map(({ value, lang }) =>\n    lang.length ? Rdf.langLiteral(value.value, lang) : Rdf.literal(value.value)\n  );\n  mapped.categories = categories;\n  mapped.domain = domain.map((v) => v.value);\n  mapped.range = range.map((v) => v.value);\n  mapped.defaultValues = defaults.map((v) => v.value);\n  mapped.treePatterns = treePatterns.map(ValidatedTreeConfig.unwrap).getOrElse(undefined);\n  return mapped;\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport * as React from 'react';\nimport { Component, FormEvent } from 'react';\n\nimport { SparqlEditor } from 'platform/components/sparql-editor';\nimport { DefaultLightweightPatterns, createDefaultTreeQueries } from 'platform/components/semantic/lazy-tree';\n\nimport { FieldEditorRow } from './FieldEditorRow';\nimport { ValidatedTreeConfig, ValidatedSimpleTreeConfig, ValidatedFullTreeConfig } from './FieldEditorState';\n\nexport interface TreePatternsEditorProps {\n  config: ValidatedTreeConfig;\n  onChange: (config: ValidatedTreeConfig) => void;\n}\n\nconst CLASS_NAME = 'tree-patterns-editor';\n\nexport class TreePatternsEditor extends Component<TreePatternsEditorProps, {}> {\n  private readonly fullConfigDefaults = createDefaultTreeQueries();\n\n  render() {\n    const { config } = this.props;\n    const typeSwitchClass = `${CLASS_NAME}__type-switch`;\n    return (\n      <div className={CLASS_NAME}>\n        <FieldEditorRow label=\"type\" expanded={true}>\n          <label className={typeSwitchClass}>\n            <input type=\"radio\" value=\"simple\" checked={config.type === 'simple'} onChange={this.changeConfigType} />{' '}\n            Simple\n          </label>\n          <label className={typeSwitchClass}>\n            <input type=\"radio\" value=\"full\" checked={config.type === 'full'} onChange={this.changeConfigType} /> Full\n          </label>\n        </FieldEditorRow>\n        {config.type === 'simple' ? this.renderSimpleEditor(config) : this.renderFullEditor(config)}\n      </div>\n    );\n  }\n\n  private changeConfigType = (event: FormEvent<HTMLInputElement>) => {\n    const type = event.currentTarget.value as ValidatedTreeConfig['type'];\n\n    let newConfig: ValidatedTreeConfig;\n    if (type === 'simple') {\n      newConfig = { type };\n    } else {\n      const { rootsQuery, childrenQuery, parentsQuery, searchQuery } = createDefaultTreeQueries();\n      newConfig = {\n        type: 'full',\n        rootsQuery: { value: rootsQuery },\n        childrenQuery: { value: childrenQuery },\n        parentsQuery: { value: parentsQuery },\n        searchQuery: { value: searchQuery },\n      };\n    }\n\n    this.props.onChange(newConfig);\n  };\n\n  renderSimpleEditor(config: ValidatedSimpleTreeConfig) {\n    return (\n      <div key=\"simple\" className={`${CLASS_NAME}__simple-config`}>\n        <FieldEditorRow\n          label=\"scheme pattern\"\n          expanded={Boolean(config.schemePattern)}\n          onExpand={() =>\n            this.changeConfig(config, {\n              schemePattern: { value: DefaultLightweightPatterns.schemePattern },\n            })\n          }\n          onCollapse={() => this.changeConfig(config, { schemePattern: undefined })}\n          error={config.schemePattern ? config.schemePattern.error : undefined}\n        >\n          <SparqlEditor\n            syntaxErrorCheck={false}\n            query={config.schemePattern ? config.schemePattern.value : ''}\n            onChange={(e) => this.changeConfig(config, { schemePattern: { value: e.value } })}\n          />\n        </FieldEditorRow>\n        <FieldEditorRow\n          label=\"relation pattern\"\n          expanded={Boolean(config.relationPattern)}\n          onExpand={() =>\n            this.changeConfig(config, {\n              relationPattern: { value: DefaultLightweightPatterns.relationPattern },\n            })\n          }\n          onCollapse={() => this.changeConfig(config, { relationPattern: undefined })}\n          error={config.relationPattern ? config.relationPattern.error : undefined}\n        >\n          <SparqlEditor\n            syntaxErrorCheck={false}\n            query={config.relationPattern ? config.relationPattern.value : ''}\n            onChange={(e) => this.changeConfig(config, { relationPattern: { value: e.value } })}\n          />\n        </FieldEditorRow>\n      </div>\n    );\n  }\n\n  renderFullEditor(config: ValidatedFullTreeConfig) {\n    return (\n      <div key=\"full\" className={`${CLASS_NAME}__full-config`}>\n        {this.renderFullQuery(config, 'rootsQuery', 'roots query')}\n        {this.renderFullQuery(config, 'childrenQuery', 'children query')}\n        {this.renderFullQuery(config, 'parentsQuery', 'parents query')}\n        {this.renderFullQuery(config, 'searchQuery', 'search query')}\n      </div>\n    );\n  }\n\n  private renderFullQuery(\n    config: ValidatedFullTreeConfig,\n    queryKey: 'rootsQuery' | 'childrenQuery' | 'parentsQuery' | 'searchQuery',\n    label: string\n  ) {\n    const query = config[queryKey];\n    const defaultValue = this.fullConfigDefaults[queryKey];\n    return (\n      <FieldEditorRow\n        label={label}\n        expanded={Boolean(query)}\n        expandOnMount={true}\n        onExpand={() => this.changeConfig(config, { [queryKey]: { value: defaultValue } })}\n        error={query ? query.error : undefined}\n      >\n        <SparqlEditor\n          syntaxErrorCheck={false}\n          query={query ? query.value : undefined}\n          onChange={(e) => this.changeConfig(config, { [queryKey]: { value: e.value } })}\n        />\n      </FieldEditorRow>\n    );\n  }\n\n  private changeConfig(previous: ValidatedSimpleTreeConfig, update: Partial<ValidatedSimpleTreeConfig>): void;\n  private changeConfig(previous: ValidatedFullTreeConfig, update: Partial<ValidatedFullTreeConfig>): void;\n  private changeConfig(previous: any, update: Partial<any>) {\n    this.props.onChange({ ...previous, ...update });\n  }\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as N3 from 'n3';\nimport * as SparqlJs from 'sparqljs';\n\nimport { SparqlUtil, QueryVisitor, SparqlTypeGuards } from 'platform/api/sparql';\n\nimport {\n  Value,\n  ValidatedTreeConfig,\n  ValidatedSimpleTreeConfig,\n  ValidatedFullTreeConfig,\n  State,\n} from './FieldEditorState';\n\nexport function collectStateErrors(state: State): Error[] {\n  const errors: Error[] = [];\n  const collectError = (value: Value) => {\n    if (value.error) {\n      errors.push(value.error);\n    }\n  };\n\n  const values = [\n    state.id,\n    state.description,\n    state.xsdDatatype,\n    state.min,\n    state.max,\n    state.order,\n    state.testSubject,\n    state.selectPattern,\n    state.insertPattern,\n    state.deletePattern,\n    state.askPattern,\n    state.valueSetPattern,\n    state.autosuggestionPattern,\n  ];\n  for (const value of values) {\n    value.map(collectError);\n  }\n\n  state.label.forEach(({ value }) => collectError(value));\n  state.domain.forEach(collectError);\n  state.range.forEach(collectError);\n  state.defaults.forEach(collectError);\n  state.treePatterns.map(collectTreeConfigErrors);\n  return errors;\n}\n\nexport function collectTreeConfigErrors(config: ValidatedTreeConfig): Error[] {\n  const errors: Error[] = [];\n  const collectError = (value: Value | undefined) => {\n    if (value && value.error) {\n      errors.push(value.error);\n    }\n  };\n\n  if (config.type === 'simple') {\n    collectError(config.schemePattern);\n    collectError(config.relationPattern);\n  } else {\n    collectError(config.rootsQuery);\n    collectError(config.childrenQuery);\n    collectError(config.parentsQuery);\n    collectError(config.searchQuery);\n  }\n\n  return errors;\n}\n\n/**\n * Returns a valid IRI value observable if supplied value is valid IRI string,\n * an error observable otherwise.\n */\nexport function validateIri(v: string): Value {\n  if (!N3.Util.isIRI(v)) {\n    return {\n      value: v,\n      error: new Error('Identifier must be a valid full IRI string.'),\n    };\n  }\n  return { value: v };\n}\n\n/**\n * Returns a valid value (SPARQL select) string if supplied queryString is a valid\n * SPARQL SELECT query and fulfills all constraints e.g. has at least ?value ?subject\n * projection variable.\n * Returns an error observable otherwise.\n */\nexport function validateLabel(v: string): Value {\n  if (v.length > 0) {\n    return { value: v };\n  }\n  return {\n    value: v,\n    error: new Error('Label should be meaningful and have at least one character.'),\n  };\n}\n\n/**\n * Returns a valid min value observable if value is >= 0, an error observable otherwise.\n */\nexport function validateMin(v: string): Value {\n  const num = Number(v);\n  if (Number.isInteger(num) && num >= 0) {\n    return { value: v };\n  } else {\n    return {\n      value: v,\n      error: new Error('Min. Cardinality must be >= 0'),\n    };\n  }\n}\n\n/**\n * Returns a valid max observable value if value is >=1 or unbound, an error observable otherwise.\n */\nexport function validateMax(v: string): Value {\n  const num = Number(v);\n  if (v === 'unbound' || (Number.isInteger(num) && num >= 1)) {\n    return { value: v };\n  } else {\n    return {\n      value: v,\n      error: new Error('Max. Cardinality must be >= 1 or unbound'),\n    };\n  }\n}\n\n/**\n * Returns a valid order observable value if value is >= 0 or unbound,\n * an error observable otherwise.\n */\nexport function validateOrder(v: string): Value {\n  const num = Number(v);\n  if (Number.isInteger(num) && num >= 0) {\n    return { value: v };\n  } else {\n    return {\n      value: v,\n      error: new Error('Order must be >= 0'),\n    };\n  }\n}\n/**\n * Returns a valid value (SPARQL insert) observable if supplied queryString is a valid\n * SPARQL INSERT query and fulfills all constraints e.g. containing ?value ?subject.\n * Returns an error observable otherwise.\n */\nexport function validateInsert(query: string): Value {\n  const error =\n    `Insert pattern must be a valid SPARQL UPDATE INSERT query ` + `and must have a $subject and $value variable.`;\n  return validateQuery({ query, type: 'insertdelete', variables: ['subject', 'value'], error });\n}\n\n/**\n * Returns a valid value  (SPARQL delete) observable if supplied queryString is a valid\n * SPARQL DELETE query and fulfills all constraints e.g. containing ?value ?subject.\n * Returns an error observable otherwise.\n */\nexport function validateDelete(query: string): Value {\n  const error =\n    `Delete pattern must be a valid SPARQL UPDATE DELETE query ` + `and must have a $subject and $value variable.`;\n  return validateQuery({ query, type: 'insertdelete', variables: ['subject', 'value'], error });\n}\n\n/**\n * Returns a valid value (SPARQL select) observable if supplied queryString is a valid\n * SPARQL SELECT query and fulfills all constraints e.g. containing ?value ?subject.\n * Returns an error observable otherwise.\n */\nexport function validateSelect(query: string): Value {\n  return validateQuery({\n    query,\n    type: 'SELECT',\n    variables: ['subject', 'value'],\n    projection: ['value'],\n    error:\n      `Select pattern must be a valid SPARQL SELECT query, ` +\n      `must have a $subject and $value variable ` +\n      `and must expose a ?value projection variable.`,\n  });\n}\n\n/**\n * Returns a valid value (SPARQL ask) observable if supplied queryString is a valid\n * SPARQL ask query and fulfills all constraints.\n * Returns an error observable otherwise.\n */\nexport function validateAsk(query: string): Value {\n  const error = `Ask validation pattern must be a valid SPARQL ASK query.`;\n  return validateQuery({ query, type: 'ASK', error });\n}\n\n/**\n * Returns a valid value (SPARQL select) observable if supplied queryString is a valid\n * SPARQL SELECT query and fulfills all constraints e.g. has at least ?value ?subject\n * projection variable.\n * Returns an error observable otherwise.\n */\nexport function validateValueSet(query: string): Value {\n  const error =\n    `Select valueset pattern must be a valid SPARQL SELECT query ` + `and must expose a ?value projection variable.`;\n  return validateQuery({ query, type: 'SELECT', projection: ['value'], error });\n}\n\n/**\n * Returns a valid value (SPARQL select) observable if supplied queryString is a valid\n * SPARQL SELECT query and fulfills all constraints e.g. has at least ?value ?subject\n * projection variable.\n * Returns an error observable otherwise.\n */\nexport function validateAutosuggestion(query: string): Value {\n  const error =\n    `Select autosuggestion pattern must be a valid SPARQL SELECT query ` +\n    `and must expose a ?value and ?label projection variable.`;\n  // TODO check also on existence of ?token, needs to be done with string contains\n  // const containsToken = queryString.indexOf('\"?token\"')  !== -1;\n  return validateQuery({ query, type: 'SELECT', projection: ['value', 'label'], error });\n}\n\nexport function validateTreeConfig(config: ValidatedTreeConfig): ValidatedTreeConfig {\n  if (config.type === 'simple') {\n    const result: ValidatedSimpleTreeConfig = {\n      type: 'simple',\n      schemePattern: config.schemePattern\n        ? validateQuery({\n            patterns: config.schemePattern.value,\n            variables: ['item'],\n            error: 'Tree scheme pattern must be a valid SPARQL pattern ' + 'and must expose an ?item variable.',\n          })\n        : undefined,\n      relationPattern: config.relationPattern\n        ? validateQuery({\n            patterns: config.relationPattern.value,\n            variables: ['item', 'parent'],\n            error:\n              'Tree relation pattern must be a valid SPARQL pattern ' +\n              'and must expose an ?item and ?parent variables.',\n          })\n        : undefined,\n    };\n    return result;\n  } else {\n    const result: ValidatedFullTreeConfig = {\n      type: 'full',\n      rootsQuery: validateQuery({\n        query: config.rootsQuery ? config.rootsQuery.value : undefined,\n        type: 'SELECT',\n        projection: ['item', 'label', 'hasChildren'],\n        error:\n          'Tree roots pattern must be a valid SPARQL SELECT query ' +\n          'and must expose a ?item, ?label and ?hasChildren projection variables.',\n      }),\n      childrenQuery: validateQuery({\n        query: config.childrenQuery ? config.childrenQuery.value : undefined,\n        type: 'SELECT',\n        variables: ['parent'],\n        projection: ['item', 'label', 'hasChildren'],\n        error:\n          'Tree children pattern must be a valid SPARQL SELECT query, ' +\n          'must have a ?parent variable ' +\n          'and must expose a ?item, ?label and ?hasChildren projection variables.',\n      }),\n      parentsQuery: validateQuery({\n        query: config.parentsQuery ? config.parentsQuery.value : undefined,\n        type: 'SELECT',\n        projection: ['item', 'parent', 'parentLabel'],\n        error:\n          'Tree parents pattern must be a valid SPARQL SELECT query ' +\n          'and must expose a ?item, ?parent and ?parentLabel projection variables.',\n      }),\n      searchQuery: validateQuery({\n        query: config.searchQuery ? config.searchQuery.value : undefined,\n        type: 'SELECT',\n        projection: ['item', 'score', 'label', 'hasChildren'],\n        error:\n          'Tree search pattern must be a valid SPARQL SELECT query ' +\n          'and must expose a ?item, ?score, ?label and ?hasChildren projection variables.',\n      }),\n    };\n    return result;\n  }\n}\n\ninterface ValidateQueryParams {\n  query?: string;\n  patterns?: string;\n  type?: SparqlJs.Query['queryType'] | SparqlJs.InsertDeleteOperation['updateType'];\n  variables?: ReadonlyArray<string>;\n  projection?: ReadonlyArray<string>;\n  error: string;\n}\n\nfunction validateQuery(params: ValidateQueryParams): Value {\n  const { query, patterns, type, variables = [], projection = [], error } = params;\n\n  if (typeof query !== 'string' && typeof patterns !== 'string') {\n    return { value: '', error: new Error(error) };\n  }\n\n  let value: string;\n  let queryInfo: QueryInfo;\n  try {\n    if (query) {\n      value = query;\n      const parsedQuery = SparqlUtil.parseQuery(query);\n      queryInfo = collectQueryInfo({ query: parsedQuery });\n    } else if (patterns) {\n      value = patterns;\n      const parsedPatterns = SparqlUtil.parsePatterns(patterns);\n      queryInfo = collectQueryInfo({ patterns: parsedPatterns });\n    }\n  } catch (e) {\n    return { value, error: e };\n  }\n\n  const { queryType, allVariables, projectionVariables } = queryInfo;\n  const hasCorrectType = !type || queryType === type;\n  const projectionSet = new Set(projectionVariables);\n  const hasEveryVariable = variables.every((v) => allVariables.has(v));\n  const hasEveryProjection = projection.every((v) => projectionSet.has(v));\n\n  if (hasCorrectType && hasEveryVariable && hasEveryProjection) {\n    return { value };\n  } else {\n    return { value, error: new Error(error) };\n  }\n}\n\nexport interface QueryInfo {\n  queryType: string;\n  allVariables: Set<string>;\n  projectionVariables: string[];\n}\n\n/**\n * Traverses the query AST of the specified {@SparqlJs.SparqlQuery} and\n * collects information into a {@QueryInfo} object including information on the\n * query type and whether certain variables exist.\n *\n * In addition we collect extract information of which projection variables are being used.\n */\nexport function collectQueryInfo(params: { query?: SparqlJs.SparqlQuery; patterns?: SparqlJs.Pattern[] }): QueryInfo {\n  const visitor = new (class extends QueryVisitor {\n    allVariables = new Set<string>();\n    queryType: string;\n\n    variableTerm(variable: SparqlJs.Term) {\n      const name = variable.substr(1);\n      this.allVariables.add(name);\n      return super.variableTerm(variable);\n    }\n\n    query(query: SparqlJs.Query): SparqlJs.Query {\n      this.queryType = query.queryType;\n      return super.query(query);\n    }\n\n    insertDelete(operation: SparqlJs.InsertDeleteOperation) {\n      this.queryType = operation.updateType;\n      return super.insertDelete(operation);\n    }\n  })();\n\n  const { query, patterns } = params;\n  let projectionVariables: string[] = [];\n\n  if (query) {\n    visitor.sparqlQuery(query);\n    if (query.type === 'query' && query.queryType === 'SELECT' && !SparqlTypeGuards.isStarProjection(query.variables)) {\n      projectionVariables = query.variables.map((v) =>\n        SparqlTypeGuards.isTerm(v) ? v.substr(1) : v.variable.substr(1)\n      );\n    }\n  } else if (patterns) {\n    patterns.forEach((p) => visitor.pattern(p));\n  }\n\n  return {\n    queryType: visitor.queryType,\n    allVariables: visitor.allVariables,\n    projectionVariables: projectionVariables,\n  };\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport * as React from 'react';\nimport { FormGroup, InputGroup, FormControl, Button, Row, Col } from 'react-bootstrap';\nimport ReactSelect from 'react-select';\n\nimport { LocalizedValue } from './FieldEditorState';\n\nexport interface Props {\n  label: LocalizedValue;\n  isRequired: boolean;\n  langOptions: Array<{ value: string; label: string; disabled: boolean }>;\n  onChangeLabelValue: (value: string) => void;\n  onChangeLabelLang: (lang: string) => void;\n  onDeleteLabel: () => void;\n}\n\nexport class FieldEditorLabel extends React.Component<Props, {}> {\n  render() {\n    const { label, isRequired, langOptions, onChangeLabelValue, onChangeLabelLang, onDeleteLabel } = this.props;\n    const { value, lang } = label;\n    return (\n      <FormGroup>\n        <InputGroup>\n          <FormControl\n            placeholder=\"Label\"\n            value={value.value}\n            onChange={(e) => {\n              const { value: newLabelValue } = e.target as HTMLInputElement;\n              onChangeLabelValue(newLabelValue);\n            }}\n          />\n          <div className=\"input-group-btn\" style={{ fontSize: 'inherit', display: 'flex' }}>\n            <div className=\"field-editor__lang-selector-holder\">\n              <ReactSelect\n                value={lang}\n                options={langOptions}\n                clearable={false}\n                onChange={(opt: { value: string }) => onChangeLabelLang(opt.value)}\n              />\n            </div>\n            {!isRequired ? (\n              <Button className=\"field-editor__delete-label-button\" onClick={() => onDeleteLabel()}>\n                <i className=\"fa fa-times\" />\n              </Button>\n            ) : null}\n          </div>\n        </InputGroup>\n        {value.error ? (\n          <Row className=\"field-editor__error\">\n            <Col md={12}>{value.error.message}</Col>\n          </Row>\n        ) : null}\n      </FormGroup>\n    );\n  }\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { createFactory, createElement, MouseEvent, FormEvent, ChangeEvent } from 'react';\nimport * as D from 'react-dom-factories';\n\nimport * as bem from 'bem-cn';\nimport * as ReactBootstrap from 'react-bootstrap';\nimport ReactSelectComponent from 'react-select';\nimport TextareaAutosize from 'react-textarea-autosize';\nimport { Just, Nothing } from 'data.maybe';\nimport * as classnames from 'classnames';\n\nimport { Component } from 'platform/api/components';\nimport { Rdf, vocabularies } from 'platform/api/rdf';\nimport { SparqlUtil } from 'platform/api/sparql';\nimport { navigateToResource } from 'platform/api/navigation';\nimport { LdpService } from 'platform/api/services/ldp';\nimport { ConfigHolder } from 'platform/api/services/config-holder';\n\nimport { SparqlEditor } from 'platform/components/sparql-editor';\nimport {\n  SemanticTreeInput,\n  SemanticTreeInputProps,\n  TreeSelection,\n  createDefaultTreeQueries,\n} from 'platform/components/semantic/lazy-tree';\nimport { Spinner } from 'platform/components/ui/spinner';\nimport { CopyToClipboardComponent } from 'platform/components/copy-to-clipboard';\n\nimport row from './FieldEditorRow';\nimport {\n  State,\n  Value,\n  LocalizedValue,\n  getFieldDefitionState,\n  createFieldDefinitionGraph,\n  unwrapState,\n  ValidatedTreeConfig,\n} from './FieldEditorState';\nimport { TreePatternsEditor } from './TreePatternsEditor';\nimport * as Validation from './Validation';\nimport { FieldEditorLabel } from './FieldEditorLabel';\n\nimport './field-editor.scss';\n\nconst btn = createFactory(ReactBootstrap.Button);\nconst bsrow = createFactory(ReactBootstrap.Row);\nconst bscol = createFactory(ReactBootstrap.Col);\nconst input = createFactory(ReactBootstrap.FormControl);\nconst textarea = createFactory(TextareaAutosize);\nconst select = createFactory(ReactSelectComponent);\n\nconst FIELD_DEF_INSTANCE_BASE = 'http://www.researchspace.org/fieldDefinition/';\nconst CLASS_NAME = 'field-editor';\nconst block = bem(CLASS_NAME);\n\ninterface Props {\n  /**\n   * IRI of the field definition to be edited.\n   */\n  fieldIri?: string;\n  /**\n   * Optional string to make the base IRI being used\n   * for creating new field definitions configurable\n   */\n  fieldInstanceBaseIri?: string;\n  /**\n   * Full IRI enclosed in <> or prefixed IRI\n   */\n  categoryScheme?: string;\n  /**\n   * URI to navigate after saving/updating a field.\n   */\n  navigateTo?: string;\n}\n\n/* Default queries to be set on the SPARQL input elements as placeholders */\nconst DEFAULT_INSERT = 'INSERT { $subject ?predicate $value} WHERE {}';\nconst DEFAULT_SELECT = `SELECT ?value ?label WHERE {\n  $subject ?predicate ?value.\n  ?value rdfs:label ?label.\n}`;\nconst DEFAULT_DELETE = 'DELETE { $subject ?predicate $value} WHERE {}';\nconst DEFAULT_ASK = 'ASK {}';\nconst DEFAULT_VALUE_SET = `SELECT ?value ?label WHERE {\n  ?value a ?anyType ;\n    rdfs:label ?label .\n}`;\nconst DEFAULT_AUTOSUGGESTION = `SELECT ?value ?label WHERE {\n  ?value a ?anyType ;\n    rdfs:label ?label .\n  FILTER REGEX(STR(?label), \"?token\")\n} LIMIT 10`;\n\nclass FieldEditorComponent extends Component<Props, State> {\n  static readonly defaultProps: Partial<Props> = {\n    categoryScheme: '<http://www.researchspace.org/resource/system/FieldCategories>',\n    navigateTo: 'http://www.researchspace.org/resource/assets/Fields',\n  };\n  private readonly languages: ReadonlyArray<string>;\n\n  constructor(props: Props, context: any) {\n    super(props, context);\n    const [categoryScheme] = SparqlUtil.resolveIris([this.props.categoryScheme]);\n    const categoryQueries = createDefaultTreeQueries({ scheme: categoryScheme.value });\n    this.languages = ConfigHolder.getUIConfig().preferredLanguages;\n\n    this.state = {\n      id: Nothing<Value>(),\n      label: [] as LocalizedValue[],\n      description: Nothing<Value>(),\n      categories: [],\n      domain: [] as Value[],\n      xsdDatatype: Nothing<Value>(),\n      range: [] as Value[],\n      min: Nothing<Value>(),\n      max: Nothing<Value>(),\n      order: Nothing<Value>(),\n      defaults: [] as Value[],\n      testSubject: Nothing<Value>(),\n      insertPattern: Nothing<Value>(),\n      selectPattern: Nothing<Value>(),\n      deletePattern: Nothing<Value>(),\n      askPattern: Nothing<Value>(),\n      valueSetPattern: Nothing<Value>(),\n      autosuggestionPattern: Nothing<Value>(),\n      treePatterns: Nothing<ValidatedTreeConfig>(),\n\n      isLoading: this.isEditMode(),\n      isValid: false,\n      categoryQueries,\n    };\n  }\n\n  public componentDidMount() {\n    // only if in edit mode, we try to fetch an existing\n    // field definition (as identified by the provided fieldIri\n    // from backend and de-serialize it back to the component state.\n    if (this.isEditMode()) {\n      const fieldIri = Rdf.iri(this.props.fieldIri);\n      getFieldDefitionState(fieldIri).observe({\n        value: (state) => this.setState(state),\n      });\n    }\n  }\n\n  public render() {\n    return D.div(\n      { className: block('').toString() },\n      this.state.isLoading ? createElement(Spinner) : this.renderEditor()\n    );\n  }\n\n  /**\n   * Renders the editor in a row / column layout using different input elements.\n   *\n   * Each input emits values on change into respective pools i.e. input elements\n   * do not provide any validation on their own.\n   */\n  private isMaxSet() {\n    const { max } = this.state;\n    return max.isJust && parseInt(max.get().value) >= 1;\n  }\n\n  private defaultsUpToMax() {\n    const { defaults, max } = this.state;\n    if (!this.isMaxSet()) {\n      return defaults;\n    }\n    const maxInt = parseInt(max.get().value);\n    return defaults.slice(0, maxInt);\n  }\n\n  private renderEditor = () => {\n    const empty = Just<Value>({ value: '' });\n    const nothing = Nothing<Value>();\n    const lang = this.languages.find((language) => !this.state.label.find((label) => label.lang === language));\n    const langOptions = this.languages.map((language) => {\n      const isLabelAlreadyExists = Boolean(this.state.label.find((label) => label.lang === language));\n      return { value: language, label: language, disabled: isLabelAlreadyExists };\n    });\n    const addLabel = () => {\n      const label = [...this.state.label];\n      const validatedLabel = Validation.validateLabel('');\n      label.push({ value: validatedLabel, lang: lang || '' });\n      this.updateState({ label });\n    };\n    return D.div(\n      {},\n      row({\n        label: 'Label*',\n        expanded: this.state.label.length > 0,\n        expandOnMount: true,\n        onExpand: () => addLabel(),\n        element: [\n          this.state.label.map((label, index) => this.renderLabel(label, index, langOptions)),\n          Boolean(lang) ? D.a({ onClick: () => addLabel() }, '+ Add label') : null,\n        ],\n      }),\n      row({\n        label: 'Identifier*',\n        expanded: this.state.id.isJust,\n        expandOnMount: true,\n        onExpand: () => this.updateValues({ id: empty }, Validation.validateIri),\n        error: this.state.id.map((v) => v.error).getOrElse(undefined),\n        element: D.div({ className: 'input-group' }, [\n          input({\n            className: block('iri-input').toString(),\n            type: 'text',\n            placeholder: 'Any IRI to be used as unique identifier for the field definition.',\n            onChange: (e) => this.updateValues({ id: getFormValue(e) }, Validation.validateIri),\n            value: this.state.id.isJust ? this.state.id.get().value : undefined,\n            disabled: this.isEditMode(),\n          }),\n          D.div(\n            { className: 'input-group-btn' },\n            this.isEditMode()\n              ? this.renderCopyToClipboardButton()\n              : btn(\n                  {\n                    title: 'Generate IRI',\n                    onClick: (e) => this.generateIRI(),\n                  },\n                  D.i({ className: 'fa fa-refresh' })\n                )\n          ),\n        ]),\n      }),\n      row({\n        label: 'Description',\n        expanded: this.state.description.isJust,\n        onExpand: () => this.updateValues({ description: empty }),\n        onCollapse: () => this.updateValues({ description: nothing }),\n        element: textarea({\n          className: classnames('form-control', block('description-input').toString()),\n          rows: 4,\n          placeholder: 'Description',\n          onChange: (e) => this.updateValues({ description: getFormValue(e) }),\n          value: this.state.description.isJust ? this.state.description.get().value : undefined,\n        }),\n      }),\n      row({\n        label: 'Categories',\n        expanded: true,\n        element: createElement(SemanticTreeInput, {\n          ...this.state.categoryQueries,\n          initialSelection: this.state.categories,\n          multipleSelection: true,\n          onSelectionChanged: (selection) => {\n            const categories = TreeSelection.leafs(selection)\n              .map((node) => node.iri)\n              .toArray();\n            this.updateState({ categories });\n          },\n        } as SemanticTreeInputProps),\n      }),\n      this.renderMultipleValuesInput({\n        values: this.state.domain,\n        label: 'Domains',\n        addButtonLabel: '+ Add domain',\n        showAddButton: true,\n        placeholder: 'Any IRI to be used as domain for the field definition.',\n        onChange: (value, index) => {\n          const domain = [...this.state.domain];\n          domain[index] = Validation.validateIri(value);\n          this.updateState({ domain });\n        },\n        onAdd: () => {\n          const domain = [...this.state.domain, Validation.validateIri('')];\n          this.updateState({ domain });\n        },\n        onDelete: (index) => {\n          const domain = [...this.state.domain];\n          domain.splice(index, 1);\n          this.updateState({ domain });\n        },\n      }),\n      row({\n        label: 'XSD Datatype',\n        expanded: this.state.xsdDatatype.isJust,\n        onExpand: () => this.updateValues({ xsdDatatype: empty }),\n        onCollapse: () => this.updateValues({ xsdDatatype: nothing }),\n        error: this.state.xsdDatatype.map((v) => v.error).getOrElse(undefined),\n        element: select({\n          value: this.state.xsdDatatype.map((v) => v.value).getOrElse(undefined),\n          className: block('xsd-input').toString(),\n          multi: false,\n          clearable: false,\n          placeholder: 'Please select any XSD datatype',\n          options: vocabularies.xsd.LIST_TYPES,\n          onChange: (e: Value) => this.updateValues({ xsdDatatype: Just({ value: e.value }) }),\n          labelKey: 'label',\n          valueKey: 'value',\n        }),\n      }),\n      this.renderMultipleValuesInput({\n        values: this.state.range,\n        label: 'Ranges',\n        addButtonLabel: '+ Add range',\n        showAddButton: true,\n        placeholder: 'Any IRI to be used as range for the field definition.',\n        onChange: (value, index) => {\n          const range = [...this.state.range];\n          range[index] = Validation.validateIri(value);\n          this.updateState({ range });\n        },\n        onAdd: () => {\n          const range = [...this.state.range, Validation.validateIri('')];\n          this.updateState({ range });\n        },\n        onDelete: (index) => {\n          const range = [...this.state.range];\n          range.splice(index, 1);\n          this.updateState({ range });\n        },\n      }),\n      row({\n        label: 'Min. Cardinality',\n        expanded: this.state.min.isJust,\n        onExpand: () => this.updateValues({ min: Just({ value: '0' }) }, Validation.validateMin),\n        onCollapse: () => this.updateValues({ min: nothing }),\n        error: this.state.min.map((v) => v.error).getOrElse(undefined),\n        element: input({\n          className: block('min-input').toString(),\n          type: 'number',\n          min: 0,\n          step: 1,\n          placeholder: 'Any positive number from 0 to n. \"0\" for not required.',\n          onChange: (e) => this.updateValues({ min: getFormValue(e) }, Validation.validateMin),\n          value: this.state.min.map((v) => v.value).getOrElse(undefined),\n        }),\n      }),\n      row({\n        label: 'Max. Cardinality',\n        expanded: this.state.max.isJust,\n        onExpand: () => this.updateValues({ max: Just({ value: '1' }) }, Validation.validateMax),\n        onCollapse: () => this.updateValues({ max: nothing }),\n        error: this.state.max.map((v) => v.error).getOrElse(undefined),\n        element: input({\n          className: block('max-input').toString(),\n          type: 'text',\n          placeholder: 'Any positive number from 1 to n. \"unbound\" for unlimited.',\n          onChange: (e) => this.updateValues({ max: getFormValue(e) }, Validation.validateMax),\n          value: this.state.max.map((v) => v.value).getOrElse(undefined),\n        }),\n      }),\n      row({\n        label: 'Order',\n        expanded: this.state.order.isJust,\n        onExpand: () => this.updateValues({ order: Just({ value: '1' }) }, Validation.validateOrder),\n        onCollapse: () => this.updateValues({ order: nothing }),\n        error: this.state.order.map((v) => v.error).getOrElse(undefined),\n        element: input({\n          className: block('order-input').toString(),\n          type: 'text',\n          placeholder: 'Any positive number greater than 0.',\n          onChange: (e) => this.updateValues({ order: getFormValue(e) }, Validation.validateOrder),\n          value: this.state.order.map((v) => v.value).getOrElse(undefined),\n        }),\n      }),\n      this.renderMultipleValuesInput({\n        values: this.defaultsUpToMax(),\n        label: 'Default values',\n        addButtonLabel: '+ Add default value',\n        showAddButton: !(this.isMaxSet() && this.state.defaults.length >= parseInt(this.state.max.get().value)),\n        onChange: (value, index) => {\n          const defaults = [...this.defaultsUpToMax()];\n          defaults[index] = { value };\n          this.updateState({ defaults });\n        },\n        onAdd: () => {\n          const defaults = [...this.defaultsUpToMax(), { value: '' }];\n          this.updateState({ defaults });\n        },\n        onDelete: (index) => {\n          const defaults = [...this.defaultsUpToMax()];\n          defaults.splice(index, 1);\n          this.updateState({ defaults });\n        },\n      }),\n      row({\n        label: 'Test Subject',\n        expanded: this.state.testSubject.isJust,\n        onExpand: () => this.updateValues({ testSubject: empty }, Validation.validateIri),\n        onCollapse: () => this.updateValues({ testSubject: nothing }),\n        error: this.state.testSubject.map((v) => v.error).getOrElse(undefined),\n        element: input({\n          className: block('label-input').toString(),\n          type: 'text',\n          placeholder: `IRI of any entity to be used for testing the patterns of the field.`,\n          onChange: (e) => this.updateValues({ testSubject: getFormValue(e) }, Validation.validateIri),\n          value: this.state.testSubject.isJust ? this.state.testSubject.get().value : undefined,\n        }),\n      }),\n      row({\n        label: 'Insert Pattern*',\n        expanded: this.state.insertPattern.isJust,\n        expandOnMount: true,\n        onExpand: () =>\n          this.updateValues({ insertPattern: Just({ value: DEFAULT_INSERT }) }, Validation.validateInsert),\n        error: this.state.insertPattern.map((v) => v.error).getOrElse(undefined),\n        element: createElement(SparqlEditor, {\n          onChange: (e) => this.updateValues({ insertPattern: Just({ value: e.value }) }, Validation.validateInsert),\n          syntaxErrorCheck: false,\n          query: this.state.insertPattern.map((v) => v.value).getOrElse(''),\n        }),\n      }),\n      row({\n        label: 'Select Pattern',\n        expanded: this.state.selectPattern.isJust,\n        onExpand: () =>\n          this.updateValues({ selectPattern: Just({ value: DEFAULT_SELECT }) }, Validation.validateSelect),\n        onCollapse: () => this.updateValues({ selectPattern: nothing }),\n        error: this.state.selectPattern.map((v) => v.error).getOrElse(undefined),\n        element: createElement(SparqlEditor, {\n          onChange: (e) => this.updateValues({ selectPattern: Just({ value: e.value }) }, Validation.validateSelect),\n          syntaxErrorCheck: false,\n          query: this.state.selectPattern.map((v) => v.value).getOrElse(''),\n        }),\n      }),\n      row({\n        label: 'Delete Pattern',\n        expanded: this.state.deletePattern.isJust,\n        onExpand: () =>\n          this.updateValues({ deletePattern: Just({ value: DEFAULT_DELETE }) }, Validation.validateDelete),\n        onCollapse: () => this.updateValues({ deletePattern: nothing }),\n        error: this.state.deletePattern.map((v) => v.error).getOrElse(undefined),\n        element: createElement(SparqlEditor, {\n          onChange: (e) => this.updateValues({ deletePattern: Just({ value: e.value }) }, Validation.validateDelete),\n          syntaxErrorCheck: false,\n          query: this.state.deletePattern.map((v) => v.value).getOrElse(''),\n        }),\n      }),\n      row({\n        label: 'ASK Validation Pattern',\n        expanded: this.state.askPattern.isJust,\n        onExpand: () => this.updateValues({ askPattern: Just({ value: DEFAULT_ASK }) }, Validation.validateAsk),\n        onCollapse: () => this.updateValues({ askPattern: nothing }),\n        error: this.state.askPattern.map((v) => v.error).getOrElse(undefined),\n        element: createElement(SparqlEditor, {\n          onChange: (e) => this.updateValues({ askPattern: Just({ value: e.value }) }, Validation.validateAsk),\n          syntaxErrorCheck: false,\n          query: this.state.askPattern.map((v) => v.value).getOrElse(''),\n        }),\n      }),\n      row({\n        label: 'Value Set Pattern',\n        expanded: this.state.valueSetPattern.isJust,\n        onExpand: () =>\n          this.updateValues({ valueSetPattern: Just({ value: DEFAULT_VALUE_SET }) }, Validation.validateValueSet),\n        onCollapse: () => this.updateValues({ valueSetPattern: nothing }),\n        error: this.state.valueSetPattern.map((v) => v.error).getOrElse(undefined),\n        element: createElement(SparqlEditor, {\n          onChange: (e) =>\n            this.updateValues({ valueSetPattern: Just({ value: e.value }) }, Validation.validateValueSet),\n          syntaxErrorCheck: false,\n          query: this.state.valueSetPattern.map((v) => v.value).getOrElse(''),\n        }),\n      }),\n      row({\n        label: 'Autosuggestion Pattern',\n        expanded: this.state.autosuggestionPattern.isJust,\n        onExpand: () =>\n          this.updateValues(\n            { autosuggestionPattern: Just({ value: DEFAULT_AUTOSUGGESTION }) },\n            Validation.validateAutosuggestion\n          ),\n        onCollapse: () => this.updateValues({ autosuggestionPattern: nothing }),\n        error: this.state.autosuggestionPattern.map((v) => v.error).getOrElse(undefined),\n        element: createElement(SparqlEditor, {\n          onChange: (e) =>\n            this.updateValues({ autosuggestionPattern: Just({ value: e.value }) }, Validation.validateAutosuggestion),\n          syntaxErrorCheck: false,\n          query: this.state.autosuggestionPattern.map((v) => v.value).getOrElse(''),\n        }),\n      }),\n      row({\n        label: 'Tree Patterns',\n        expanded: this.state.treePatterns.isJust,\n        onExpand: () =>\n          this.updateState({\n            treePatterns: Just<ValidatedTreeConfig>({ type: 'simple' }),\n          }),\n        onCollapse: () =>\n          this.updateState({\n            treePatterns: Nothing<ValidatedTreeConfig>(),\n          }),\n        element: createElement(TreePatternsEditor, {\n          config: this.state.treePatterns.getOrElse({ type: 'simple' }),\n          onChange: (config: ValidatedTreeConfig) => {\n            const validated = Validation.validateTreeConfig(config);\n            this.updateState({ treePatterns: Just(validated) });\n          },\n        }),\n      }),\n      bsrow(\n        {},\n        bscol({ md: 3 }),\n        bscol(\n          { md: 9 },\n          btn(\n            {\n              disabled: !this.state.isValid,\n              bsSize: 'small',\n              onClick: () => this.onSaveOrUpdate(),\n              style: { marginLeft: '-15px' },\n            },\n            this.isEditMode() ? 'Update Field' : 'Create Field'\n          ),\n          btn(\n            {\n              disabled: !this.state.isValid,\n              bsSize: 'small',\n              onClick: () => this.onSaveOrUpdate(this.props.navigateTo),\n              style: { marginLeft: 10 },\n            },\n            this.isEditMode() ? 'Update Field and Close' : 'Create Field and Close'\n          )\n        )\n      )\n    );\n  };\n\n  private renderLabel = (\n    { value, lang }: LocalizedValue,\n    index: number,\n    langOptions: Array<{ value: string; label: string; disabled: boolean }>\n  ) => {\n    const isRequired = index === 0;\n    return createElement(FieldEditorLabel, {\n      label: { value, lang },\n      isRequired,\n      langOptions,\n      onChangeLabelValue: (newValue) => this.updateLabelValue(index, isRequired, newValue),\n      onChangeLabelLang: (newLang: string) => {\n        const label = [...this.state.label];\n        label[index] = { ...label[index], lang: newLang };\n        this.updateState({ label });\n      },\n      onDeleteLabel: () => {\n        const label = [...this.state.label];\n        label.splice(index, 1);\n        this.updateState({ label });\n      },\n    });\n  };\n\n  private updateLabelValue(index: number, isRequired: boolean, newValue: string) {\n    const labels = [...this.state.label];\n    const { value, lang } = labels[index];\n\n    const oldGeneratedId = this.generateIriFromLabel(value.value);\n\n    const validatedValue = Validation.validateLabel(newValue);\n    labels[index] = { value: validatedValue, lang };\n    this.updateState({ label: labels });\n\n    const shouldUpdateId =\n      isRequired &&\n      !this.isEditMode() &&\n      this.state.id.map((v) => !v.value || v.value === oldGeneratedId).getOrElse(true);\n\n    if (shouldUpdateId) {\n      const generatedId = this.generateIriFromLabel(newValue);\n      this.updateValues({ id: Just({ value: generatedId }) }, Validation.validateIri);\n    }\n  }\n\n  private renderCopyToClipboardButton = () => {\n    const value = this.state.id.isJust ? this.state.id.get().value : '';\n    const button = btn({ title: 'Copy to clipboard' }, D.i({ className: 'fa fa-copy' }));\n    return createElement(CopyToClipboardComponent, { text: value }, button);\n  };\n\n  private renderMultipleValuesInput(params: {\n    values: ReadonlyArray<Value>;\n    label: string;\n    addButtonLabel: string;\n    showAddButton: boolean;\n    placeholder?: string;\n    onChange: (value: string, index: number) => void;\n    onAdd: () => void;\n    onDelete: (index: number) => void;\n  }) {\n    const { values, label, addButtonLabel, showAddButton, placeholder, onChange, onAdd, onDelete } = params;\n    return row({\n      label,\n      expanded: true,\n      element: [\n        values.map(({ value, error }, index) => [\n          D.div(\n            { className: block('default-input-holder').toString() },\n            input({\n              className: block('default-input').toString(),\n              type: 'text',\n              placeholder,\n              onChange: (e) => onChange((e.target as HTMLInputElement).value, index),\n              value,\n            }),\n            btn(\n              {\n                className: block('delete-default').toString(),\n                onClick: () => onDelete(index),\n              },\n              D.span({ className: 'fa fa-times' })\n            )\n          ),\n          error ? bsrow({ className: block('error').toString() }, bscol({ md: 12 }, error.message)) : null,\n        ]),\n        showAddButton ? D.a({ onClick: onAdd }, addButtonLabel) : null,\n      ],\n    });\n  }\n\n  private isEditMode = (): boolean => {\n    return Boolean(this.props.fieldIri);\n  };\n\n  private updateValues(\n    values: Partial<State> & Record<string, Data.Maybe<Value>>,\n    validate?: (value: string) => Value\n  ) {\n    const validatedValues = Object.keys(values).reduce<Partial<State>>((acc, key) => {\n      const original = values[key];\n      const validated = original.map<Value>((v) => (validate ? validate(v.value) : { value: v.value }));\n      acc[key] = validated;\n      return acc;\n    }, {});\n\n    this.updateState(validatedValues);\n  }\n\n  private updateState(update: Partial<State>) {\n    const newState = { ...this.state, ...update };\n    const errors = Validation.collectStateErrors(newState);\n    this.setState({ ...update, isValid: errors.length === 0 });\n  }\n\n  private generateIRI = () => {\n    const local = this.state.label.length > 0 ? encodeURIComponent(this.state.label[0].value.value) : Date.now();\n    const id = this.getFieldInstanceIriBase() + local;\n    this.updateValues({ id: Just({ value: id }) }, Validation.validateIri);\n  };\n\n  private generateIriFromLabel(v: string): string {\n    return this.getFieldInstanceIriBase() + encodeURIComponent(v);\n  }\n\n  /**\n   * Returns base IRI to be used for storing new field definitions.\n   * If not configured as attribute on the field editor, it will return a\n   * standard LdpBase prefix + 'fieldDefinitionContainer/' or {@FIELD_DEF_INSTANCE_BASE}.\n   */\n  private getFieldInstanceIriBase = (): string => {\n    if (this.props.fieldInstanceBaseIri) {\n      return this.props.fieldInstanceBaseIri;\n    } else if (SparqlUtil.RegisteredPrefixes['LdpBase']) {\n      // fieldDefinitionContainer is local name of the FieldDefinitionContainer IRI\n      // see FieldDefinitionContainer.java\n      return SparqlUtil.RegisteredPrefixes['LdpBase'] + 'fieldDefinitionContainer/';\n    } else {\n      return FIELD_DEF_INSTANCE_BASE;\n    }\n  };\n\n  /**\n   * Action for save or update button. Saves the graph (i.e. the field definition)\n   * using LDP api.\n   */\n  private onSaveOrUpdate = (navigateTo?: string) => {\n    const finalGraph = tryCreateFinalGraph(this.state);\n    if (finalGraph.isNothing) {\n      return;\n    }\n\n    const graph = finalGraph.get();\n    const ldp = new LdpService(vocabularies.VocabPlatform.FieldDefinitionContainer.value);\n\n    if (this.isEditMode()) {\n      ldp.update(Rdf.iri(this.state.id.get().value), graph).onValue(() => {\n        if (navigateTo) {\n          navigateToResource(Rdf.iri(navigateTo), {}, 'assets').onValue((v) => v);\n        } else {\n          window.location.reload();\n        }\n      });\n    } else {\n      return ldp\n        .addResource(graph, Just(this.state.id.get().value))\n        .flatMap((newResourceIri) => {\n          const resourceIri = navigateTo ? Rdf.iri(navigateTo) : newResourceIri;\n          return navigateToResource(resourceIri, {}, 'assets');\n        })\n        .onValue((v) => v);\n    }\n  };\n}\n\n/**\n * Simple helper to convert the current value of any HTMLInputElement into\n * a Kefir observable.\n */\nfunction getFormValue(e: FormEvent<ReactBootstrap.FormControl> | ChangeEvent<HTMLTextAreaElement>): Data.Maybe<Value> {\n  const text = (e.target as HTMLInputElement).value;\n  return Just({ value: text });\n}\n\nfunction tryCreateFinalGraph(state: State): Data.Maybe<Rdf.Graph> {\n  const fields = unwrapState(state);\n\n  // ignore these cases where iri, label or insert are undefined\n  if (!fields.id || !fields.label || !fields.insertPattern) {\n    return Nothing<Rdf.Graph>();\n  }\n\n  const graph = createFieldDefinitionGraph(fields);\n  return Just(graph);\n}\n\nexport type component = FieldEditorComponent;\nexport const component = FieldEditorComponent;\nexport const factory = createFactory(component);\nexport default component;\n"],"sourceRoot":""}