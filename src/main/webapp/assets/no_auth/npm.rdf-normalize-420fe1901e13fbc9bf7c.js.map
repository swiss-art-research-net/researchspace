{"version":3,"sources":["webpack:///./node_modules/rdf-normalize/index.js","webpack:///./node_modules/rdf-normalize/jsonld-normalize.js"],"names":["jsonldNormalize","createPlainNode","node","plain","interfaceName","type","value","nominalValue","toString","datatype","language","createPlainDataset","graph","dataset","forEach","quad","name","push","createPlainTriple","triple","subject","predicate","object","module","exports","normalize","Processor","_hashQuads","id","bnodes","hash","quads","nquads","i","length","_toNQuad","sort","sha1","_getAdjacentBlankNodeName","graphName","bnode","s","p","o","g","replace","RDF","indexOf","UniqueNamer","prefix","this","counter","existing","prototype","options","callback","triples","ti","attrs","ai","attr","namer","hashBlankNodes","Object","keys","unnamed","nextUnnamed","duplicates","unique","hashUnnamed","nameBlankNodes","named","hashes","getName","nameDuplicates","processGroup","createArray","normalized","join","group","results","nameGroupMember","n","a","b","r","key","pathNamer","isNamed","_hashPaths","groupHashes","md","create","groups","groupNodes","hashGroup","direction","update","groupHash","digest","chosenPath","chosenNamer","permutator","Permutator","permutate","permutation","next","pathNamerCopy","clone","path","recurse","nextPermutation","nextRecursion","err","result","skipped","hasNext","copy","_clone","rval","Array","isArray","oldName","list","done","left","slice","k","pos","element","swap","crypto","createHash","data"],"mappings":"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","file":"npm.rdf-normalize-420fe1901e13fbc9bf7c.js","sourcesContent":["var jsonldNormalize = require('./jsonld-normalize')\n\nfunction createPlainNode (node) {\n  if (!node) {\n    return null\n  }\n\n  var plain = {}\n\n  if (node.interfaceName === 'NamedNode') {\n    plain.type = 'IRI'\n    plain.value = node.nominalValue\n  } else if (node.interfaceName === 'BlankNode') {\n    plain.type = 'blank node'\n    plain.value = node.toString()\n  } else if (node.interfaceName === 'Literal') {\n    plain.type = 'literal'\n    plain.value = node.nominalValue\n    plain.datatype = node.datatype.nominalValue\n    plain.language = node.language\n  }\n\n  return plain\n}\n\nfunction createPlainTriple (triple) {\n  return {\n    subject: createPlainNode(triple.subject),\n    predicate: createPlainNode(triple.predicate),\n    object: createPlainNode(triple.object)\n  }\n}\n\nfunction createPlainDataset (graph) {\n  var dataset = {}\n\n  graph.forEach(function (quad) {\n    var name = '@default'\n\n    if ('graph' in quad && quad.graph.nominalValue) {\n      name = quad.graph.nominalValue\n    }\n\n    if (!(name in dataset)) {\n      dataset[name] = []\n    }\n\n    dataset[name].push(createPlainTriple(quad))\n  })\n\n  return dataset\n}\n\nfunction normalize (graph) {\n  return jsonldNormalize(createPlainDataset(graph))\n}\n\nmodule.exports = normalize\n","/**\n * A JavaScript implementation of the JSON-LD API.\n *\n * @author Dave Longley\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2011-2014 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// constants\n    var XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';\n\n    var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\n    var RDF_LANGSTRING = RDF + 'langString';\n\n    /**\n     * Constructs a new JSON-LD Processor.\n     */\n    var Processor = function() {};\n\n    /**\n     * Performs normalization on the given RDF dataset.\n     *\n     * @param dataset the RDF dataset to normalize.\n     * @param options the normalization options.\n     * @param callback(err, normalized) called once the operation completes.\n     */\n    Processor.prototype.normalize = function(dataset, options, callback) {\n      // create quads and map bnodes to their associated quads\n      var quads = [];\n      var bnodes = {};\n      for(var graphName in dataset) {\n        var triples = dataset[graphName];\n        if(graphName === '@default') {\n          graphName = null;\n        }\n        for(var ti = 0; ti < triples.length; ++ti) {\n          var quad = triples[ti];\n          if(graphName !== null) {\n            if(graphName.indexOf('_:') === 0) {\n              quad.name = {type: 'blank node', value: graphName};\n            } else {\n              quad.name = {type: 'IRI', value: graphName};\n            }\n          }\n          quads.push(quad);\n\n          var attrs = ['subject', 'object', 'name'];\n          for(var ai = 0; ai < attrs.length; ++ai) {\n            var attr = attrs[ai];\n            if(quad[attr] && quad[attr].type === 'blank node') {\n              var id = quad[attr].value;\n              if(id in bnodes) {\n                bnodes[id].quads.push(quad);\n              } else {\n                bnodes[id] = {quads: [quad]};\n              }\n            }\n          }\n        }\n      }\n\n      // mapping complete, start canonical naming\n      var namer = new UniqueNamer('_:c14n');\n      return hashBlankNodes(Object.keys(bnodes));\n\n      // generates unique and duplicate hashes for bnodes\n      function hashBlankNodes(unnamed) {\n        var nextUnnamed = [];\n        var duplicates = {};\n        var unique = {};\n\n        // TODO: instead of N calls to setImmediate, run\n        // atomic normalization parts for a specified\n        // slice of time (perhaps configurable) as this\n        // will better utilize CPU and improve performance\n        // as JS processing speed improves\n\n        // hash quads for each unnamed bnode\n        return hashUnnamed(0);\n        function hashUnnamed(i) {\n          if(i === unnamed.length) {\n            // done, name blank nodes\n            return nameBlankNodes(unique, duplicates, nextUnnamed);\n          }\n\n          // hash unnamed bnode\n          var bnode = unnamed[i];\n          var hash = _hashQuads(bnode, bnodes);\n\n          // store hash as unique or a duplicate\n          if(hash in duplicates) {\n            duplicates[hash].push(bnode);\n            nextUnnamed.push(bnode);\n          } else if(hash in unique) {\n            duplicates[hash] = [unique[hash], bnode];\n            nextUnnamed.push(unique[hash]);\n            nextUnnamed.push(bnode);\n            delete unique[hash];\n          } else {\n            unique[hash] = bnode;\n          }\n\n          // hash next unnamed bnode\n          return hashUnnamed(i + 1);\n        }\n      }\n\n      // names unique hash bnodes\n      function nameBlankNodes(unique, duplicates, unnamed) {\n        // name unique bnodes in sorted hash order\n        var named = false;\n        var hashes = Object.keys(unique).sort();\n        for(var i = 0; i < hashes.length; ++i) {\n          var bnode = unique[hashes[i]];\n          namer.getName(bnode);\n          named = true;\n        }\n\n        if(named) {\n          // continue to hash bnodes if a bnode was assigned a name\n          return hashBlankNodes(unnamed);\n        } else {\n          // name the duplicate hash bnodes\n          return nameDuplicates(duplicates);\n        }\n      }\n\n      // names duplicate hash bnodes\n      function nameDuplicates(duplicates) {\n        // enumerate duplicate hash groups in sorted order\n        var hashes = Object.keys(duplicates).sort();\n\n        // process each group\n        return processGroup(0);\n        function processGroup(i) {\n          if(i === hashes.length) {\n            // done, create JSON-LD array\n            return createArray();\n          }\n\n          // name each group member\n          var group = duplicates[hashes[i]];\n          var results = [];\n          return nameGroupMember(group, 0);\n          function nameGroupMember(group, n) {\n            if(n === group.length) {\n              // name bnodes in hash order\n              results.sort(function(a, b) {\n                a = a.hash;\n                b = b.hash;\n                return (a < b) ? -1 : ((a > b) ? 1 : 0);\n              });\n              for(var r = 0; r < results.length; ++r) {\n                // name all bnodes in path namer in key-entry order\n                // Note: key-order is preserved in javascript\n                for(var key in results[r].pathNamer.existing) {\n                  namer.getName(key);\n                }\n              }\n              return processGroup(i + 1);\n            }\n\n            // skip already-named bnodes\n            var bnode = group[n];\n            if(namer.isNamed(bnode)) {\n              return nameGroupMember(group, n + 1);\n            }\n\n            // hash bnode paths\n            var pathNamer = new UniqueNamer('_:b');\n            pathNamer.getName(bnode);\n            return _hashPaths(bnode, bnodes, namer, pathNamer,\n              function(err, result) {\n                if(err) {\n                  return callback(err);\n                }\n                results.push(result);\n                return nameGroupMember(group, n + 1);\n              });\n          }\n        }\n      }\n\n      // creates the sorted array of RDF quads\n      function createArray() {\n        var normalized = [];\n\n        /* Note: At this point all bnodes in the set of RDF quads have been\n         assigned canonical names, which have been stored in the 'namer' object.\n         Here each quad is updated by assigning each of its bnodes its new name\n         via the 'namer' object. */\n\n        // update bnode names in each quad and serialize\n        for(var i = 0; i < quads.length; ++i) {\n          var quad = quads[i];\n          var attrs = ['subject', 'object', 'name'];\n          for(var ai = 0; ai < attrs.length; ++ai) {\n            var attr = attrs[ai];\n            if(quad[attr] && quad[attr].type === 'blank node' &&\n              quad[attr].value.indexOf('_:c14n') !== 0) {\n              quad[attr].value = namer.getName(quad[attr].value);\n            }\n          }\n          normalized.push(_toNQuad(quad, quad.name ? quad.name.value : null));\n        }\n\n        // sort normalized output\n        return normalized.sort().join('');\n      }\n    };\n\n    /**\n     * Hashes all of the quads about a blank node.\n     *\n     * @param id the ID of the bnode to hash quads for.\n     * @param bnodes the mapping of bnodes to quads.\n     *\n     * @return the new hash.\n     */\n    function _hashQuads(id, bnodes) {\n      // return cached hash\n      if('hash' in bnodes[id]) {\n        return bnodes[id].hash;\n      }\n\n      // serialize all of bnode's quads\n      var quads = bnodes[id].quads;\n      var nquads = [];\n      for(var i = 0; i < quads.length; ++i) {\n        nquads.push(_toNQuad(\n          quads[i], quads[i].name ? quads[i].name.value : null, id));\n      }\n      // sort serialized quads\n      nquads.sort();\n      // return hashed quads\n      var hash = bnodes[id].hash = sha1.hash(nquads);\n      return hash;\n    }\n\n    /**\n     * Produces a hash for the paths of adjacent bnodes for a bnode,\n     * incorporating all information about its subgraph of bnodes. This\n     * method will recursively pick adjacent bnode permutations that produce the\n     * lexicographically-least 'path' serializations.\n     *\n     * @param id the ID of the bnode to hash paths for.\n     * @param bnodes the map of bnode quads.\n     * @param namer the canonical bnode namer.\n     * @param pathNamer the namer used to assign names to adjacent bnodes.\n     * @param callback(err, result) called once the operation completes.\n     */\n    function _hashPaths(id, bnodes, namer, pathNamer, callback) {\n      // create SHA-1 digest\n      var md = sha1.create();\n\n      // group adjacent bnodes by hash, keep properties and references separate\n      var groups = {};\n      var groupHashes;\n      var quads = bnodes[id].quads;\n      return groupNodes(0);\n      function groupNodes(i) {\n        if(i === quads.length) {\n          // done, hash groups\n          groupHashes = Object.keys(groups).sort();\n          return hashGroup(0);\n        }\n\n        // get adjacent bnode\n        var quad = quads[i];\n        var bnode = _getAdjacentBlankNodeName(quad.subject, id);\n        var direction = null;\n        if(bnode !== null) {\n          // normal property\n          direction = 'p';\n        } else {\n          bnode = _getAdjacentBlankNodeName(quad.object, id);\n          if(bnode !== null) {\n            // reverse property\n            direction = 'r';\n          }\n        }\n\n        if(bnode !== null) {\n          // get bnode name (try canonical, path, then hash)\n          var name;\n          if(namer.isNamed(bnode)) {\n            name = namer.getName(bnode);\n          } else if(pathNamer.isNamed(bnode)) {\n            name = pathNamer.getName(bnode);\n          } else {\n            name = _hashQuads(bnode, bnodes);\n          }\n\n          // hash direction, property, and bnode name/hash\n          var md = sha1.create();\n          md.update(direction);\n          md.update(quad.predicate.value);\n          md.update(name);\n          var groupHash = md.digest();\n\n          // add bnode to hash group\n          if(groupHash in groups) {\n            groups[groupHash].push(bnode);\n          } else {\n            groups[groupHash] = [bnode];\n          }\n        }\n\n        return groupNodes(i + 1);\n      }\n\n      // hashes a group of adjacent bnodes\n      function hashGroup(i) {\n        if(i === groupHashes.length) {\n          // done, return SHA-1 digest and path namer\n          return callback(null, {hash: md.digest(), pathNamer: pathNamer});\n        }\n\n        // digest group hash\n        var groupHash = groupHashes[i];\n        md.update(groupHash);\n\n        // choose a path and namer from the permutations\n        var chosenPath = null;\n        var chosenNamer = null;\n        var permutator = new Permutator(groups[groupHash]);\n        return permutate();\n        function permutate() {\n          var permutation = permutator.next();\n          var pathNamerCopy = pathNamer.clone();\n\n          // build adjacent path\n          var path = '';\n          var recurse = [];\n          for(var n in permutation) {\n            var bnode = permutation[n];\n\n            // use canonical name if available\n            if(namer.isNamed(bnode)) {\n              path += namer.getName(bnode);\n            } else {\n              // recurse if bnode isn't named in the path yet\n              if(!pathNamerCopy.isNamed(bnode)) {\n                recurse.push(bnode);\n              }\n              path += pathNamerCopy.getName(bnode);\n            }\n\n            // skip permutation if path is already >= chosen path\n            if(chosenPath !== null && path.length >= chosenPath.length &&\n              path > chosenPath) {\n              return nextPermutation(true);\n            }\n          }\n\n          // does the next recursion\n          return nextRecursion(0);\n          function nextRecursion(n) {\n            if(n === recurse.length) {\n              // done, do next permutation\n              return nextPermutation(false);\n            }\n\n            // do recursion\n            var bnode = recurse[n];\n            return _hashPaths(bnode, bnodes, namer, pathNamerCopy,\n              function(err, result) {\n                if(err) {\n                  return callback(err);\n                }\n                path += pathNamerCopy.getName(bnode) + '<' + result.hash + '>';\n                pathNamerCopy = result.pathNamer;\n\n                // skip permutation if path is already >= chosen path\n                if(chosenPath !== null && path.length >= chosenPath.length &&\n                  path > chosenPath) {\n                  return nextPermutation(true);\n                }\n\n                // do next recursion\n                return nextRecursion(n + 1);\n              });\n          }\n\n          // stores the results of this permutation and runs the next\n          function nextPermutation(skipped) {\n            if(!skipped && (chosenPath === null || path < chosenPath)) {\n              chosenPath = path;\n              chosenNamer = pathNamerCopy;\n            }\n\n            // do next permutation\n            if(permutator.hasNext()) {\n              return permutate();\n            } else {\n              // digest chosen path and update namer\n              md.update(chosenPath);\n              pathNamer = chosenNamer;\n\n              // hash the next group\n              return hashGroup(i + 1);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * A helper function that gets the blank node name from an RDF quad node\n     * (subject or object). If the node is a blank node and its value\n     * does not match the given blank node ID, it will be returned.\n     *\n     * @param node the RDF quad node.\n     * @param id the ID of the blank node to look next to.\n     *\n     * @return the adjacent blank node name or null if none was found.\n     */\n    function _getAdjacentBlankNodeName(node, id) {\n      return (node.type === 'blank node' && node.value !== id ? node.value : null);\n    }\n\n    /**\n     * Clones an object, array, or string/number. If a typed JavaScript object\n     * is given, such as a Date, it will be converted to a string.\n     *\n     * @param value the value to clone.\n     *\n     * @return the cloned value.\n     */\n    function _clone(value) {\n      if(value && typeof value === 'object') {\n        var rval;\n        if(Array.isArray(value)) {\n          rval = [];\n          for(var i = 0; i < value.length; ++i) {\n            rval[i] = _clone(value[i]);\n          }\n        } else if(typeof value === 'object') {\n          rval = {};\n          for(var key in value) {\n            rval[key] = _clone(value[key]);\n          }\n        } else {\n          rval = value.toString();\n        }\n        return rval;\n      }\n      return value;\n    }\n\n    /**\n     * Converts an RDF triple and graph name to an N-Quad string (a single quad).\n     *\n     * @param triple the RDF triple to convert.\n     * @param graphName the name of the graph containing the triple, null for\n     *          the default graph.\n     * @param bnode the bnode the quad is mapped to (optional, for use\n     *          during normalization only).\n     *\n     * @return the N-Quad string.\n     */\n    function _toNQuad(triple, graphName, bnode) {\n      var s = triple.subject;\n      var p = triple.predicate;\n      var o = triple.object;\n      var g = graphName;\n\n      var quad = '';\n\n      // subject is an IRI\n      if(s.type === 'IRI') {\n        quad += '<' + s.value + '>';\n      } else if(bnode) {\n        // bnode normalization mode\n        quad += (s.value === bnode) ? '_:a' : '_:z';\n      } else {\n        // bnode normal mode\n        quad += s.value;\n      }\n      quad += ' ';\n\n      // predicate is an IRI\n      if(p.type === 'IRI') {\n        quad += '<' + p.value + '>';\n      } else if(bnode) {\n        // FIXME: TBD what to do with bnode predicates during normalization\n        // bnode normalization mode\n        quad += '_:p';\n      } else {\n        // bnode normal mode\n        quad += p.value;\n      }\n      quad += ' ';\n\n      // object is IRI, bnode, or literal\n      if(o.type === 'IRI') {\n        quad += '<' + o.value + '>';\n      } else if(o.type === 'blank node') {\n        // normalization mode\n        if(bnode) {\n          quad += (o.value === bnode) ? '_:a' : '_:z';\n        } else {\n          // normal mode\n          quad += o.value;\n        }\n      } else {\n        var escaped = o.value\n          .replace(/\\\\/g, '\\\\\\\\')\n          .replace(/\\t/g, '\\\\t')\n          .replace(/\\n/g, '\\\\n')\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\\"/g, '\\\\\"');\n        quad += '\"' + escaped + '\"';\n        if(o.datatype === RDF_LANGSTRING) {\n          if(o.language) {\n            quad += '@' + o.language;\n          }\n        } else if(o.datatype !== XSD_STRING) {\n          quad += '^^<' + o.datatype + '>';\n        }\n      }\n\n      // graph\n      if(g !== null) {\n        if(g.indexOf('_:') !== 0) {\n          quad += ' <' + g + '>';\n        } else if(bnode) {\n          quad += ' _:g';\n        } else {\n          quad += ' ' + g;\n        }\n      }\n\n      quad += ' .\\n';\n      return quad;\n    }\n\n    /**\n     * Creates a new UniqueNamer. A UniqueNamer issues unique names, keeping\n     * track of any previously issued names.\n     *\n     * @param prefix the prefix to use ('<prefix><counter>').\n     */\n    function UniqueNamer(prefix) {\n      this.prefix = prefix;\n      this.counter = 0;\n      this.existing = {};\n    }\n\n    /**\n     * Copies this UniqueNamer.\n     *\n     * @return a copy of this UniqueNamer.\n     */\n    UniqueNamer.prototype.clone = function() {\n      var copy = new UniqueNamer(this.prefix);\n      copy.counter = this.counter;\n      copy.existing = _clone(this.existing);\n      return copy;\n    };\n\n    /**\n     * Gets the new name for the given old name, where if no old name is given\n     * a new name will be generated.\n     *\n     * @param [oldName] the old name to get the new name for.\n     *\n     * @return the new name.\n     */\n    UniqueNamer.prototype.getName = function(oldName) {\n      // return existing old name\n      if(oldName && oldName in this.existing) {\n        return this.existing[oldName];\n      }\n\n      // get next name\n      var name = this.prefix + this.counter;\n      this.counter += 1;\n\n      // save mapping\n      if(oldName) {\n        this.existing[oldName] = name;\n      }\n\n      return name;\n    };\n\n    /**\n     * Returns true if the given oldName has already been assigned a new name.\n     *\n     * @param oldName the oldName to check.\n     *\n     * @return true if the oldName has been assigned a new name, false if not.\n     */\n    UniqueNamer.prototype.isNamed = function(oldName) {\n      return (oldName in this.existing);\n    };\n\n    /**\n     * A Permutator iterates over all possible permutations of the given array\n     * of elements.\n     *\n     * @param list the array of elements to iterate over.\n     */\n    var Permutator = function(list) {\n      // original array\n      this.list = list.sort();\n      // indicates whether there are more permutations\n      this.done = false;\n      // directional info for permutation algorithm\n      this.left = {};\n      for(var i = 0; i < list.length; ++i) {\n        this.left[list[i]] = true;\n      }\n    };\n\n    /**\n     * Returns true if there is another permutation.\n     *\n     * @return true if there is another permutation, false if not.\n     */\n    Permutator.prototype.hasNext = function() {\n      return !this.done;\n    };\n\n    /**\n     * Gets the next permutation. Call hasNext() to ensure there is another one\n     * first.\n     *\n     * @return the next permutation.\n     */\n    Permutator.prototype.next = function() {\n      // copy current permutation\n      var rval = this.list.slice();\n\n      /* Calculate the next permutation using the Steinhaus-Johnson-Trotter\n       permutation algorithm. */\n\n      // get largest mobile element k\n      // (mobile: element is greater than the one it is looking at)\n      var k = null;\n      var pos = 0;\n      var length = this.list.length;\n      for(var i = 0; i < length; ++i) {\n        var element = this.list[i];\n        var left = this.left[element];\n        if((k === null || element > k) &&\n          ((left && i > 0 && element > this.list[i - 1]) ||\n          (!left && i < (length - 1) && element > this.list[i + 1]))) {\n          k = element;\n          pos = i;\n        }\n      }\n\n      // no more permutations\n      if(k === null) {\n        this.done = true;\n      } else {\n        // swap k and the element it is looking at\n        var swap = this.left[k] ? pos - 1 : pos + 1;\n        this.list[pos] = this.list[swap];\n        this.list[swap] = k;\n\n        // reverse the direction of all elements larger than k\n        for(var i = 0; i < length; ++i) {\n          if(this.list[i] > k) {\n            this.left[this.list[i]] = !this.left[this.list[i]];\n          }\n        }\n      }\n\n      return rval;\n    };\n\n// SHA-1 API\n    var sha1 = {};\n\n    var crypto = require('crypto');\n    sha1.create = function() {\n      var md = crypto.createHash('sha1');\n      return {\n        update: function(data) {\n          md.update(data, 'utf8');\n        },\n        digest: function() {\n          return md.digest('hex');\n        }\n      };\n    };\n\n    /**\n     * Hashes the given array of quads and returns its hexadecimal SHA-1 message\n     * digest.\n     *\n     * @param nquads the list of serialized quads to hash.\n     *\n     * @return the hexadecimal SHA-1 message digest.\n     */\n    sha1.hash = function(nquads) {\n      var md = sha1.create();\n      for(var i = 0; i < nquads.length; ++i) {\n        md.update(nquads[i]);\n      }\n      return md.digest();\n    };\n\nfunction normalize (dataset) {\n  var processor = new Processor()\n\n  return processor.normalize(dataset)\n}\n\nmodule.exports = normalize\n"],"sourceRoot":""}