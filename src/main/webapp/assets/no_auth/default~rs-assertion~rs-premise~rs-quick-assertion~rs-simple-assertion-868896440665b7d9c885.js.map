{"version":3,"sources":["webpack:///./src/main/web/components/arguments/FieldUtils.ts","webpack:///./src/main/web/components/arguments/AssertionsStore.ts","webpack:///./src/main/web/components/arguments/BeliefsUtil.ts"],"names":["getArgumentsFieldDefinition","iri","getFieldDefinitionProp","map","field","argumentsField","id","rdfs","evaluate","context","assertion","assertionIri","getOrElse","Rdf","uuid","v4","Kefir","combine","_","beliefs","getBeliefGraphs","beliefGraphs","allBeliefs","flatten","evaluateAssertion","b","pointer","flatMap","assertionPg","bs","service","LdpService","rso","AssertionsContainer","value","isJust","update","get","graph","addResource","Maybe","Just","baseIri","beliefsPgs","BASE_IRI","beliefsTriples","beliefPg","union","triple","PX_asserts","assertionTimePg","createAssertionTimeSpan","timeIri","time","moment","timeLiteral","literal","toISOString","vocabularies","xsd","dateTime","label","format","pg","crm","P82a_begin_of_the_begin","P82a_end_of_the_end","displayLabel","triples","rdf","type","EX_Assertion","title","P3_has_note","note","targetsField","targetsRecord","target","P14_carried_out_by","user","P4_has_time_span","toJS","narrative","push","P70i_is_documented_in","loadAssertion","deserializeAssertion","getValueFromPropertyPath","undefined","fieldIri","getValuesFromPropertyPath","beliefIri","beliefType","AssertedBeliefTypeKind","targetValue","PX_asserts_value","isCanonical","PX_is_canonical_value","v","originRepository","belief","crminf","J5_holds_to_be","toProperty","saveAssertion","fromPromise","Util","getUser","userURI","serializeBelief","propSetIri","I2_Belief","J4_that","argumentBeliefType","ArgumentsBeliefTypeAssertionKind","PX_premise_assertion","PX_premise_target","PX_premise_field","PX_premise_target_repository","savePropositionSet","propositions","propositionSetIri","createPropositionIri","propositionSetGraph","serializePropSet","proposition","I4_Proposition_Set","ldpc","PropositionsContainer","maybe","createBeliefIri","createBeliefLabel","matchBelief","AssertedBelief","getBeliefGraphForAssertedBelief","propSetForAssertedBelief","query","buildQueryForAssertedBelief","insertQuery","isCanonicalValue","operation","updates","prefixes","queryType","template","insert","where","cloneDeep","SparqlUtil","parseQuerySync","insertPattern","SparqlClient","construct","setBindings","subject","propSet","ArgumentsBelief","getBeliefGraphForArgumentsBelief","matchArgumentsBelief","AssertionBelief","getBeliefsForAssertion","FieldBelief","getBeliefsForField","propSetForArgumentsBelief","buildQueryForArgumentsBelief","x"],"mappings":"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","file":"default~rs-assertion~rs-premise~rs-quick-assertion~rs-simple-assertion-868896440665b7d9c885.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2015-2020, © Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { getFieldDefinitionProp } from 'platform/api/services/ldp-field';\n\nimport { ArgumentsFieldDefinition } from './ArgumentsApi';\n\nexport function getArgumentsFieldDefinition(iri: Rdf.Iri): Kefir.Property<ArgumentsFieldDefinition> {\n  return getFieldDefinitionProp(iri).map((field) => {\n    const argumentsField = field as ArgumentsFieldDefinition;\n    argumentsField.iri = argumentsField.id;\n    argumentsField.id = 'field';\n    return argumentsField;\n  });\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, © Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\nimport * as uuid from 'uuid';\nimport * as Maybe from 'data.maybe';\nimport * as moment from 'moment';\nimport * as _ from 'lodash';\n\nimport { Rdf, vocabularies } from 'platform/api/rdf';\nconst { rdfs } = vocabularies;\n\nimport { LdpService } from 'platform/api/services/ldp';\nimport { Util } from 'platform/api/services/security';\n\nimport { crm, rso, crminf } from 'platform/data/vocabularies/vocabularies';\nimport { Assertion, AssertedBeliefTypeKind } from './ArgumentsApi';\nimport { getArgumentsFieldDefinition } from './FieldUtils';\n\nimport { getBeliefGraphs } from './BeliefsUtil';\n\n// Assertion restore\nexport function loadAssertion(iri: Rdf.Iri): Kefir.Property<Assertion> {\n  return new LdpService(rso.AssertionsContainer.value)\n    .get(iri)\n    .flatMap((graph) => deserializeAssertion(iri, graph))\n    .toProperty();\n}\n\nfunction deserializeAssertion(iri: Rdf.Iri, graph: Rdf.Graph): Kefir.Property<Assertion> {\n  const pg = Rdf.pg(iri, graph);\n\n  const target = Rdf.getValueFromPropertyPath<Rdf.Iri>([rso.targetsRecord], pg).getOrElse(undefined);\n  const fieldIri = Rdf.getValueFromPropertyPath<Rdf.Iri>([rso.targetsField], pg).getOrElse(undefined);\n\n  return getArgumentsFieldDefinition(fieldIri).map((field) => {\n    const beliefRoots = Rdf.getValuesFromPropertyPath<Rdf.Iri>([rso.PX_asserts], pg);\n    const beliefs = beliefRoots.map((beliefIri) => {\n      const beliefPg = Rdf.pg(beliefIri, graph);\n      return {\n        iri: Maybe.Just(beliefIri),\n        beliefType: AssertedBeliefTypeKind as typeof AssertedBeliefTypeKind,\n        target: target,\n        field: field,\n        targetValue: Rdf.getValueFromPropertyPath([rso.PX_asserts_value], beliefPg).getOrElse(undefined),\n        isCanonical: Rdf.getValueFromPropertyPath([rso.PX_is_canonical_value], beliefPg)\n          .map((v) => v.value === 'true')\n          .getOrElse(false),\n        originRepository: 'default',\n        belief: {\n          type: 'simple' as 'simple',\n          value: Rdf.getValueFromPropertyPath([crminf.J5_holds_to_be], beliefPg)\n            .map((v) => v.value)\n            .getOrElse(undefined) as any,\n        },\n      };\n    });\n\n    const assertion: Assertion = {\n      iri: Maybe.Just(iri),\n      title: Rdf.getValueFromPropertyPath([rdfs.label], pg)\n        .map((v) => v.value)\n        .getOrElse(''),\n      note: Rdf.getValueFromPropertyPath([crm.P3_has_note], pg)\n        .map((v) => v.value)\n        .getOrElse(''),\n      narrative: Rdf.getValueFromPropertyPath<Rdf.Iri>([crm.P70i_is_documented_in], pg).getOrElse(undefined),\n      target: target,\n      field: field,\n      beliefs: beliefs,\n    };\n\n    return assertion;\n  });\n}\n\n// Assertion saving\nexport interface SavedAssertion {\n  assertion: Rdf.Iri;\n  beliefs: Array<Rdf.Node>;\n}\n\nexport function saveAssertion(assertion: Assertion): Kefir.Property<SavedAssertion> {\n  return Kefir.fromPromise(Util.getUser())\n    .toProperty()\n    .flatMap((user) =>\n      evaluate({\n        user: Rdf.iri(user.userURI),\n      })(assertion)\n    )\n    .toProperty();\n}\n\ninterface EvaluationContext {\n  user: Rdf.Iri;\n}\n\nexport function evaluate(context: EvaluationContext) {\n  return (assertion: Assertion) => {\n    const assertionIri = assertion.iri.getOrElse(Rdf.iri(`${assertion.field.iri}/assertion/${uuid.v4()}`));\n    return Kefir.combine(_.map(assertion.beliefs, getBeliefGraphs))\n      .map<[Rdf.PointedGraph, Array<Rdf.Node>]>((beliefGraphs) => {\n        const allBeliefs = _.flatten(beliefGraphs);\n        return [evaluateAssertion(context, assertionIri)(assertion, allBeliefs), _.map(allBeliefs, (b) => b.pointer)];\n      })\n      .flatMap(([assertionPg, bs]) => {\n        const service = new LdpService(rso.AssertionsContainer.value);\n        if (assertion.iri.isJust) {\n          return service\n            .update(assertion.iri.get(), assertionPg.graph)\n            .map((_) => ({ assertion: assertion.iri.get(), beliefs: bs }));\n        } else {\n          return new LdpService(rso.AssertionsContainer.value)\n            .addResource(assertionPg.graph, Maybe.Just(assertionIri.value))\n            .map((iri) => ({ assertion: iri, beliefs: bs }));\n        }\n      });\n  };\n}\n\nfunction evaluateAssertion(context: EvaluationContext, baseIri: Rdf.Iri) {\n  return (assertion: Assertion, beliefsPgs: Array<Rdf.PointedGraph>): Rdf.PointedGraph => {\n    const assertionIri = Rdf.BASE_IRI;\n    const beliefsTriples = _.map(beliefsPgs, (beliefPg) =>\n      Rdf.union(Rdf.graph([Rdf.triple(assertionIri, rso.PX_asserts, beliefPg.pointer)]), beliefPg.graph)\n    );\n    const assertionTimePg = createAssertionTimeSpan();\n    const triples = [\n      Rdf.triple(assertionIri, vocabularies.rdf.type, rso.EX_Assertion),\n      Rdf.triple(assertionIri, vocabularies.rdfs.label, Rdf.literal(assertion.title)),\n      Rdf.triple(assertionIri, crm.P3_has_note, Rdf.literal(assertion.note)),\n      Rdf.triple(assertionIri, rso.targetsField, Rdf.iri(assertion.field.iri)),\n      Rdf.triple(assertionIri, rso.targetsRecord, assertion.target),\n      Rdf.triple(assertionIri, crm.P14_carried_out_by, context.user),\n      Rdf.triple(assertionIri, crm.P4_has_time_span, assertionTimePg.pointer),\n      ...Rdf.union(...beliefsTriples).triples.toJS(),\n      ...assertionTimePg.graph.triples.toJS(),\n    ];\n\n    if (assertion.narrative) {\n      triples.push(Rdf.triple(assertionIri, crm.P70i_is_documented_in, assertion.narrative));\n    }\n\n    return Rdf.pg(assertionIri, Rdf.graph(triples));\n  };\n}\n\nfunction createAssertionTimeSpan(): Rdf.PointedGraph {\n  const timeIri = Rdf.iri(`/time/${uuid.v4()}`);\n  const time = moment();\n  const timeLiteral = Rdf.literal(time.toISOString(), vocabularies.xsd.dateTime);\n  const label = Rdf.literal(time.format('LL'));\n  return Rdf.pg(\n    timeIri,\n    Rdf.graph([\n      Rdf.triple(timeIri, crm.P82a_begin_of_the_begin, timeLiteral),\n      Rdf.triple(timeIri, crm.P82a_end_of_the_end, timeLiteral),\n      Rdf.triple(timeIri, rso.displayLabel, label),\n      Rdf.triple(timeIri, vocabularies.rdfs.label, label),\n    ])\n  );\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, © Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\nimport * as uuid from 'uuid';\nimport * as maybe from 'data.maybe';\nimport * as _ from 'lodash';\nimport * as SparqlJs from 'sparqljs';\n\nimport { Rdf, vocabularies } from 'platform/api/rdf';\nimport { SparqlClient, SparqlUtil } from 'platform/api/sparql';\nimport { ldpc } from 'platform/api/services/ldp';\n\nimport { crminf, rso } from 'platform/data/vocabularies/vocabularies';\nimport {\n  AssertedBelief,\n  ArgumentsBelief,\n  PropositionSet,\n  Belief,\n  matchBelief,\n  matchArgumentsBelief,\n  ArgumentsFieldBelief,\n  AssertedBeliefTypeKind,\n  ArgumentsBeliefTypeAssertionKind,\n  ArgumentsBeliefTypeFieldKind,\n} from './ArgumentsApi';\n\nexport function getBeliefGraphs(belief: Belief): Kefir.Property<Array<Rdf.PointedGraph>> {\n  return matchBelief({\n    AssertedBelief: (b) => getBeliefGraphForAssertedBelief(b).map((pg) => [pg]),\n    ArgumentsBelief: (b) => getBeliefGraphForArgumentsBelief(b),\n  })(belief);\n}\n\nfunction getBeliefGraphForAssertedBelief(belief: AssertedBelief): Kefir.Property<Rdf.PointedGraph> {\n  const beliefIri = createBeliefIri(belief);\n  return propSetForAssertedBelief(belief)\n    .flatMap((propSet) =>\n      savePropositionSet(propSet, beliefIri, belief).map((propSetIri) => serializeBelief(beliefIri, belief, propSetIri))\n    )\n    .toProperty();\n}\n\n/**\n * Premise for inference making can be only crminf:Belief or rso:EX_Assertion\n * (which contains beliefs).\n * To use other object as a premise we need to construct a belief out of it.\n * e.g in case of a digital image as a Premise we construct belief that object\n * has this image as a representation.\n */\nfunction getBeliefGraphForArgumentsBelief(belief: ArgumentsBelief): Kefir.Property<Array<Rdf.PointedGraph>> {\n  return matchArgumentsBelief({\n    AssertionBelief: (b) => getBeliefsForAssertion(b.assertion),\n    FieldBelief: (b) => getBeliefsForField(b).map((x) => [x]),\n  })(belief);\n}\n\nfunction getBeliefsForField(belief: ArgumentsFieldBelief): Kefir.Property<Rdf.PointedGraph> {\n  const beliefIri = createBeliefIri(belief);\n  return propSetForArgumentsBelief(belief)\n    .flatMap((propSet) =>\n      savePropositionSet(propSet, beliefIri, belief).map((propSetIri) => serializeBelief(beliefIri, belief, propSetIri))\n    )\n    .toProperty();\n}\n\nfunction serializeBelief(beliefIri: Rdf.Iri, belief: Belief, propSetIri: Rdf.Iri): Rdf.PointedGraph {\n  const label = createBeliefLabel(belief);\n  const triples = [\n    Rdf.triple(beliefIri, vocabularies.rdf.type, crminf.I2_Belief),\n    Rdf.triple(beliefIri, crminf.J4_that, propSetIri),\n    Rdf.triple(beliefIri, crminf.J5_holds_to_be, Rdf.literal(belief.belief.value)),\n    Rdf.triple(beliefIri, vocabularies.rdfs.label, Rdf.literal(label)),\n  ];\n\n  if (belief.beliefType === AssertedBeliefTypeKind) {\n    triples.push(\n      Rdf.triple(beliefIri, rso.PX_asserts_value, belief.targetValue),\n      Rdf.triple(beliefIri, rso.PX_is_canonical_value, Rdf.literal(belief.isCanonical))\n    );\n  } else {\n    if (belief.argumentBeliefType === ArgumentsBeliefTypeAssertionKind) {\n      triples.push(Rdf.triple(beliefIri, rso.PX_premise_assertion, belief.assertion));\n    } else {\n      triples.push(\n        Rdf.triple(beliefIri, rso.PX_premise_target, belief.target),\n        Rdf.triple(beliefIri, rso.PX_premise_field, Rdf.iri(belief.field.iri)),\n        Rdf.triple(beliefIri, rso.PX_premise_target_repository, Rdf.literal(belief.originRepository))\n      );\n    }\n  }\n\n  return Rdf.pg(beliefIri, Rdf.graph(triples));\n}\n\nfunction propSetForArgumentsBelief(belief: ArgumentsFieldBelief): Kefir.Property<PropositionSet> {\n  const query = buildQueryForArgumentsBelief(SparqlUtil.parseQuerySync<SparqlJs.Update>(belief.field.insertPattern));\n  return SparqlClient.construct(SparqlClient.setBindings(query, { subject: belief.target }));\n}\n\nfunction buildQueryForArgumentsBelief(insertQuery: SparqlJs.Update): SparqlJs.ConstructQuery {\n  const operation = insertQuery.updates[0] as SparqlJs.InsertDeleteOperation;\n  return {\n    prefixes: insertQuery.prefixes,\n    type: 'query',\n    queryType: 'CONSTRUCT',\n    template: (operation.insert as Array<SparqlJs.BgpPattern>)[0].triples,\n    where: [\n      {\n        type: 'bgp',\n        triples: (operation.insert as Array<SparqlJs.BgpPattern>)[0].triples,\n      },\n    ],\n  };\n}\n\nfunction propSetForAssertedBelief(belief: AssertedBelief): Kefir.Property<PropositionSet> {\n  const query = buildQueryForAssertedBelief(\n    SparqlUtil.parseQuerySync<SparqlJs.Update>(belief.field.insertPattern),\n    belief.isCanonical\n  );\n  return SparqlClient.construct(SparqlClient.setBindings(query, { subject: belief.target, value: belief.targetValue }));\n}\n\n/**\n * In case when user asserts new value for a field,\n * insertPattern from Field Definition is used as a construct pattern\n * for proposition set\n */\nfunction buildQueryForAssertedBelief(insertQuery: SparqlJs.Update, isCanonicalValue: boolean): SparqlJs.ConstructQuery {\n  const operation = insertQuery.updates[0] as SparqlJs.InsertDeleteOperation;\n  return {\n    prefixes: insertQuery.prefixes,\n    type: 'query',\n    queryType: 'CONSTRUCT',\n    template: (operation.insert as Array<SparqlJs.BgpPattern>)[0].triples,\n    where: isCanonicalValue ? [] : _.cloneDeep(operation.where),\n  };\n}\n\nfunction getBeliefsForAssertion(assertionIri: Rdf.Iri): Kefir.Property<Array<Rdf.PointedGraph>> {\n  // If premise is an assertion we point to the beliefs of the assertion\n  return ldpc(rso.AssertionsContainer.value)\n    .get(assertionIri)\n    .map((graph: Rdf.Graph) =>\n      _.map(Rdf.getValuesFromPropertyPath<Rdf.Iri>([rso.PX_asserts], Rdf.pg(assertionIri, graph)), (belief) =>\n        Rdf.pg(belief, Rdf.graph([Rdf.triple(belief, rso.PX_premise_assertion, assertionIri)]))\n      )\n    );\n}\n\nfunction savePropositionSet(propositions: PropositionSet, beliefIri: Rdf.Iri, belief: Belief): Kefir.Property<Rdf.Iri> {\n  const propositionSetIri = createPropositionIri(beliefIri);\n  const propositionSetGraph = serializePropSet(belief, propositions);\n  const service = ldpc(rso.PropositionsContainer.value);\n  if (belief.iri.isJust) {\n    return service.update(propositionSetIri, propositionSetGraph);\n  }\n  return service.addResource(propositionSetGraph, maybe.Just(propositionSetIri.value));\n}\n\nfunction serializePropSet(belief: Belief, proposition: PropositionSet): Rdf.Graph {\n  const propositionSetIri = Rdf.iri('');\n  return Rdf.graph([\n    Rdf.triple(propositionSetIri, vocabularies.rdf.type, crminf.I4_Proposition_Set),\n    Rdf.triple(propositionSetIri, vocabularies.rdfs.label, Rdf.literal('Proposition Set')),\n    ...proposition,\n  ]);\n}\n\nfunction createBeliefIri(belief: Belief): Rdf.Iri {\n  return belief.iri.getOrElse(Rdf.iri(`http://researchspace.org/instances/belief/${uuid.v4()}`));\n}\n\nfunction createPropositionIri(beliefIri: Rdf.Iri): Rdf.Iri {\n  return Rdf.iri(`${beliefIri.value}/proposition`);\n}\n\nexport function createBeliefLabel(belief: Belief): string {\n  // const start = belief. === 'Agree'\n  //   ? 'Agree with proposition ' : 'Disagree with proposition ';\n  // const propositionSetLabel = createPropositionSetLabel(subject, field, belief);\n  // return `${start} \"${propositionSetLabel}\"`;\n  return 'Belief';\n}\n"],"sourceRoot":""}