{"version":3,"sources":["webpack:///./src/main/web/components/semantic/chart/SemanticChart.ts","webpack:///./src/main/web/components/semantic/chart/ChartingCommons.ts","webpack:///./src/main/web/components/semantic/chart/extensions.tsx","webpack:///./src/main/web/components/semantic/chart/ChartJsRenderer.tsx"],"names":["SemanticChartConfig","DEFAULT_RENDERERS","chartjs","ChartJsRenderer","props","context","cancellation","Cancellation","query","Action","loadQueryData","config","semanticContext","querying","SparqlClient","select","onValue","queryResult","setState","isLoading","buildRendererProps","onError","errorMessage","onEnd","id","trigger","eventType","BuiltInEvents","ComponentLoaded","source","ComponentLoading","data","state","map","$property","debounce","flatMap","componentDidMount","ChartRendererExtension","loadAndUpdate","this","componentWillReceiveProps","nextProps","undefined","type","componentWillUnmount","cancelAll","buildData","fetchLabels","iris","sets","set","iri","push","points","point","key","extractKey","isIri","categories","category","getLabels","labels","mapKeys","k","value","toObject","rendererProps","componentWillUpdate","root","style","width","clientWidth","height","clientHeight","componentDidUpdate","render","createElement","Spinner","D","div","ErrorNotification","SparqlUtil","isSelectResultEmpty","TemplateItem","template","noResultTemplate","renderers","get","renderer","provider","rootProps","className","selectedType","ref","children","CLASS_NAME","builtData","Component","dataPoints","results","bindings","dataSets","multiDataSet","_","node","dataSetVariable","name","isLiteral","mapping","uniqBy","sortBy","dataSetIRI","Rdf","dataSetName","isNumericXScale","some","Boolean","isPieLikeChart","filter","isSetContainsPoint","valueExists","buildCategorialDataInPlace","groupedByKey","categoryString","toString","groupedPoints","pointsAtKey","find","SemanticChart","DataSetMappings","ChartType","ProviderSpecificStyle","DataSet","extractValue","y","propertyValue","property","Nothing","labeled","label","x","isUndefined","isNull","parseNumeric","num","parseFloat","Number","isNaN","Just","TOOLTIP_ID","DEFAULT_TOOLTIP_MARKUP","ExtensionPoint","CHART_TYPE_MAPPING","line","Line","bar","Bar","radar","Radar","pie","Pie","donut","Doughnut","bubble","Bubble","redrawChart","onChartMount","chart","onTooltipHide","tooltip","updateTooltip","model","existing","disableTooltips","caretX","caretY","opacity","hovering","popoverSide","arrowAlignment","yAlign","xAlign","chartInstance","offsetLeft","offsetTop","mapped","makeTooltip","p","setIndex","datasetIndex","pointIndex","index","targetLeft","targetTop","hiddenCategories","Immutable","Set","mapCircularData","length","datasets","options","firstSet","chartLabels","getOrElse","backgroundColor","color","getDefaultColor","defaultPalette","legendOptions","meta","getDatasetMeta","items","Chart","defaults","doughnut","legend","generateLabels","forEach","i","hidden","has","event","item","onClick","call","refs","relation","markerStyle","mapCategorialData","mapSingleCategorialSet","mapMultipleCategorialSets","chartType","merge","scales","xAxes","ticks","autoSkip","yAxes","beginAtZero","scale","displayedCategories","displayedIndices","displayedIndicesSet","dataset","chain","z","r","borderWidth","fillColors","borderColors","barDataset","borderColor","fill","pointRadius","pointHitRadius","pointBackgroundColor","chartData","singleCategorialSetLegendOptions","legendItems","categoryIndex","text","fillStyle","wasHidden","remove","add","updateVisibility","getLinearSeriesDefaultStyle","mapNumericalData","position","isXYChart","isCategorialChart","Error","specificStyle","styles","optionsOverride","responsive","maintainAspectRatio","tooltips","enabled","mode","custom","generatedConfig","dimensions","redraw","React","TargetedPopover","onHide","tooltipTemplate","fillOpacity","pointBorderColor","pointHoverBackgroundColor","pointHoverBorderColor"],"mappings":"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","file":"semantic-chart-2622d1519c286f9abe0a.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { createElement, Props } from 'react';\nimport * as D from 'react-dom-factories';\nimport { Dictionary, find } from 'lodash';\nimport * as Kefir from 'kefir';\nimport * as _ from 'lodash';\n\nimport { Cancellation } from 'platform/api/async';\nimport { Component } from 'platform/api/components';\nimport { BuiltInEvents, trigger } from 'platform/api/events';\nimport { Rdf } from 'platform/api/rdf';\nimport { SparqlClient, SparqlUtil } from 'platform/api/sparql';\nimport { getLabels } from 'platform/api/services/resource-label';\n\nimport { Action } from 'platform/components/utils';\nimport { ErrorNotification } from 'platform/components/ui/notification';\nimport { Spinner } from 'platform/components/ui/spinner';\nimport { TemplateItem } from 'platform/components/ui/template';\n\nimport { ChartRendererExtension, ChartRenderers } from './extensions';\n\nimport {\n  ChartType,\n  SemanticChartConfig,\n  DataPoint,\n  DataSet,\n  BuiltData,\n  ChartRenderer,\n  extractKey,\n  valueExists,\n  isSetContainsPoint,\n} from './ChartingCommons';\nimport { ChartJsRenderer } from './ChartJsRenderer';\n\nimport './SemanticChart.scss';\n\nexport type SemanticChartProps = SemanticChartConfig & Props<SemanticChart>;\n\ninterface State {\n  selectedType?: ChartType;\n  queryResult?: SparqlClient.SparqlSelectResult;\n  rendererProps?: {\n    config: SemanticChartConfig;\n    data: BuiltData;\n    labels: Dictionary<string>;\n  };\n  errorMessage?: string;\n  isLoading?: boolean;\n}\n\nconst DEFAULT_RENDERERS: ChartRenderers = {\n  chartjs: ChartJsRenderer,\n};\n\nconst CLASS_NAME = 'semantic-chart';\n\nexport class SemanticChart extends Component<SemanticChartProps, State> {\n  private readonly cancellation = new Cancellation();\n  private query = Action<SemanticChartProps>();\n\n  private root: HTMLElement;\n\n  constructor(props: SemanticChartProps, context: any) {\n    super(props, context);\n    this.state = {\n      isLoading: true,\n    };\n    this.cancellation\n      .map(this.query.$property.debounce(300))\n      .flatMap(this.loadQueryData)\n      .onValue(() => {\n        /**/\n      });\n  }\n\n  componentDidMount() {\n    ChartRendererExtension.loadAndUpdate(this, this.cancellation);\n    this.query(this.props);\n  }\n\n  componentWillReceiveProps(nextProps: SemanticChartProps) {\n    if (nextProps.query !== this.props.query) {\n      this.setState({ isLoading: true, errorMessage: undefined });\n      this.query(nextProps);\n    } else if (nextProps.type !== this.props.type) {\n      if (this.state.queryResult) {\n        this.buildRendererProps(nextProps, this.state.queryResult);\n      } else {\n        this.query(nextProps);\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    this.cancellation.cancelAll();\n  }\n\n  private loadQueryData = (config: SemanticChartConfig) => {\n    const context = this.context.semanticContext;\n    const querying = SparqlClient.select(config.query, { context });\n    querying.onValue((queryResult) => {\n      this.setState({\n        queryResult: queryResult,\n        isLoading: false,\n      });\n      this.buildRendererProps(config, queryResult);\n    });\n    querying.onError((errorMessage) => {\n      this.setState({\n        errorMessage: errorMessage,\n        isLoading: false,\n      });\n    });\n    querying.onEnd(() => {\n      if (this.props.id) {\n        trigger({ eventType: BuiltInEvents.ComponentLoaded, source: this.props.id });\n      }\n    });\n\n    if (this.props.id) {\n      trigger({\n        eventType: BuiltInEvents.ComponentLoading,\n        source: this.props.id,\n        data: querying,\n      });\n    }\n    return querying;\n  };\n\n  buildRendererProps(config: SemanticChartConfig, queryResult: SparqlClient.SparqlSelectResult) {\n    const data = buildData(config, queryResult);\n    fetchLabels(data)\n      .onValue((labels) => {\n        this.setState({\n          queryResult,\n          rendererProps: { config, data, labels },\n          errorMessage: undefined,\n          isLoading: false,\n        });\n      })\n      .onError((errorMessage) => {\n        this.setState({\n          queryResult,\n          rendererProps: undefined,\n          errorMessage,\n          isLoading: false,\n        });\n      });\n  }\n\n  componentWillUpdate() {\n    if (this.root) {\n      // preserve chart's dimensions when switching chart type\n      this.root.style.width = this.root.clientWidth + 'px';\n      this.root.style.height = this.root.clientHeight + 'px';\n    }\n  }\n\n  componentDidUpdate() {\n    if (this.root) {\n      this.root.style.width = null;\n      this.root.style.height = null;\n    }\n  }\n\n  render() {\n    if (ChartRendererExtension.isLoading() || this.state.isLoading) {\n      return createElement(Spinner);\n    } else if (this.state.errorMessage) {\n      return D.div({}, createElement(ErrorNotification, { errorMessage: this.state.errorMessage }));\n    } else if (this.state.rendererProps) {\n      if (SparqlUtil.isSelectResultEmpty(this.state.queryResult)) {\n        return createElement(TemplateItem, { template: { source: this.props.noResultTemplate } });\n      }\n\n      const config = this.state.rendererProps.config;\n      const renderers: ChartRenderers = {\n        ...DEFAULT_RENDERERS,\n        ...ChartRendererExtension.get(),\n      };\n      const renderer = renderers[config.provider] || renderers['chartjs'];\n\n      const rootProps = {\n        className: CLASS_NAME,\n        'data-type': this.state.selectedType,\n        ref: (root) => {\n          this.root = root;\n        },\n      };\n      return D.div(\n        rootProps,\n        this.props.children,\n        createElement(renderer, {\n          className: `${CLASS_NAME}__renderer`,\n          config,\n          builtData: this.state.rendererProps.data,\n          labels: this.state.rendererProps.labels,\n        })\n      );\n    } else {\n      return D.div({ className: CLASS_NAME }, this.props.children);\n    }\n  }\n}\n\nexport function buildData(config: SemanticChartConfig, queryResult: SparqlClient.SparqlSelectResult): BuiltData {\n  const dataPoints = queryResult.results.bindings;\n\n  const dataSets: DataSet[] = config.multiDataSet\n    ? _(dataPoints)\n        .map((point) => {\n          const node = point[config.multiDataSet.dataSetVariable];\n          return {\n            id: node.value,\n            iri: node.isIri() ? node : null,\n            name: node.isLiteral() ? node.value : null,\n            mapping: config.multiDataSet,\n          };\n        })\n        .uniqBy((set) => set.id)\n        .sortBy((set) => set.id)\n        .value()\n    : config.sets.map((set) => {\n        return {\n          mapping: set,\n          iri: typeof set.dataSetIRI === 'string' ? Rdf.iri(set.dataSetIRI) : set.dataSetIRI,\n          name: set.dataSetName,\n        };\n      });\n\n  const isNumericXScale =\n    (config.type === 'line' || config.type === 'bubble') && !dataSets.some((set) => Boolean(set.mapping.category));\n  const isPieLikeChart = config.type === 'pie' || config.type === 'donut';\n\n  if (isNumericXScale || isPieLikeChart) {\n    for (const set of dataSets) {\n      set.points = dataPoints.filter((point) => isSetContainsPoint(set, point) && valueExists(set, point));\n    }\n    return { sets: dataSets };\n  } else {\n    return buildCategorialDataInPlace(dataPoints, dataSets);\n  }\n}\n\nfunction buildCategorialDataInPlace(dataPoints: DataPoint[], dataSets: DataSet[]): BuiltData {\n  const categories: Rdf.Node[] = [];\n  const groupedByKey: { [key: string]: DataPoint[] } = {};\n\n  for (const set of dataSets) {\n    for (const point of dataPoints) {\n      const category = extractKey(set, point);\n      if (!category) {\n        continue;\n      }\n      const categoryString = category.toString();\n      let groupedPoints = groupedByKey[categoryString];\n      if (!groupedPoints) {\n        groupedPoints = groupedByKey[categoryString] = [];\n        categories.push(category);\n      }\n      if (isSetContainsPoint(set, point) && valueExists(set, point)) {\n        groupedPoints.push(point);\n      }\n    }\n  }\n\n  for (const set of dataSets) {\n    set.points = [];\n  }\n\n  for (const category of categories) {\n    const pointsAtKey = groupedByKey[category.toString()];\n    for (const set of dataSets) {\n      const point = find(pointsAtKey, (point) => isSetContainsPoint(set, point) && valueExists(set, point));\n      set.points.push(point ? point : null);\n    }\n  }\n\n  return { sets: dataSets, categories: categories };\n}\n\nfunction fetchLabels(data: BuiltData): Kefir.Property<Dictionary<string>> {\n  const iris: Rdf.Iri[] = [];\n  for (const set of data.sets) {\n    if (set.iri) {\n      iris.push(set.iri);\n    }\n    for (const point of set.points) {\n      if (point) {\n        const key = extractKey(set, point);\n        if (key && key.isIri()) {\n          iris.push(key);\n        }\n      }\n    }\n  }\n  if (data.categories) {\n    for (const category of data.categories) {\n      if (category.isIri()) {\n        iris.push(category);\n      }\n    }\n  }\n  return getLabels(iris).map((labels) => labels.mapKeys((k) => k.value).toObject());\n}\n\nexport { SemanticChartConfig };\nexport { DataSetMappings, ChartType, ProviderSpecificStyle, DataSet } from './ChartingCommons';\nexport default SemanticChart;\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as React from 'react';\nimport { Just, Nothing, of as maybeOf } from 'data.maybe';\nimport * as _ from 'lodash';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { SparqlClient } from 'platform/api/sparql';\n\nexport interface DataSetMappings {\n  /** Query variable to pivot on. */\n  dataSetVariable?: string;\n  /** Optional label of data set to display in legend. */\n  dataSetName?: string;\n  /**\n   * Optional IRI of data set. If specified, a label for this IRI will be fetched and displayed in legend.\n   * */\n  dataSetIRI?: string;\n  /**\n   * Determines position of data point along main axis (usually x-axis or axis around chart's center).\n   */\n  x?: string;\n  /**\n   * Determine position along cross axis (y-axis or radial axis).\n   */\n  y?: string;\n  /**\n   * Third-dimension value for 3+ dimensional data.\n   */\n  z?: string;\n  /** Same as x, but value is explicitly non-numerical. */\n  category?: string;\n  /** Same as y for two-dimensional data. */\n  value?: string;\n  /** Color of specific data point. */\n  color?: string;\n}\n\nexport type ChartProvider = 'chartjs' | 'highcharts';\n\nexport interface ProviderSpecificStyle {\n  /** Charting library identifier. */\n  provider: ChartProvider;\n\n  /**\n   * Options specific to the provider. These options will be merged with widget-generated options and specified style will override defaults.\n   * See <a href=\"https://www.chartjs.org/docs/\" target=\"_blank\">ChartJS Docs</a> and <a href=\"https://www.highcharts.com/docs/\" target=\"_blank\">Highcharts Docs</a> for further information.\n   */\n  style: any;\n}\n\nexport type ChartType = 'line' | 'bar' | 'radar' | 'pie' | 'donut' | 'bubble';\n\nexport interface ChartDimensions {\n  /**\n   * Chart width in pixels\n   */\n  width?: number;\n\n  /**\n   * Chart height in pixels\n   */\n  height?: number;\n}\n\nexport interface SemanticChartConfig {\n  /**\n   * SPARQL select query where the resulting rows correspond to one (in case of `multi-data-set`) or multiple (in case of `data-sets`) data points.\n   */\n  query: string;\n\n  /** Type of chart, specified as string */\n  type: ChartType;\n\n  /**\n   * List of plotted data sets where each specified through mapping between data points properties and query variables. (Mutually exclusive with `multi-data-sets.`)\n   */\n  sets?: DataSetMappings[];\n\n  /**\n   * Data sets specified through pivoting on variable in query and mapping between data points properties and other query variables. (Mutually exclusive with `data-sets.`)\n   */\n  multiDataSet?: DataSetMappings;\n\n  /** List of charting library-specific configurations. */\n  styles?: ProviderSpecificStyle[];\n\n  /**\n   * Chart's dimensions. If any dimension is not set, the default value provided by the charting library is used instead. In most cases the component will occupy all available space, so you should limit dimensions on enclosing HTML container tag if omitting this parameter.\n   */\n  dimensions?: ChartDimensions;\n\n  /**\n   * Charting library provider.\n   * <a target='_blank' href='http://www.chartjs.org/'>Chart.js</a> is used by default.\n   */\n  provider?: ChartProvider;\n\n  /**\n   * ID for issuing component events.\n   */\n  id?: string;\n\n  /**\n   * Disables chart tooltips.\n   */\n  disableTooltips?: boolean;\n\n  /**\n   * <semantic-link iri='http://help.researchspace.org/resource/FrontendTemplating'>Template</semantic-link> which is applied when query returns no results.\n   */\n  noResultTemplate?: string;\n\n  /**\n   * <semantic-link iri='http://help.researchspace.org/resource/FrontendTemplating'>Template</semantic-link> which is applied to render tooltip for chart points; the following properies are provided:\n   * <mp-documentation type=\"ChartTooltipData\"></mp-documentation>\n   */\n  tooltipTemplate?: string;\n}\n\nexport type DataPoint = SparqlClient.Binding;\n\nexport interface DataSet {\n  id?: string;\n  iri?: Rdf.Iri;\n  name?: string;\n  mapping: DataSetMappings;\n  points?: DataPoint[];\n}\n\nexport interface BuiltData {\n  sets: DataSet[];\n  categories?: Rdf.Node[];\n}\n\nexport function propertyValue(point: DataPoint, property: string): Data.Maybe<string> {\n  return point && point[property] ? maybeOf(point[property].value) : Nothing<string>();\n}\n\nexport function labeled(node: Rdf.Node, labels: _.Dictionary<string>): string {\n  if (!node) {\n    return '';\n  }\n  if (node.isIri()) {\n    const label = labels[node.value];\n    if (label) {\n      return label;\n    }\n  }\n  return node.value;\n}\n\nexport function extractKey(set: DataSet, point: DataPoint): Rdf.Node {\n  return point[set.mapping.category || set.mapping.x];\n}\n\nexport function extractValue(set: DataSet, point: DataPoint): Rdf.Node {\n  return point[set.mapping.value || set.mapping.y];\n}\n\nexport function valueExists(set: DataSet, point: DataPoint): boolean {\n  const value = extractValue(set, point);\n  return !_.isUndefined(value) && !_.isNull(value);\n}\n\nexport function isSetContainsPoint(set: DataSet, point: DataPoint) {\n  return !set.id || point[set.mapping.dataSetVariable].value === set.id;\n}\n\nexport interface ChartRendererProps {\n  className?: string;\n  builtData: BuiltData;\n  labels: _.Dictionary<string>;\n  config: SemanticChartConfig;\n}\n\nexport interface ChartRenderer {\n  new (props: ChartRendererProps): React.Component<ChartRendererProps, any>;\n}\n\nexport function parseNumeric(value: string | undefined): Data.Maybe<number> {\n  const num = parseFloat(value);\n  return Number.isNaN(num) ? Nothing<number>() : Just(num);\n}\n\nexport interface ChartTooltipData {\n  /**\n   * Non-numerical value for argument axis (usually x-axis) at selected data points,\n   * e.g. labels of pie chart segement or bar chart column; may be empty.\n   */\n  category?: {\n    /**\n     * Category IRI (as plain string); may be empty.\n     */\n    iri?: string;\n    /**\n     * Category label.\n     */\n    label: string;\n    /**\n     * Style string for SVG shape to display category color; may be empty.\n     * (Provided by ChartJs.)\n     */\n    markerStyle?: string;\n    /**\n     * CSS class for SVG shape to display category color; may be empty.\n     * (Provided by Highcharts.)\n     */\n    markerClass?: string;\n  };\n  /**\n   * Numerical values for value axes (usually y-axis, z-axis, etc) at selected data points.\n   */\n  points: ReadonlyArray<ChartTooltipPoint>;\n}\n\nexport interface ChartTooltipPoint {\n  /**\n   * Bindings from SPARQL query for the data point.\n   */\n  bindings: DataPoint;\n  /**\n   * Data set IRI (as plain string) for the data point; may be empty.\n   */\n  iri?: string;\n  /**\n   * Data set label for the data point.\n   */\n  label: string;\n  /**\n   * Data point value representation: either a simple number or\n   * tuple for charts with multiple numerical axes.\n   */\n  value: number | string;\n  /**\n   * Style string for SVG shape to display data set color; may be empty.\n   * (Provided by ChartJs.)\n   */\n  markerStyle?: string;\n  /**\n   * CSS class for SVG shape to display data set color; may be empty.\n   * (Provided by Highcharts.)\n   */\n  markerClass?: string;\n}\n\nexport const TOOLTIP_ID = 'mp-semantic-chart-tooltip';\nexport const DEFAULT_TOOLTIP_MARKUP = `<div>\n  {{#*inline \"@marker\"}}\n    {{#ifCond style \"||\" class}}\n      <svg xmlns=\"http://www.w3.org/2000/svg\"\n        style=\"display: inline-block; margin-right: 10px;\"\n        width=\"10\" height=\"10\">\n        <rect width=\"10\" height=\"10\"\n          style=\"{{style}}\"\n          class=\"{{class}}\" />\n      </svg>\n    {{/ifCond}}\n  {{/inline}}\n  {{#if category}}\n    <div>\n      {{> @marker style=category.markerStyle class=category.markerClass}}\n      {{#if category.iri}}\n        <semantic-link iri='{{category.iri}}'>\n          {{category.label}}\n        </semantic-link>\n      {{else}}\n        {{category.label}}\n      {{/if}}\n    </div>\n  {{/if}}\n  <ul class=\"list-unstyled\">\n    {{#each points}}\n      <li>\n        {{> @marker style=markerStyle class=markerClass}}\n        {{#if iri}}\n          <semantic-link iri=\"{{iri}}\">{{label}}</semantic-link>: {{value}}\n        {{else}}\n          {{label}}: {{value}}\n        {{/if}}\n      </li>\n    {{/each}}\n  </ul>\n</div>`;\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport { ExtensionPoint } from 'platform/api/module-loader';\n\nimport { ChartRenderer } from './ChartingCommons';\nimport { ChartJsRenderer } from './ChartJsRenderer';\n\n// Important! This module is an extension point definition or an implementation, so it\n// should limit it's imports to only base platform APIs and type definitions.\n// Otherwise every module imported here will be bundled as part of main \"app\" bundle.\n//\n// This happens due to the fact that extension point is directly referenced by the\n// implementation which in turn is directly referenced by .mp-extensions.\n// And .mp-extension is loaded eagerly because otherwise extension point won't be\n// aware about implementation existence.\n\nexport interface ChartRenderers {\n  [provider: string]: ChartRenderer;\n}\n\nexport const ChartRendererExtension = new ExtensionPoint<ChartRenderers>();\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Dictionary, merge, find } from 'lodash';\nimport * as Immutable from 'immutable';\nimport * as React from 'react';\nimport * as D from 'react-dom-factories';\nimport {\n  Chart,\n  ChartData,\n  ChartOptions,\n  LegendItem,\n  TooltipOptions,\n  TooltipModel,\n  TooltipItem,\n  ScaleOptions,\n  LinearDataSet,\n  BarDataSet,\n  CircularDataSet,\n  BubbleDataSet,\n  BubbleDataObject,\n} from 'chart.js';\nimport ChartComponent, { ChartComponentProps, Line, Bar, Radar, Pie, Doughnut, Bubble } from 'react-chartjs-2';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { TemplateItem } from 'platform/components/ui/template';\nimport { TargetedPopover, TargetedPopoverProps } from 'platform/components/ui/TargetedPopover';\n\nimport {\n  ChartType,\n  BuiltData,\n  DataPoint,\n  ChartRendererProps,\n  propertyValue,\n  labeled,\n  parseNumeric,\n  ChartTooltipData,\n  ChartTooltipPoint,\n  TOOLTIP_ID,\n  DEFAULT_TOOLTIP_MARKUP,\n} from './ChartingCommons';\n\nconst LINE_FILL_OPACITY = 0.2;\nconst BAR_FILL_OPACITY = 0.6;\nconst DEFAULT_BUBBLE_RADIUS = 10;\n\ninterface State {\n  hiddenCategories?: Immutable.Set<Rdf.Node>;\n  tooltip?: TooltipState;\n}\n\ninterface MappedOptions {\n  data: ChartData;\n  options: ChartOptions;\n  makeTooltip: (refs: ReadonlyArray<PointReference>) => ChartTooltipData;\n}\n\ninterface PointReference {\n  setIndex: number;\n  pointIndex: number;\n}\n\ninterface TooltipState {\n  hovering: boolean;\n  caretX: number;\n  caretY: number;\n  data: ChartTooltipData;\n  props: TargetedPopoverProps;\n}\n\nconst CHART_TYPE_MAPPING: Record<ChartType, any> = {\n  line: Line,\n  bar: Bar,\n  radar: Radar,\n  pie: Pie,\n  donut: Doughnut,\n  bubble: Bubble,\n};\n\n// stretch horizontally by default\nconst DEFAULT_WIDTH: number = undefined;\nconst DEFAULT_HEIGHT = 400;\n\ntype CustomLegendItem = LegendItem & { category?: Rdf.Node };\n\nexport class ChartJsRenderer extends React.Component<ChartRendererProps, State> {\n  private redrawChart = false;\n\n  private chart: ChartComponent<ChartComponentProps>;\n  private mapped: MappedOptions;\n\n  constructor(props: ChartRendererProps) {\n    super(props);\n    this.state = {\n      hiddenCategories: Immutable.Set<Rdf.Node>(),\n    };\n  }\n\n  componentWillReceiveProps(nextProps?: ChartRendererProps) {\n    if (nextProps.builtData !== this.props.builtData) {\n      this.redrawChart = true;\n    }\n  }\n\n  private mapCircularData(data: BuiltData, labels: Dictionary<string>): MappedOptions {\n    if (data.sets.length === 0) {\n      return {\n        data: { datasets: [], labels: [] },\n        options: {},\n        makeTooltip: () => ({ points: [] }),\n      };\n    }\n\n    const firstSet = data.sets[0];\n    const categories = firstSet.points.map((point) => point[firstSet.mapping.category || firstSet.mapping.x]);\n    const chartLabels = categories.map((category) => labeled(category, labels));\n    const datasets = data.sets.map<CircularDataSet>((set, setIndex) => ({\n      label: set.name || labeled(set.iri, labels),\n      data: set.points.map((point) =>\n        propertyValue(point, set.mapping.value || set.mapping.y)\n          .map(parseFloat)\n          .getOrElse(0)\n      ),\n      backgroundColor: set.points.map((point, pointIndex) =>\n        propertyValue(point, set.mapping.color).getOrElse(getDefaultColor(pointIndex))\n      ),\n    }));\n\n    let options = {};\n    let makeTooltip: MappedOptions['makeTooltip'];\n\n    if (data.sets.length === 1) {\n      options = this.legendOptions(\n        (chart) => {\n          const meta = chart.getDatasetMeta(0);\n          const items: CustomLegendItem[] = Chart.defaults.doughnut.legend.labels.generateLabels(chart);\n          categories.forEach((category, i) => {\n            const hidden = this.state.hiddenCategories.has(category);\n            items[i].category = category;\n            items[i].hidden = hidden;\n            meta.data[i].hidden = hidden;\n          });\n          return items;\n        },\n        (event, item, context) => {\n          Chart.defaults.doughnut.legend.onClick.call(context, event, item);\n        }\n      );\n      makeTooltip = (refs): ChartTooltipData => {\n        const { setIndex, pointIndex } = refs[0];\n        const set = datasets[setIndex];\n        const relation: ChartTooltipPoint = {\n          bindings: firstSet.points[pointIndex],\n          iri: firstSet.iri ? firstSet.iri.value : undefined,\n          label: set.label,\n          value: set.data[pointIndex],\n        };\n        return {\n          category: {\n            iri: categories[pointIndex].value,\n            label: chartLabels[pointIndex],\n            markerStyle: `fill: ${set.backgroundColor[pointIndex] as string}`,\n          },\n          points: [relation],\n        };\n      };\n    } else {\n      makeTooltip = (refs) => ({\n        points: refs.map(\n          ({ setIndex, pointIndex }): ChartTooltipPoint => {\n            const set = datasets[setIndex];\n            return {\n              bindings: data.sets[setIndex].points[pointIndex],\n              iri: categories[pointIndex].value,\n              label: chartLabels[pointIndex],\n              value: set.data[pointIndex],\n              markerStyle: `fill: ${set.backgroundColor[pointIndex] as string}`,\n            };\n          }\n        ),\n      });\n    }\n\n    return {\n      data: { labels: chartLabels, datasets },\n      options,\n      makeTooltip,\n    };\n  }\n\n  private mapCategorialData(data: BuiltData, labels: Dictionary<string>): MappedOptions {\n    const mapped =\n      data.sets.length === 1 ? this.mapSingleCategorialSet(data, labels) : this.mapMultipleCategorialSets(data, labels);\n\n    const chartType = this.props.config.type;\n    if (chartType === 'line' || chartType === 'bar') {\n      merge(mapped.options, {\n        scales: {\n          xAxes: [\n            {\n              ticks: { autoSkip: false },\n            },\n          ],\n          yAxes: [\n            {\n              ticks: { beginAtZero: true },\n            },\n          ],\n        },\n      });\n    } else if (chartType === 'radar') {\n      merge(mapped.options, {\n        scale: {\n          ticks: { beginAtZero: true },\n        },\n      });\n    }\n\n    return mapped;\n  }\n\n  /**\n   * Perform separate mapping for single dataset case to display\n   * different legend with a legend item for each dataset point.\n   */\n  private mapSingleCategorialSet(data: BuiltData, labels: Dictionary<string>): MappedOptions {\n    const chartType = this.props.config.type;\n    const set = data.sets[0];\n\n    const displayedCategories = data.categories\n      .map((category, index) => ({ category, index }))\n      .filter(({ category }) => !this.state.hiddenCategories.has(category));\n    const displayedIndices = displayedCategories.map(({ index }) => index);\n    const displayedIndicesSet = Immutable.Set<number>(displayedIndices);\n\n    const dataset: BarDataSet | LinearDataSet | BubbleDataSet = {\n      label: set.name || labeled(set.iri, labels),\n      data: set.points\n        .filter((point, index) => displayedIndicesSet.has(index))\n        .map((point) => {\n          const x = propertyValue(point, set.mapping.x).chain(parseNumeric);\n          const y = propertyValue(point, set.mapping.y || set.mapping.value).chain(parseNumeric);\n          const z = propertyValue(point, set.mapping.z).chain(parseNumeric);\n          if (chartType === 'bubble') {\n            return { x: x.getOrElse(0), y: y.getOrElse(0), r: z.getOrElse(DEFAULT_BUBBLE_RADIUS) };\n          } else {\n            return y.getOrElse(null);\n          }\n        }) as number[] | BubbleDataObject[],\n      borderWidth: 1,\n    };\n\n    const fillColors = displayedIndices.map((i) => defaultPalette(i, BAR_FILL_OPACITY));\n    const borderColors = displayedIndices.map((i) => defaultPalette(i, 1));\n    if (chartType === 'bar' || chartType === 'bubble') {\n      const barDataset = dataset as BarDataSet | BubbleDataSet;\n      barDataset.backgroundColor = fillColors;\n      barDataset.borderColor = borderColors;\n    } else {\n      merge(dataset, singleLinearDatasetStyle());\n      (dataset as LinearDataSet).pointBackgroundColor = borderColors;\n    }\n\n    const chartData = {\n      labels: displayedCategories.map(({ category }) => labeled(category, labels)),\n      datasets: [dataset],\n    };\n\n    type Point = number | { x: number; y: number; r?: number };\n\n    return {\n      data: chartData,\n      options: this.singleCategorialSetLegendOptions(data, labels),\n      makeTooltip: (refs): ChartTooltipData => {\n        const { pointIndex } = refs[0];\n        const point: Point = dataset.data[pointIndex];\n        const relation: ChartTooltipPoint = {\n          bindings: set.points[pointIndex],\n          iri: set.iri ? set.iri.value : undefined,\n          label: dataset.label,\n          value:\n            typeof point === 'number'\n              ? point\n              : typeof point.r === 'number'\n              ? `(${point.x}, ${point.y}, ${point.r})`\n              : `(${point.x}, ${point.y})`,\n        };\n        return {\n          category: {\n            iri: displayedCategories[pointIndex].category.value,\n            label: chartData.labels[pointIndex],\n            markerStyle: `fill: ${borderColors[pointIndex]}`,\n          },\n          points: [relation],\n        };\n      },\n    };\n  }\n\n  private singleCategorialSetLegendOptions(data: BuiltData, labels: Dictionary<string>): ChartOptions {\n    const legendItems = data.categories.map(\n      (category, categoryIndex): CustomLegendItem => {\n        return {\n          text: labeled(category, labels),\n          fillStyle: defaultPalette(categoryIndex, BAR_FILL_OPACITY),\n          hidden: this.state.hiddenCategories.has(category),\n          category,\n        };\n      }\n    );\n    return this.legendOptions(\n      (chart) => legendItems,\n      (event, item) => {\n        item.hidden = !item.hidden;\n      }\n    );\n  }\n\n  private legendOptions(\n    generateLabels: (chart: Chart) => CustomLegendItem[],\n    onClick: (event: any, item: CustomLegendItem, context: any) => void\n  ): ChartOptions {\n    const updateVisibility = (category: Rdf.Node, wasHidden: boolean) => {\n      this.setState({\n        hiddenCategories: wasHidden\n          ? this.state.hiddenCategories.remove(category)\n          : this.state.hiddenCategories.add(category),\n      });\n    };\n    return {\n      legend: {\n        labels: { generateLabels },\n        onClick: function (this: any, event: any, item: CustomLegendItem) {\n          const wasHidden = item.hidden;\n          onClick(event, item, this);\n          updateVisibility(item.category, wasHidden);\n        },\n      },\n    };\n  }\n\n  private mapMultipleCategorialSets(data: BuiltData, labels: Dictionary<string>): MappedOptions {\n    const chartData = {\n      labels: data.categories.map((category) => labeled(category, labels)),\n      datasets: data.sets.map((set, setIndex) => {\n        const style = getLinearSeriesDefaultStyle(\n          setIndex,\n          this.props.config.type === 'bar' ? BAR_FILL_OPACITY : LINE_FILL_OPACITY\n        );\n        const dataSet: BarDataSet & LinearDataSet = merge(\n          {\n            label: set.name || labeled(set.iri, labels),\n            data: set.points.map((point) =>\n              propertyValue(point, set.mapping.value || set.mapping.y)\n                .map(parseFloat)\n                .getOrElse(0)\n            ),\n          },\n          style\n        );\n        return dataSet;\n      }),\n    };\n    return {\n      data: chartData,\n      options: {},\n      makeTooltip: (refs): ChartTooltipData => {\n        const { pointIndex } = refs[0];\n        return {\n          category: {\n            iri: data.categories[pointIndex].value,\n            label: chartData.labels[pointIndex],\n          },\n          points: refs.map(\n            ({ setIndex, pointIndex }): ChartTooltipPoint => {\n              const source = data.sets[setIndex];\n              const mapped = chartData.datasets[setIndex];\n              return {\n                bindings: source.points[pointIndex],\n                iri: source.iri ? source.iri.value : undefined,\n                label: mapped.label,\n                value: mapped.data[pointIndex],\n                markerStyle: `fill: ${mapped.borderColor as string}`,\n              };\n            }\n          ),\n        };\n      },\n    };\n  }\n\n  private mapNumericalData(data: BuiltData, labels: Dictionary<string>): MappedOptions {\n    type MappedPoint = { x: number; y: number; r?: number };\n    const datasets = data.sets.map((set, setIndex) => {\n      const dataset: LinearDataSet = {\n        label: set.name || labeled(set.iri, labels),\n        data: set.points.map((point): MappedPoint | null => {\n          const x = propertyValue(point, set.mapping.x || set.mapping.category).chain(parseNumeric);\n          const y = propertyValue(point, set.mapping.y || set.mapping.value).chain(parseNumeric);\n          return {\n            x: x.getOrElse(0),\n            y: y.getOrElse(0),\n            r: propertyValue(point, set.mapping.z).chain(parseNumeric).getOrElse(DEFAULT_BUBBLE_RADIUS),\n          };\n        }),\n      };\n      return merge(\n        dataset,\n        getLinearSeriesDefaultStyle(setIndex, this.props.config.type === 'bar' ? BAR_FILL_OPACITY : LINE_FILL_OPACITY)\n      );\n    });\n    const options =\n      this.props.config.type === 'line'\n        ? {\n            scales: {\n              xAxes: [{ type: 'linear', position: 'bottom' } as ScaleOptions],\n            },\n          }\n        : {};\n    return {\n      data: { datasets },\n      options,\n      makeTooltip: (refs) => ({\n        points: refs.map(\n          ({ setIndex, pointIndex }): ChartTooltipPoint => {\n            const source = data.sets[setIndex];\n            const mapped = datasets[setIndex];\n            const point = mapped.data[pointIndex] as MappedPoint;\n            return {\n              bindings: source.points[pointIndex],\n              iri: source.iri ? source.iri.value : undefined,\n              label: mapped.label,\n              value: typeof point.r === 'number' ? `(${point.x},${point.y},${point.r})` : `(${point.x},${point.y})`,\n              markerStyle: `fill: ${mapped.borderColor as string}`,\n            };\n          }\n        ),\n      }),\n    };\n  }\n\n  render() {\n    const { config, builtData, labels } = this.props;\n    const { tooltip } = this.state;\n\n    const isXYChart = config.type === 'line' || config.type === 'bubble';\n    const isCategorialChart = config.type === 'bar' || config.type === 'radar';\n    const isCircularChart = config.type === 'pie' || config.type === 'donut';\n\n    let mapped: MappedOptions;\n    if (isCircularChart) {\n      mapped = this.mapCircularData(builtData, labels);\n    } else if (isCategorialChart || (isXYChart && builtData.categories)) {\n      mapped = this.mapCategorialData(builtData, labels);\n    } else if (isXYChart && !builtData.categories) {\n      mapped = this.mapNumericalData(builtData, labels);\n    } else {\n      throw Error(`Unsupported chart type '${config.type}'`);\n    }\n\n    this.mapped = mapped;\n    const { data, options } = mapped;\n\n    const specificStyle = find(config.styles, (style) => style.provider === 'chartjs');\n    const tooltipOptions: TooltipOptions = {\n      enabled: false,\n      mode: 'index',\n      position: 'nearest',\n      custom: this.updateTooltip,\n    };\n    const optionsOverride: ChartOptions = {\n      responsive: true,\n      maintainAspectRatio: false,\n      tooltips: tooltipOptions,\n    };\n    const generatedConfig: ChartComponentProps = {\n      data: data,\n      options: merge(options, optionsOverride),\n      width: !config.dimensions || config.dimensions.width === 0 ? DEFAULT_WIDTH : config.dimensions.width,\n      height: !config.dimensions || config.dimensions.height === 0 ? DEFAULT_HEIGHT : config.dimensions.height,\n    };\n\n    if (specificStyle && specificStyle.style) {\n      merge(generatedConfig, specificStyle.style);\n    }\n\n    // redraw chart on BuiltData change to correctly update chart legend\n    if (this.redrawChart) {\n      generatedConfig.redraw = true;\n      this.redrawChart = false;\n    }\n\n    return (\n      <div\n        className={this.props.className}\n        style={{\n          width: generatedConfig.width,\n          height: generatedConfig.height,\n        }}\n      >\n        {React.createElement(CHART_TYPE_MAPPING[config.type], { ...generatedConfig, ref: this.onChartMount })}\n        {tooltip ? (\n          <TargetedPopover\n            key={`${tooltip.caretX};${tooltip.caretY}`}\n            onHide={tooltip.hovering ? undefined : this.onTooltipHide}\n            {...tooltip.props}\n          >\n            <TemplateItem\n              template={{\n                source: config.tooltipTemplate || DEFAULT_TOOLTIP_MARKUP,\n                options: tooltip.data,\n              }}\n            />\n          </TargetedPopover>\n        ) : null}\n      </div>\n    );\n  }\n\n  private onChartMount = (chart: ChartComponent<ChartComponentProps>) => {\n    this.chart = chart;\n  };\n\n  private onTooltipHide = () => {\n    this.setState({ tooltip: undefined });\n  };\n\n  private updateTooltip = (model: TooltipModel) => {\n    const existing = this.state.tooltip;\n\n    if (this.props.config.disableTooltips) {\n      if (existing) {\n        this.setState({ tooltip: undefined });\n      }\n      return;\n    }\n\n    if (existing && existing.caretX === model.caretX && existing.caretY === model.caretY) {\n      if (model.opacity === 0) {\n        this.setState({ tooltip: { ...existing, hovering: false } });\n      } else if (!existing.hovering) {\n        this.setState({ tooltip: { ...existing, hovering: true } });\n      }\n      return;\n    }\n\n    if (model.opacity === 0) {\n      return;\n    }\n\n    const mapAlignment = (chartJsAlignment: string) => {\n      switch (model.xAlign) {\n        case 'left':\n          return 'right';\n        case 'right':\n          return 'left';\n        case 'center':\n          return 'center';\n      }\n    };\n\n    let popoverSide: TargetedPopoverProps['popoverSide'];\n    let arrowAlignment: TargetedPopoverProps['arrowAlignment'];\n\n    switch (model.yAlign) {\n      case 'top':\n        popoverSide = 'bottom';\n        arrowAlignment = model.xAlign === 'left' ? 'start' : model.xAlign === 'right' ? 'end' : 'center';\n        break;\n      case 'bottom':\n        popoverSide = 'top';\n        arrowAlignment = model.xAlign === 'left' ? 'start' : model.xAlign === 'right' ? 'end' : 'center';\n        break;\n      case 'center':\n        popoverSide = model.xAlign === 'left' ? 'right' : model.xAlign === 'right' ? 'left' : 'bottom';\n        arrowAlignment = 'center';\n        break;\n    }\n\n    const chart = this.chart.chartInstance;\n    const { offsetLeft, offsetTop } = chart.canvas as HTMLElement;\n\n    this.setState({\n      tooltip: {\n        hovering: true,\n        caretX: model.caretX,\n        caretY: model.caretY,\n        data: this.mapped.makeTooltip(model.dataPoints.map((p) => ({ setIndex: p.datasetIndex, pointIndex: p.index }))),\n        props: {\n          id: TOOLTIP_ID,\n          targetLeft: offsetLeft + model.caretX,\n          targetTop: offsetTop + model.caretY,\n          popoverSide,\n          arrowAlignment,\n        },\n      },\n    });\n  };\n}\n\nfunction defaultPalette(index: number, opacity: number) {\n  const colorNo = index % 8;\n  const angle = colorNo * 45;\n  return `hsla(${angle},75%,70%,${opacity})`;\n}\n\nfunction getLinearSeriesDefaultStyle(index: number, fillOpacity: number) {\n  return {\n    backgroundColor: defaultPalette(index, fillOpacity),\n    borderColor: defaultPalette(index, 1),\n    borderWidth: 1,\n    pointBackgroundColor: defaultPalette(index, 1),\n    pointBorderColor: '#fff',\n    pointHoverBackgroundColor: '#fff',\n    pointHoverBorderColor: defaultPalette(index, 1),\n  };\n}\n\nfunction getDefaultColor(index: number): string {\n  return defaultPalette(index, 1);\n}\n\nfunction singleLinearDatasetStyle() {\n  return {\n    borderColor: 'lightgray',\n    fill: false,\n    pointRadius: 5,\n    pointHitRadius: 7,\n  };\n}\n"],"sourceRoot":""}