{"version":3,"sources":["webpack:///./src/main/web/components/alignment/AlignmentTool.tsx","webpack:///./src/main/web/components/alignment/ToolController.ts","webpack:///./src/main/web/components/alignment/ConfirmAlignDialog.tsx","webpack:///./src/main/web/components/alignment/MatchList.tsx","webpack:///./src/main/web/components/alignment/MatchPanel.tsx"],"names":["LoadingStatus","props","context","cancellation","Cancellation","onSourcePanelMount","panel","sourcePanel","onSourceRequestMore","path","controller","requestMore","AlignementRole","Source","onSourceExpandOrCollapse","expanded","expandOrCollapse","onSourceSelectionChanged","selection","setSelection","onSourceExpandAndScroll","node","expandAndScrollToPath","onSourceCancelExpanding","cancelExpandingToScroll","onSourceFindAligned","targetKey","state","assertLoaded","targetNode","target","forest","getFirst","getKeyPath","Target","base","onTargetPanelMount","targetPanel","onTargetRequestMore","onTargetExpandOrCollapse","onTargetExpandAndScroll","onTargetCancelExpanding","onDragStart","nodes","enqueueStateUpdate","draggedNodes","onDragEnd","undefined","onAlign","sourceNodes","targetPath","length","showAlignmentRelationDialog","params","sourceNode","onSubmit","onDialogClose","getOverlaySystem","hide","ConfirmAlignDialog","KEY","show","kind","onClose","fromKeyPath","alignNodes","alingments","map","AlignKind","NarrowerMatch","onUnalign","unalignNode","onScrollToEntry","entry","source","Node","keyOf","targetAligned","aligned","sourcePath","targetInternalNode","targetBase","loadAlignment","alignmentContainer","queries","task","service","get","Rdf","iri","graph","deserializeAlignment","flatMap","alignState","loadState","toProperty","observe","value","setState","type","Success","error","addNotification","level","message","Error","onCancelUnsaved","onSaveAlignments","metadata","alignmentState","exportAlignment","alignmentGraph","serializeAlignment","update","setSavedState","AlignmentService","semanticContext","ToolController","updateState","change","callback","getSparqlOptions","scrollToPath","role","showValidationError","Loading","componentDidMount","this","componentWillUnmount","cancelAll","render","className","style","classnames","styles","component","Spinner","matches","savedMatches","SplitPaneComponent","id","dock","minSize","Panel","leftPanel","PanelHeader","PanelBody","MatchPanel","ref","requestMoreItems","onExpandOrCollapse","onSelectionChanged","onExpandAndScrollToPath","onCancelExpandingToScroll","onFindAligned","rightPanel","targetHolder","controlHolder","controlPanel","MatchList","controlList","PanelFooter","controlToolbar","Button","disabled","bsStyle","onClick","Component","AlignmentTool","PanelState","set","mergeIn","merged","changeQueue","changeCallbacks","changingState","alignment","sourceQueries","createQueries","targetQueries","sourceModel","SparqlNodeModel","rootsQuery","childrenQuery","parentsQuery","sparqlOptions","targetModel","targetPanelModel","AlignmentNodeModel","baseModel","baseNodeQuery","nodeQuery","alignedModel","alignNodeQuery","loadedTrees","Immutable","Map","patterns","model","TreeSelection","empty","expandingToScroll","expandingCancellation","cancelled","loadedState","syncDecoratorsAndMatches","push","initalState","totalChange","computedChange","shift","enqueuedChange","resultState","changeCallback","toolState","loadingForest","forestChange","changeForest","onMoreItemsLoaded","updateNode","TreeNode","onExpandingStateChanged","highlightedPath","deriveAndCancel","loadPath","parent","hasMoreChildren","loadMoreChildren","expandPath","current","console","expandTarget","alignments","excludeFromAlignment","validate","targetIri","warn","ExactMatch","AlignmentNode","setExactMatch","addNarrowMatches","asNarrowMatch","some","result","validateAlignment","valid","sourceKey","getMatchTarget","unalignAll","dirty","groupMatches","sources","withMutations","bySources","forEach","group","match","sourceTree","mapRoot","root","decorateMatchParent","mapBottomUp","decorated","decorateMatchChildren","has","matchedTargetNode","targetTree","isAlignChild","mapNode","child","decorateAlignChild","children","decorateAlignParent","Boolean","rawPatterns","SparqlUtil","parseQuery","searchQuery","binder","IriBinder","q","sparqlQuery","serializeQuery","replacements","tryReplace","termValue","replacement","turtle","serialize","nodeToN3","QueryVisitor","OverlayDialog","title","onHide","bsSize","block","description","sourceTerm","getLabel","targetTerm","entries","computeMatchEntries","grouped","_","orderBy","MATCH_COMPARATOR","renderMatch","key","toString","relationSign","hasBeenSaved","hasIn","unsaved","scrollTo","scrollToItem","label","searchedPaths","Set","onAlignmentTreeMount","alignementTree","onSearchBadgeClick","onSearchSelectionChanged","previousPaths","leafs","List","toSet","newlySelectedPaths","filter","size","first","toArray","isLeaf","item","childrenOf","loading","hasMoreItems","onExpandedOrCollapsed","onShowNodeInfoClick","e","stopPropagation","highlightedNodes","highlightTarget","getNodePath","renderItem","renderTreeNodeRow","hideCheckboxes","selectionMode","PartialSubtrees","SingleFullSubtree","isExpanded","SemanticTreeInput","multipleSelection","onSelectionClick","alignmentTreeContainer","renderExpandToScrollMessage","LazyTreeSelector","alignmentTree","decoratorsClass","computeDecoratorsClass","alignmentNodeRow","renderTreeNode","renderIndicators","renderUnalignButton","renderFindAlignedButton","renderInfoButton","body","renderAlignedTerm","baseTerm","alignedTerm","alignKind","mode","selected","itemSelection","isSelectedSubtree","Draggable","startDraggingSelection","draggableWrapper","draggableHandle","Droppable","onDrop","onDropInto","indicators","overlay","Tooltip","OverlayTrigger","placement","classes","decoratedNodeBody","pathIndex","indexOf","isTarget","decorateHighlightLeaf","decorateHighlightParent","decorateAlignLeaf","join","scrollNotification","scrollToName","scrollSpinner","spinnerDelay","messageDelay","Infinity","cancelScrollingTo","subtrees","getSelectedSubtrees","selectionRoot","selectionPath","findExcludedChildren","unloadedNode","reachedLimit","n","equals","NodeInfoPopover","infoTemplate","trigger","rootClose","nodeInfoButton","MatchChild","unalignButton","findAlignedButton","nodeLabel","infoHeader","ResourceLink","resource","popoverProps","delegatedProps","Popover","nodeInfoPopup","TemplateItem","template","options","React"],"mappings":"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","file":"rs-alignment-tool-30b3bfd43748652718d5.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2015-2020, © Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as React from 'react';\nimport { CSSProperties } from 'react';\nimport * as classnames from 'classnames';\nimport { Button } from 'react-bootstrap';\nimport * as SparqlJs from 'sparqljs';\n\nimport { Cancellation } from 'platform/api/async';\nimport { Component } from 'platform/api/components';\nimport { getOverlaySystem } from 'platform/components/ui/overlay';\nimport { Spinner } from 'platform/components/ui/spinner';\nimport { Rdf } from 'platform/api/rdf';\n\nimport { SplitPaneComponent } from 'platform/components/ui/splitpane/SplitPaneComponent';\nimport { Panel } from 'platform/components/ui/panel/Panel';\nimport { PanelHeader } from 'platform/components/ui/panel/PanelHeader';\nimport { PanelFooter } from 'platform/components/ui/panel/PanelFooter';\nimport { PanelBody } from 'platform/components/ui/panel/PanelBody';\nimport { addNotification } from 'platform/components/ui/notification';\n\nimport { KeyPath, TreeSelection, Node } from 'platform/components/semantic/lazy-tree';\n\nimport { AlignmentNode, AlignKind } from './AlignmentNodeModel';\nimport { AlignmentService } from './AlignmentService';\nimport { ConfirmAlignDialog } from './ConfirmAlignDialog';\nimport { MatchEntry, exportAlignment, serializeAlignment, deserializeAlignment } from './Serialization';\nimport { MatchList } from './MatchList';\nimport { MatchPanel } from './MatchPanel';\nimport { ToolController, ToolState, AlignmentQueries, AlignementRole } from './ToolController';\n\nimport * as styles from './AlignmentTool.scss';\n\nexport interface AlignmentToolProps {\n  className?: string;\n  style?: CSSProperties;\n  queries: AlignmentQueries;\n  alignmentContainer: string;\n  /**\n   * Template for tree node information box.\n   *\n   * Parameters:\n   *  - `iri`: node's IRI;\n   *  - `label`: node's label.\n   */\n  infoTemplate?: string;\n}\n\nenum LoadingStatus {\n  Loading = 1,\n  Success,\n  Error,\n}\n\ntype State = { type: LoadingStatus.Loading } | SuccessState | ErrorState;\n\ninterface SuccessState extends ToolState {\n  readonly type: LoadingStatus.Success;\n}\n\ninterface ErrorState {\n  readonly type: LoadingStatus.Error;\n}\n\nexport class AlignmentTool extends Component<AlignmentToolProps, State> {\n  private readonly cancellation = new Cancellation();\n  private readonly controller: ToolController;\n\n  private readonly service: AlignmentService;\n\n  private sourcePanel: MatchPanel;\n  private targetPanel: MatchPanel;\n\n  constructor(props: AlignmentToolProps, context: any) {\n    super(props, context);\n\n    this.service = new AlignmentService(this.context.semanticContext);\n\n    this.controller = new ToolController({\n      cancellation: this.cancellation,\n      updateState: (change, callback) => {\n        this.setState(\n          (state) => change(assertLoaded(state)) as SuccessState,\n          () => callback(assertLoaded(this.state))\n        );\n      },\n      getSparqlOptions: () => ({ context: this.context.semanticContext }),\n      scrollToPath: (role: AlignementRole, path: KeyPath) => {\n        const panel = role === AlignementRole.Source ? this.sourcePanel : this.targetPanel;\n        panel.scrollToPath(path);\n      },\n      showValidationError: (message: string) => {\n        addNotification({ level: 'warning', message });\n      },\n    });\n\n    this.state = { type: LoadingStatus.Loading };\n  }\n\n  componentDidMount() {\n    this.loadAlignment();\n  }\n\n  componentWillUnmount() {\n    this.cancellation.cancelAll();\n  }\n\n  render() {\n    const { className, style } = this.props;\n    if (this.state.type === LoadingStatus.Loading) {\n      return (\n        <div className={classnames(styles.component, className)}>\n          <Spinner />\n        </div>\n      );\n    } else if (this.state.type === LoadingStatus.Error) {\n      return null;\n    } else {\n      const { source, target, draggedNodes, matches, savedMatches } = this.state;\n      return (\n        <div className={classnames(styles.component, className)} style={style}>\n          <SplitPaneComponent id=\"alignment-tool-pane\" dock={false} minSize={300}>\n            <Panel className={styles.leftPanel}>\n              <PanelHeader>\n                <div>Source</div>\n              </PanelHeader>\n              <PanelBody>\n                <MatchPanel\n                  ref={this.onSourcePanelMount}\n                  className={styles.sourcePanel}\n                  role={AlignementRole.Source}\n                  state={source}\n                  requestMoreItems={this.onSourceRequestMore}\n                  onExpandOrCollapse={this.onSourceExpandOrCollapse}\n                  onSelectionChanged={this.onSourceSelectionChanged}\n                  onExpandAndScrollToPath={this.onSourceExpandAndScroll}\n                  onCancelExpandingToScroll={this.onSourceCancelExpanding}\n                  draggedNodes={draggedNodes}\n                  onDragStart={this.onDragStart}\n                  onDragEnd={this.onDragEnd}\n                  onFindAligned={this.onSourceFindAligned}\n                />\n              </PanelBody>\n            </Panel>\n            <div className={styles.rightPanel}>\n              <Panel className={styles.targetHolder}>\n                <PanelHeader>\n                  <div>Target</div>\n                </PanelHeader>\n                <PanelBody>\n                  <MatchPanel\n                    ref={this.onTargetPanelMount}\n                    className={styles.targetPanel}\n                    role={AlignementRole.Target}\n                    state={target}\n                    requestMoreItems={this.onTargetRequestMore}\n                    onExpandOrCollapse={this.onTargetExpandOrCollapse}\n                    onExpandAndScrollToPath={this.onTargetExpandAndScroll}\n                    onCancelExpandingToScroll={this.onTargetCancelExpanding}\n                    draggedNodes={draggedNodes}\n                    onAlign={this.onAlign}\n                    onUnalign={this.onUnalign}\n                  />\n                </PanelBody>\n              </Panel>\n              <Panel className={styles.controlHolder}>\n                <PanelHeader>\n                  <div>Alignments</div>\n                </PanelHeader>\n                <PanelBody>\n                  <div className={styles.controlPanel}>\n                    <MatchList\n                      className={styles.controlList}\n                      matches={matches}\n                      savedMatches={savedMatches}\n                      onScrollToEntry={this.onScrollToEntry}\n                    />\n                  </div>\n                </PanelBody>\n                <PanelFooter>\n                  <div className={styles.controlToolbar}>\n                    <Button disabled={matches === savedMatches} bsStyle=\"danger\" onClick={this.onCancelUnsaved}>\n                      Cancel Pending\n                    </Button>\n                    <Button disabled={matches === savedMatches} bsStyle=\"success\" onClick={this.onSaveAlignments}>\n                      Save alignment\n                    </Button>\n                  </div>\n                </PanelFooter>\n              </Panel>\n            </div>\n          </SplitPaneComponent>\n        </div>\n      );\n    }\n  }\n\n  private onSourcePanelMount = (panel: MatchPanel) => {\n    this.sourcePanel = panel;\n  };\n\n  private onSourceRequestMore = (path: KeyPath) => {\n    this.controller.requestMore(AlignementRole.Source, path);\n  };\n\n  private onSourceExpandOrCollapse = (path: KeyPath, expanded: boolean) => {\n    this.controller.expandOrCollapse(AlignementRole.Source, path, expanded);\n  };\n\n  private onSourceSelectionChanged = (selection: TreeSelection<AlignmentNode>) => {\n    this.controller.setSelection(AlignementRole.Source, selection);\n  };\n\n  private onSourceExpandAndScroll = (path: KeyPath, node: Node) => {\n    this.controller.expandAndScrollToPath(AlignementRole.Source, path, node);\n  };\n\n  private onSourceCancelExpanding = () => {\n    this.controller.cancelExpandingToScroll(AlignementRole.Source);\n  };\n\n  private onSourceFindAligned = (targetKey: string) => {\n    const state = assertLoaded(this.state);\n    const targetNode = state.target.forest.getFirst(targetKey);\n    if (targetNode) {\n      const path = state.target.forest.getKeyPath(targetNode);\n      this.controller.expandAndScrollToPath(AlignementRole.Target, path, targetNode.base);\n    }\n  };\n\n  private onTargetPanelMount = (panel: MatchPanel) => {\n    this.targetPanel = panel;\n  };\n\n  private onTargetRequestMore = (path: KeyPath) => {\n    this.controller.requestMore(AlignementRole.Target, path);\n  };\n\n  private onTargetExpandOrCollapse = (path: KeyPath, expanded: boolean) => {\n    this.controller.expandOrCollapse(AlignementRole.Target, path, expanded);\n  };\n\n  private onTargetExpandAndScroll = (path: KeyPath, node: Node) => {\n    this.controller.expandAndScrollToPath(AlignementRole.Target, path, node);\n  };\n\n  private onTargetCancelExpanding = () => {\n    this.controller.cancelExpandingToScroll(AlignementRole.Target);\n  };\n\n  private onDragStart = (nodes: AlignmentNode[]) => {\n    this.controller.enqueueStateUpdate(() => ({ draggedNodes: nodes }));\n  };\n\n  private onDragEnd = () => {\n    this.controller.enqueueStateUpdate(() => ({ draggedNodes: undefined }));\n  };\n\n  private onAlign = (sourceNodes: ReadonlyArray<AlignmentNode>, targetPath: KeyPath) => {\n    if (sourceNodes.length === 0) {\n      return;\n    }\n    const state = assertLoaded(this.state);\n    if (sourceNodes.length === 1) {\n      const sourceNode = sourceNodes[0];\n      showAlignmentRelationDialog({\n        sourceNode: sourceNode.base,\n        targetNode: state.target.forest.fromKeyPath(targetPath).base,\n        onSubmit: (kind) => {\n          this.controller.alignNodes(targetPath, [{ kind, sourceNode }]);\n        },\n      });\n    } else {\n      const alingments = sourceNodes.map((sourceNode) => ({\n        sourceNode,\n        kind: AlignKind.NarrowerMatch,\n      }));\n      this.controller.alignNodes(targetPath, alingments);\n    }\n  };\n\n  private onUnalign = (path: KeyPath) => {\n    this.controller.unalignNode(path);\n  };\n\n  private onScrollToEntry = (entry: MatchEntry) => {\n    const state = assertLoaded(this.state);\n\n    const sourceNode = state.source.forest.getFirst(Node.keyOf(entry.targetAligned.aligned));\n    const sourcePath = state.source.forest.getKeyPath(sourceNode);\n    this.controller.expandAndScrollToPath(AlignementRole.Source, sourcePath, entry.targetAligned.aligned);\n\n    const targetInternalNode = entry.targetBase.base || entry.targetBase.aligned;\n    const targetNode = state.target.forest.getFirst(Node.keyOf(targetInternalNode));\n    const targetPath = state.target.forest.getKeyPath(targetNode);\n    this.controller.expandAndScrollToPath(AlignementRole.Target, targetPath, targetInternalNode);\n  };\n\n  private loadAlignment = () => {\n    const { alignmentContainer, queries } = this.props;\n\n    const task = this.service\n      .get(Rdf.iri(alignmentContainer))\n      .map((graph) => deserializeAlignment(graph))\n      .flatMap((alignState) => this.controller.loadState(queries, alignState))\n      .toProperty();\n\n    this.cancellation.map(task).observe({\n      value: (state) => this.setState({ type: LoadingStatus.Success, ...state } as SuccessState),\n      error: (error) => {\n        addNotification(\n          {\n            level: 'error',\n            message: `Failed to load alignment state.`,\n          },\n          error\n        );\n        this.setState({ type: LoadingStatus.Error });\n      },\n    });\n  };\n\n  private onCancelUnsaved = () => {\n    this.loadAlignment();\n  };\n\n  private onSaveAlignments = () => {\n    const { alignmentContainer } = this.props;\n    const { metadata, target } = assertLoaded(this.state);\n    const alignmentState = exportAlignment(target.forest, metadata);\n    const alignmentGraph = serializeAlignment(alignmentState);\n    this.cancellation.map(this.service.update(Rdf.iri(alignmentContainer), alignmentGraph)).observe({\n      value: () => {\n        addNotification({\n          level: 'success',\n          message: 'Successfully updated the alignment.',\n        });\n        this.controller.setSavedState();\n      },\n      error: (error) =>\n        addNotification(\n          {\n            level: 'error',\n            message: 'Error while updating the alignment.',\n          },\n          error\n        ),\n    });\n  };\n}\n\nfunction assertLoaded(state: State): SuccessState {\n  if (state.type !== LoadingStatus.Success) {\n    throw new Error('Cannot update state while AlignmentTool still loading');\n  }\n  return state;\n}\n\nfunction showAlignmentRelationDialog(params: {\n  sourceNode: Node;\n  targetNode: Node;\n  onSubmit: (kind: AlignKind) => void;\n}) {\n  const { sourceNode, targetNode, onSubmit } = params;\n  const onDialogClose = () => {\n    getOverlaySystem().hide(ConfirmAlignDialog.KEY);\n  };\n  const onDialogSubmit = (kind: AlignKind) => {\n    onDialogClose();\n    onSubmit(kind);\n  };\n  getOverlaySystem().show(\n    ConfirmAlignDialog.KEY,\n    <ConfirmAlignDialog\n      sourceNode={sourceNode}\n      targetNode={targetNode}\n      onSubmit={onDialogSubmit}\n      onClose={onDialogClose}\n    />\n  );\n}\n\nexport default AlignmentTool;\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, © Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\nimport * as Immutable from 'immutable';\nimport * as SparqlJs from 'sparqljs';\n\nimport { Cancellation } from 'platform/api/async';\nimport { Rdf, turtle } from 'platform/api/rdf';\nimport { SparqlClient, SparqlUtil, QueryVisitor } from 'platform/api/sparql';\n\nimport {\n  ComplexTreePatterns,\n  KeyedForest,\n  KeyPath,\n  SparqlNodeModel,\n  TreeSelection,\n  TreeNode,\n  Node,\n  queryMoreChildren,\n  loadPath,\n  expandPath,\n  mapBottomUp,\n} from 'platform/components/semantic/lazy-tree';\n\nimport {\n  AlignmentNode,\n  AlignKind,\n  AlignmentNodeModel,\n  AlignmentState,\n  AlignmentMetadata,\n  asNarrowMatch,\n  unalignAll,\n  validateAlignment,\n} from './AlignmentNodeModel';\nimport { MatchEntry, groupMatches } from './Serialization';\n\nexport interface AlignmentQueries extends ComplexTreePatterns {\n  /**\n   * Node info query with [?item] inputs through VALUES(...) clause\n   * and [?item, ?label, ?hasChildren] output variables.\n   */\n  readonly nodeQuery: string;\n}\n\nexport interface ToolState {\n  readonly source: PanelState;\n  readonly target: PanelState;\n  readonly savedMatches: Immutable.Map<string, Immutable.Map<string, MatchEntry>>;\n  readonly matches: Immutable.Map<string, Immutable.Map<string, MatchEntry>>;\n  readonly metadata: AlignmentMetadata;\n  readonly draggedNodes?: ReadonlyArray<AlignmentNode>;\n}\n\nexport enum AlignementRole {\n  Source = 1,\n  Target,\n}\n\nexport interface PanelState {\n  readonly queries: ParsedQueries;\n  readonly patterns: ComplexTreePatterns;\n  readonly model: AlignmentNodeModel;\n  readonly forest: KeyedForest<AlignmentNode>;\n  readonly selection: TreeSelection<AlignmentNode>;\n  readonly expandingToScroll: boolean;\n  readonly expandingCancellation: Cancellation;\n  readonly expandTarget?: Node;\n  readonly highlightedPath?: KeyPath;\n}\nexport namespace PanelState {\n  export function get(state: ToolState, role: AlignementRole): PanelState {\n    return role === AlignementRole.Source ? state.source : state.target;\n  }\n\n  export function set(state: PanelState, change: Partial<PanelState>): PanelState {\n    return { ...state, ...change };\n  }\n\n  export function mergeIn(state: ToolState, role: AlignementRole, change: Partial<PanelState>): Partial<ToolState> {\n    const previous = get(state, role);\n    const merged = set(previous, change);\n    return role === AlignementRole.Source ? { source: merged } : { target: merged };\n  }\n}\n\nexport interface ParsedQueries {\n  rootsQuery: SparqlJs.SelectQuery;\n  childrenQuery: SparqlJs.SelectQuery;\n  parentsQuery: SparqlJs.SelectQuery;\n  searchQuery: SparqlJs.SelectQuery;\n}\n\nexport type StateChanger = (change: StateChange, callback?: (result: ToolState) => void) => void;\nexport type StateChange = (state: ToolState) => Partial<ToolState> | null;\n\nexport class ToolController {\n  private readonly cancellation: Cancellation;\n  private readonly updateState: StateChanger;\n  private readonly getSparqlOptions: () => SparqlClient.SparqlOptions;\n  private readonly scrollToPath: (role: AlignementRole, path: KeyPath) => void;\n  private readonly showValidationError: (message: string) => void;\n\n  private changeQueue: StateChange[] = [];\n  private changeCallbacks: Array<(result: ToolState) => void> = [];\n  private changingState = false;\n\n  constructor(params: {\n    cancellation: Cancellation;\n    updateState: StateChanger;\n    getSparqlOptions: () => SparqlClient.SparqlOptions;\n    scrollToPath: (role: AlignementRole, path: KeyPath) => void;\n    showValidationError: (message: string) => void;\n  }) {\n    this.cancellation = params.cancellation;\n    this.updateState = params.updateState;\n    this.getSparqlOptions = params.getSparqlOptions;\n    this.scrollToPath = params.scrollToPath;\n    this.showValidationError = params.showValidationError;\n  }\n\n  loadState(queries: AlignmentQueries, alignment: AlignmentState): Kefir.Property<ToolState> {\n    const { source, target } = alignment.metadata;\n    const sourceQueries = createQueries(queries, source);\n    const targetQueries = createQueries(queries, target);\n\n    const sourceModel = new SparqlNodeModel({\n      rootsQuery: sourceQueries.queries.rootsQuery,\n      childrenQuery: sourceQueries.queries.childrenQuery,\n      parentsQuery: sourceQueries.queries.parentsQuery,\n      sparqlOptions: this.getSparqlOptions,\n    });\n    const targetModel = new SparqlNodeModel({\n      rootsQuery: targetQueries.queries.rootsQuery,\n      childrenQuery: targetQueries.queries.childrenQuery,\n      parentsQuery: targetQueries.queries.parentsQuery,\n      sparqlOptions: this.getSparqlOptions,\n    });\n\n    const targetPanelModel = new AlignmentNodeModel({\n      baseModel: targetModel,\n      baseNodeQuery: targetQueries.nodeQuery,\n      alignedModel: sourceModel,\n      alignNodeQuery: sourceQueries.nodeQuery,\n    });\n\n    return targetPanelModel.loadState(alignment).map((loadedTrees) => {\n      const matches = Immutable.Map<string, Immutable.Map<string, MatchEntry>>();\n      const state: ToolState = {\n        metadata: alignment.metadata,\n        source: {\n          queries: sourceQueries.queries,\n          patterns: sourceQueries.patterns,\n          model: new AlignmentNodeModel({\n            baseModel: sourceModel,\n            alignedModel: targetModel,\n          }),\n          forest: loadedTrees.source,\n          selection: TreeSelection.empty(loadedTrees.source),\n          expandingToScroll: false,\n          expandingCancellation: Cancellation.cancelled,\n        },\n        target: {\n          queries: targetQueries.queries,\n          patterns: targetQueries.patterns,\n          model: targetPanelModel,\n          forest: loadedTrees.target,\n          selection: TreeSelection.empty(loadedTrees.target),\n          expandingToScroll: false,\n          expandingCancellation: Cancellation.cancelled,\n        },\n        matches: matches,\n        savedMatches: matches,\n      };\n\n      const loadedState = syncDecoratorsAndMatches(state);\n      const decorated: ToolState = { ...state, ...loadedState, savedMatches: loadedState.matches };\n      return decorated;\n    });\n  }\n\n  enqueueStateUpdate(change: StateChange, callback?: (result: ToolState) => void) {\n    this.changeQueue.push(change);\n    if (callback) {\n      this.changeCallbacks.push(callback);\n    }\n\n    if (this.changingState) {\n      return;\n    }\n\n    this.updateState(\n      (initalState) => {\n        let totalChange: Partial<ToolState> = null;\n        while (this.changeQueue.length > 0) {\n          const enqueuedChange = this.changeQueue.shift();\n          const computedChange = enqueuedChange({ ...initalState, ...totalChange });\n          if (computedChange !== undefined && computedChange !== null) {\n            totalChange = { ...totalChange, ...computedChange };\n          }\n        }\n        return totalChange;\n      },\n      (resultState) => {\n        while (this.changeCallbacks.length > 0) {\n          const changeCallback = this.changeCallbacks.shift();\n          changeCallback(resultState);\n        }\n      }\n    );\n  }\n\n  requestMore(role: AlignementRole, path: KeyPath) {\n    this.enqueueStateUpdate((toolState) => {\n      const { model, forest } = PanelState.get(toolState, role);\n      const [loadingForest, forestChange] = queryMoreChildren((parent) => model.loadMoreChildren(parent), forest, path);\n      this.cancellation.map(forestChange).observe({\n        value: (changeForest) => {\n          this.onMoreItemsLoaded(role, changeForest);\n        },\n      });\n      return PanelState.mergeIn(toolState, role, { forest: loadingForest });\n    });\n  }\n\n  private onMoreItemsLoaded(\n    role: AlignementRole,\n    changeForest: (forest: KeyedForest<AlignmentNode>) => KeyedForest<AlignmentNode>\n  ) {\n    this.enqueueStateUpdate((toolState) => {\n      this.enqueueStateUpdate(syncDecoratorsAndMatches);\n      const { forest } = PanelState.get(toolState, role);\n      return PanelState.mergeIn(toolState, role, { forest: changeForest(forest) });\n    });\n  }\n\n  expandOrCollapse(role: AlignementRole, path: KeyPath, expanded: boolean) {\n    this.enqueueStateUpdate((toolState) => {\n      const state = PanelState.get(toolState, role);\n      const forest = state.forest.updateNode(path, (node) => TreeNode.set(node, { expanded }));\n      return PanelState.mergeIn(toolState, role, { forest });\n    });\n  }\n\n  setSelection(role: AlignementRole, selection: TreeSelection<AlignmentNode>) {\n    this.enqueueStateUpdate((toolState) => {\n      return PanelState.mergeIn(toolState, role, { selection });\n    });\n  }\n\n  expandAndScrollToPath(role: AlignementRole, path: KeyPath, target: Node) {\n    const onExpandingStateChanged = (toolState: ToolState) => {\n      const { expandingToScroll, highlightedPath } = PanelState.get(toolState, role);\n      if (!expandingToScroll && highlightedPath) {\n        this.scrollToPath(role, highlightedPath);\n      }\n    };\n\n    this.enqueueStateUpdate((toolState) => {\n      const state = PanelState.get(toolState, role);\n      const expandingCancellation = this.cancellation.deriveAndCancel(state.expandingCancellation);\n      expandingCancellation\n        .map(\n          loadPath(\n            (parent) => state.model.hasMoreChildren(parent),\n            (parent) => state.model.loadMoreChildren(parent),\n            state.forest,\n            path\n          ).map((forest) => expandPath(forest, path))\n        )\n        .observe({\n          value: (forest) => {\n            this.enqueueStateUpdate((current) => {\n              this.enqueueStateUpdate(syncDecoratorsAndMatches);\n              return PanelState.mergeIn(current, role, {\n                forest,\n                expandingToScroll: false,\n                highlightedPath: path,\n              });\n            }, onExpandingStateChanged);\n          },\n          error: (error) => {\n            console.error(error);\n            this.enqueueStateUpdate((current) =>\n              PanelState.mergeIn(current, role, {\n                expandingToScroll: false,\n                highlightedPath: undefined,\n              })\n            );\n          },\n        });\n      return PanelState.mergeIn(toolState, role, {\n        expandingToScroll: true,\n        expandingCancellation,\n        expandTarget: target,\n      });\n    }, onExpandingStateChanged);\n  }\n\n  cancelExpandingToScroll(role: AlignementRole) {\n    this.enqueueStateUpdate((toolState) => {\n      const state = PanelState.get(toolState, role);\n      if (state.expandingToScroll) {\n        state.expandingCancellation.cancelAll();\n        return PanelState.mergeIn(toolState, role, {\n          expandingToScroll: false,\n          expandTarget: undefined,\n          highlightedPath: undefined,\n        });\n      }\n      return null;\n    });\n  }\n\n  alignNodes(\n    targetPath: KeyPath,\n    alignments: ReadonlyArray<{\n      kind: AlignKind;\n      sourceNode: AlignmentNode;\n    }>\n  ) {\n    this.enqueueStateUpdate(\n      (toolState) => {\n        const { target } = toolState;\n        let forest = target.forest;\n\n        for (const { kind, sourceNode } of alignments) {\n          const { base, excludeFromAlignment } = sourceNode;\n          if (!this.validate(target.forest, targetPath, base, kind)) {\n            const targetNode = forest.fromKeyPath(targetPath);\n            const targetIri = targetNode ? `<${forest.keyOf(targetNode)}>` : '<?>';\n            console.warn(`Invalid alignment: ${base.iri} ${AlignKind[kind]} ${targetIri}`);\n            continue;\n          }\n          if (kind === AlignKind.ExactMatch) {\n            forest = target.forest.updateNode(targetPath, (node) =>\n              AlignmentNode.setExactMatch(node, base, excludeFromAlignment)\n            );\n          } else if (kind === AlignKind.NarrowerMatch) {\n            forest = forest.updateNode(targetPath, (node) => {\n              const aligned = AlignmentNode.addNarrowMatches(node, [asNarrowMatch(base, excludeFromAlignment)]);\n              return TreeNode.set(aligned, { expanded: true });\n            });\n          } else {\n            throw new Error(`Invalid alignment relation type '${AlignKind[kind]}'`);\n          }\n        }\n\n        this.enqueueStateUpdate(syncDecoratorsAndMatches);\n        return PanelState.mergeIn(toolState, AlignementRole.Target, { forest });\n      },\n      (resultState) => {\n        const reloadTarget = alignments.some(({ kind }) => kind === AlignKind.ExactMatch);\n        if (reloadTarget) {\n          this.requestMore(AlignementRole.Target, targetPath);\n        }\n      }\n    );\n  }\n\n  private validate(forest: KeyedForest<AlignmentNode>, targetPath: KeyPath, source: Node, kind: AlignKind): boolean {\n    const result = validateAlignment(forest, targetPath, source, kind);\n    if (!result.valid) {\n      this.showValidationError(result.message);\n    }\n    return result.valid;\n  }\n\n  unalignNode(targetPath: KeyPath) {\n    this.enqueueStateUpdate((toolState) => {\n      const state = toolState.target;\n      const node = state.forest.fromKeyPath(targetPath);\n      if (!node || !node.aligned) {\n        return null;\n      }\n\n      const sourceKey = Node.keyOf(node.aligned);\n      const targetKey = Node.keyOf(AlignmentNode.getMatchTarget(node, state.forest).base);\n\n      const forest = unalignAll(state.forest, sourceKey, targetKey);\n      this.enqueueStateUpdate(syncDecoratorsAndMatches);\n      return PanelState.mergeIn(toolState, AlignementRole.Target, { forest });\n    });\n  }\n\n  setSavedState() {\n    this.enqueueStateUpdate((toolState) => ({ dirty: false, savedMatches: toolState.matches }));\n  }\n}\n\nfunction syncDecoratorsAndMatches(toolState: ToolState): Partial<ToolState> {\n  const { source, target } = toolState;\n  const matches = groupMatches(toolState.target.forest);\n  const sources = Immutable.Map<string, MatchEntry>().withMutations((bySources) => {\n    matches.forEach((group) => {\n      group.forEach((match, sourceKey) => bySources.set(sourceKey, match));\n    });\n  });\n  const sourceTree = source.forest.mapRoot((root) => {\n    const withSources = mapBottomUp<AlignmentNode>(root, (node) => {\n      const entry = sources.get(AlignmentNode.keyOf(node));\n      if (entry) {\n        // update decorators and match info\n        const excluded = entry.targetAligned.excludeFromAlignment;\n        const decorated = decorateMatchChildren(node, (node) => !excluded.has(AlignmentNode.keyOf(node)));\n        const matchedTargetNode = entry.targetBase.base;\n        return AlignmentNode.set(decorated, { matchedTargetNode });\n      } else if (node.matchedTargetNode) {\n        // clear decorators and remove match info\n        const decorated = decorateMatchChildren(node, () => false);\n        return AlignmentNode.set(decorated, { matchedTargetNode: undefined });\n      } else {\n        return node;\n      }\n    });\n    return decorateMatchParent(withSources);\n  });\n  const targetTree = target.forest.mapRoot(decorateMatchParent);\n  return {\n    matches,\n    source: PanelState.set(source, { forest: sourceTree }),\n    target: PanelState.set(target, { forest: targetTree }),\n  };\n}\n\nfunction decorateMatchChildren(sourceNode: AlignmentNode, isAlignChild: (node: AlignmentNode) => boolean) {\n  const mapNode = (child: AlignmentNode) => {\n    const decorateAlignChild = isAlignChild(child);\n    const children = child.children.map(mapNode);\n    return AlignmentNode.set(child, { decorateAlignChild, children });\n  };\n  return mapNode(sourceNode);\n}\n\nfunction decorateMatchParent(root: AlignmentNode): AlignmentNode {\n  return mapBottomUp<AlignmentNode>(root, (node) => {\n    const decorateAlignParent = node.children.some((child) => {\n      return Boolean(\n        // source node is aligned\n        child.matchedTargetNode ||\n          // non-aligned target node is a parent of aligned child\n          (!node.aligned && child.aligned) ||\n          // node is a parent of decorated child\n          child.decorateAlignParent\n      );\n    });\n    return AlignmentNode.set(node, { decorateAlignParent });\n  });\n}\n\nfunction createQueries(\n  rawPatterns: AlignmentQueries,\n  graph: Rdf.Iri\n): {\n  queries: ParsedQueries;\n  nodeQuery: SparqlJs.SelectQuery;\n  patterns: ComplexTreePatterns;\n} {\n  const rootsQuery = SparqlUtil.parseQuery(rawPatterns.rootsQuery) as SparqlJs.SelectQuery;\n  const childrenQuery = SparqlUtil.parseQuery(rawPatterns.childrenQuery) as SparqlJs.SelectQuery;\n  const parentsQuery = SparqlUtil.parseQuery(rawPatterns.parentsQuery) as SparqlJs.SelectQuery;\n  const searchQuery = SparqlUtil.parseQuery(rawPatterns.searchQuery) as SparqlJs.SelectQuery;\n  const nodeQuery = SparqlUtil.parseQuery(rawPatterns.nodeQuery) as SparqlJs.SelectQuery;\n\n  const binder = new IriBinder({\n    'alignment:__graph__': graph,\n  });\n\n  [rootsQuery, childrenQuery, parentsQuery, searchQuery, nodeQuery].forEach((q) => binder.sparqlQuery(q));\n\n  const patterns: ComplexTreePatterns = {\n    rootsQuery: SparqlUtil.serializeQuery(rootsQuery),\n    childrenQuery: SparqlUtil.serializeQuery(childrenQuery),\n    parentsQuery: SparqlUtil.serializeQuery(parentsQuery),\n    searchQuery: SparqlUtil.serializeQuery(searchQuery),\n  };\n\n  return {\n    queries: { rootsQuery, childrenQuery, parentsQuery, searchQuery },\n    nodeQuery,\n    patterns,\n  };\n}\n\nclass IriBinder extends QueryVisitor {\n  constructor(protected replacements: { [iri: string]: Rdf.Iri }) {\n    super();\n  }\n\n  private tryReplace(termValue: string) {\n    const replacement = this.replacements[termValue];\n    if (replacement !== undefined) {\n      return turtle.serialize.nodeToN3(replacement) as SparqlJs.Term;\n    } else {\n      return undefined;\n    }\n  }\n\n  iri(iri: SparqlJs.Term) {\n    return this.tryReplace(iri);\n  }\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, © Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as React from 'react';\nimport { Button } from 'react-bootstrap';\n\nimport { Component } from 'platform/api/components';\n\nimport { Node } from 'platform/components/semantic/lazy-tree';\nimport { OverlayDialog } from 'platform/components/ui/overlay';\n\nimport { AlignKind } from './AlignmentNodeModel';\n\nimport * as styles from './ConfirmAlignDialog.scss';\n\nexport interface ConfirmAlignDialogProps {\n  sourceNode: Node;\n  targetNode: Node;\n  onSubmit: (kind: AlignKind) => void;\n  onClose: () => void;\n}\n\nexport class ConfirmAlignDialog extends Component<ConfirmAlignDialogProps, {}> {\n  static readonly KEY = 'ConfirmAlignDialog';\n\n  render() {\n    const { sourceNode, targetNode, onSubmit, onClose } = this.props;\n    return (\n      <OverlayDialog\n        type=\"modal\"\n        show={true}\n        className={styles.component}\n        title=\"Select alignment relation type\"\n        onHide={onClose}\n      >\n        <Button bsSize=\"large\" block={true} onClick={() => onSubmit(AlignKind.ExactMatch)}>\n          <span className={styles.description}>\n            <span className={styles.sourceTerm}>{Node.getLabel(sourceNode)}</span> is exact match (=) to{' '}\n            <span className={styles.targetTerm}>{Node.getLabel(targetNode)}</span>\n          </span>\n        </Button>\n        <Button bsSize=\"large\" block={true} onClick={() => onSubmit(AlignKind.NarrowerMatch)}>\n          <span className={styles.description}>\n            <span className={styles.sourceTerm}>{Node.getLabel(sourceNode)}</span> is narrow match (≤) to{' '}\n            <span className={styles.targetTerm}>{Node.getLabel(targetNode)}</span>\n          </span>\n        </Button>\n      </OverlayDialog>\n    );\n  }\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, © Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as React from 'react';\nimport { ReactElement } from 'react';\nimport { Button } from 'react-bootstrap';\nimport * as _ from 'lodash';\nimport * as classnames from 'classnames';\n\nimport { Component } from 'platform/api/components';\n\nimport { Node } from 'platform/components/semantic/lazy-tree';\n\nimport { AlignmentNode, AlignKind } from './AlignmentNodeModel';\nimport { MatchEntry } from './Serialization';\n\nimport * as styles from './MatchList.scss';\n\nexport interface MatchListProps {\n  className?: string;\n  matches: Immutable.Map<string, Immutable.Map<string, MatchEntry>>;\n  savedMatches: Immutable.Map<string, Immutable.Map<string, MatchEntry>>;\n  onScrollToEntry: (entry: MatchEntry) => void;\n}\n\nexport class MatchList extends Component<MatchListProps, {}> {\n  render() {\n    const { className, matches } = this.props;\n    const entries = computeMatchEntries(matches);\n    return (\n      <ul className={classnames(styles.component, className)}>{entries.map((entry) => this.renderMatch(entry))}</ul>\n    );\n  }\n\n  private renderMatch(entry: MatchEntry): ReactElement<any> {\n    const targetBase = entry.targetBase;\n    const sourceNode = entry.targetAligned.aligned || entry.targetAligned.base;\n    const key = `<${AlignmentNode.keyOf(targetBase)}>${entry.kind}${sourceNode.iri.toString()}`;\n\n    const relationSign = entry.kind === AlignKind.ExactMatch ? '=' : '≤';\n\n    const hasBeenSaved = this.props.savedMatches.hasIn([\n      entry.targetBase.base.iri.value,\n      entry.targetAligned.aligned.iri.value,\n    ]);\n    return (\n      <li key={key} className={styles.entry}>\n        <span>{getLabel(sourceNode)}</span>\n        <span> {relationSign} </span>\n        <span>{getLabel(targetBase.base)}</span>\n        {hasBeenSaved ? null : <span className={styles.unsaved}>unsaved</span>}\n        <Button\n          className={styles.scrollTo}\n          bsSize=\"xs\"\n          title=\"Scroll to aligned terms\"\n          onClick={() => this.scrollToItem(entry)}\n        >\n          <span className=\"fa fa-arrow-right\" aria-hidden=\"true\"></span>\n        </Button>\n      </li>\n    );\n  }\n\n  private scrollToItem(entry: MatchEntry) {\n    this.props.onScrollToEntry(entry);\n  }\n}\n\nconst MATCH_COMPARATOR = [\n  (entry: MatchEntry) => getLabel(entry.targetBase.base),\n  (entry: MatchEntry) => entry.kind,\n  (entry: MatchEntry) => getLabel(entry.targetAligned.aligned || entry.targetAligned.base),\n];\n\nfunction computeMatchEntries(grouped: Immutable.Map<string, Immutable.Map<string, MatchEntry>>): MatchEntry[] {\n  const result: MatchEntry[] = [];\n  grouped.forEach((group) =>\n    group.forEach((entry) => {\n      result.push(entry);\n    })\n  );\n  return _.orderBy(result, MATCH_COMPARATOR);\n}\n\nfunction getLabel(node: Node) {\n  return node.label ? node.label.value : node.iri.value;\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, © Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as React from 'react';\nimport * as classnames from 'classnames';\nimport { Button, Popover, OverlayTrigger, Tooltip } from 'react-bootstrap';\nimport * as Immutable from 'immutable';\n\nimport { Component } from 'platform/api/components';\nimport { Rdf } from 'platform/api/rdf';\n\nimport { ResourceLink } from 'platform/api/navigation/components';\nimport { Draggable, Droppable } from 'platform/components/dnd';\nimport { Spinner } from 'platform/components/ui/spinner';\nimport { TemplateItem } from 'platform/components/ui/template';\n\nimport {\n  KeyPath,\n  TreeSelection,\n  SelectionNode,\n  Node,\n  LazyTreeSelector,\n  LazyTreeSelectorProps,\n  SemanticTreeInput,\n  SelectionMode,\n  SingleFullSubtree,\n  PartialSubtrees,\n} from 'platform/components/semantic/lazy-tree';\n\nimport { AlignmentNode, AlignKind, findExcludedChildren } from './AlignmentNodeModel';\nimport { PanelState, AlignementRole } from './ToolController';\n\nimport * as styles from './MatchPanel.scss';\n\nexport interface MatchPanelProps {\n  role: AlignementRole;\n  state: PanelState;\n\n  requestMoreItems: (path: KeyPath) => void;\n  onExpandOrCollapse: (path: KeyPath, expanded: boolean) => void;\n  onSelectionChanged?: (selection: TreeSelection<AlignmentNode>) => void;\n\n  onExpandAndScrollToPath: (path: KeyPath, target: Node) => void;\n  onCancelExpandingToScroll: () => void;\n\n  draggedNodes?: ReadonlyArray<AlignmentNode>;\n  onDragStart?: (nodes: AlignmentNode[]) => void;\n  onDragEnd?: () => void;\n\n  onAlign?: (sourceNodes: ReadonlyArray<AlignmentNode>, targetPath: KeyPath) => void;\n  onUnalign?: (targetPath: KeyPath) => void;\n  onFindAligned?: (targetKey: string) => void;\n\n  className?: string;\n  infoTemplate?: string;\n}\n\nexport class MatchPanel extends Component<MatchPanelProps, {}> {\n  private alignementTree: LazyTreeSelector;\n\n  private searchedPaths = Immutable.Set<Immutable.List<string>>();\n\n  render() {\n    const { className, role, state } = this.props;\n    const { patterns, forest, selection, expandingToScroll, highlightedPath } = state;\n\n    let highlightedNodes: ReadonlyArray<AlignmentNode> = [];\n    if (highlightedPath) {\n      const highlightTarget = forest.fromKeyPath(highlightedPath);\n      if (highlightTarget) {\n        highlightedNodes = forest.getNodePath(highlightTarget);\n      }\n    }\n\n    const props: LazyTreeSelectorProps<AlignmentNode> = {\n      forest,\n      isLeaf: this.isLeaf,\n      childrenOf: this.childrenOf,\n      renderItem: (node) => this.renderTreeNodeRow(node, highlightedNodes),\n      requestMore: this.requestMore,\n      hideCheckboxes: role === AlignementRole.Target,\n      selectionMode:\n        this.props.role === AlignementRole.Source\n          ? PartialSubtrees<AlignmentNode>()\n          : SingleFullSubtree<AlignmentNode>(),\n      selection,\n      onSelectionChanged: this.props.onSelectionChanged,\n      isExpanded,\n      onExpandedOrCollapsed: this.onExpandedOrCollapsed,\n    };\n    return (\n      <div className={classnames(styles.component, className)}>\n        <SemanticTreeInput\n          {...patterns}\n          multipleSelection={true}\n          onSelectionClick={this.onSearchBadgeClick}\n          onSelectionChanged={this.onSearchSelectionChanged}\n        />\n        <div className={styles.alignmentTreeContainer}>\n          {expandingToScroll ? this.renderExpandToScrollMessage() : null}\n          <LazyTreeSelector {...props} ref={this.onAlignmentTreeMount} className={styles.alignmentTree} />\n        </div>\n      </div>\n    );\n  }\n\n  private renderTreeNodeRow(node: AlignmentNode, highlightedNodes: ReadonlyArray<AlignmentNode>) {\n    const decoratorsClass = this.computeDecoratorsClass(node, highlightedNodes);\n    return (\n      <span className={styles.alignmentNodeRow}>\n        {this.renderTreeNode(node, decoratorsClass)}\n        {...this.renderIndicators(node)}\n        {this.renderUnalignButton(node)}\n        {this.renderFindAlignedButton(node)}\n        {this.renderInfoButton(node)}\n      </span>\n    );\n  }\n\n  private renderTreeNode(node: AlignmentNode, decoratorsClass: string) {\n    const {\n      role,\n      onDragEnd,\n      state: { forest, selection },\n    } = this.props;\n    const title = (node.base || node.aligned).iri.value;\n    const body = (\n      <span className={decoratorsClass} title={title}>\n        {renderAlignedTerm(node)}\n      </span>\n    );\n\n    if (role === AlignementRole.Source) {\n      const mode = PartialSubtrees<AlignmentNode>();\n      const selected = selection.nodes.get(AlignmentNode.keyOf(node));\n      if (selected && selected.size > 0) {\n        const path = forest.getKeyPath(node);\n        const itemSelection = selection.fromKeyPath(path);\n        if (itemSelection && mode.isSelectedSubtree(itemSelection)) {\n          return (\n            <Draggable\n              iri={node.base.iri.value}\n              onDragStart={() => this.startDraggingSelection()}\n              onDragEnd={onDragEnd}\n            >\n              <span className={styles.draggableWrapper}>\n                <span className={styles.draggableHandle} />\n                {body}\n              </span>\n            </Draggable>\n          );\n        }\n      }\n    } else if (role === AlignementRole.Target) {\n      if (node.base) {\n        const path = forest.getKeyPath(node);\n        return <Droppable onDrop={(iri) => this.onDropInto(path, iri)}>{body}</Droppable>;\n      }\n    }\n\n    return body;\n  }\n\n  private renderIndicators(node: AlignmentNode): Array<React.ReactElement<any>> {\n    const indicators = [];\n\n    if (node.decorateAlignParent) {\n      const overlay = <Tooltip id=\"aligned-descendants\">Term has aligned descendants.</Tooltip>;\n      indicators.push(\n        <OverlayTrigger key=\"aligned-descendants\" placement=\"top\" overlay={overlay}>\n          <span className={styles.decorateAlignParent}>&nbsp;[*]</span>\n        </OverlayTrigger>\n      );\n    }\n\n    return indicators;\n  }\n\n  private computeDecoratorsClass(item: AlignmentNode, highlightedNodes: ReadonlyArray<AlignmentNode>): string {\n    const classes: string[] = [styles.decoratedNodeBody];\n\n    const pathIndex = highlightedNodes.indexOf(item);\n    if (pathIndex >= 0) {\n      const isTarget = pathIndex === highlightedNodes.length - 1;\n      classes.push(isTarget ? styles.decorateHighlightLeaf : styles.decorateHighlightParent);\n    }\n\n    if (item.matchedTargetNode || item.decorateAlignChild) {\n      classes.push(styles.decorateAlignLeaf);\n    }\n\n    return classes.join(' ');\n  }\n\n  private onAlignmentTreeMount = (alignementTree: LazyTreeSelector) => {\n    this.alignementTree = alignementTree;\n  };\n\n  scrollToPath(path: KeyPath) {\n    this.alignementTree.scrollToPath(path);\n  }\n\n  private renderExpandToScrollMessage() {\n    const {\n      onCancelExpandingToScroll,\n      state: { expandTarget },\n    } = this.props;\n    return (\n      <div className={styles.scrollNotification}>\n        Scrolling to item <span className={styles.scrollToName}>{expandTarget.label.value}</span>\n        <Spinner className={styles.scrollSpinner} spinnerDelay={0} messageDelay={Infinity} />\n        <Button bsSize=\"xsmall\" className={styles.cancelScrollingTo} onClick={onCancelExpandingToScroll}>\n          Cancel\n        </Button>\n      </div>\n    );\n  }\n\n  private onSearchBadgeClick = (selection: TreeSelection<Node>, target: SelectionNode<Node>) => {\n    const path = selection.getKeyPath(target);\n    this.props.onExpandAndScrollToPath(path, target);\n  };\n\n  /** Auto-scroll to newly selected single path in search input. */\n  private onSearchSelectionChanged = (selection: TreeSelection<Node>) => {\n    const previousPaths = this.searchedPaths;\n    this.searchedPaths = TreeSelection.leafs(selection)\n      .map((node) => Immutable.List(selection.getKeyPath(node) as string[]))\n      .toSet();\n\n    const newlySelectedPaths = this.searchedPaths.filter((path) => !previousPaths.has(path));\n    if (newlySelectedPaths.size === 1) {\n      const path = newlySelectedPaths.first().toArray() as KeyPath;\n      this.props.onExpandAndScrollToPath(path, selection.fromKeyPath(path));\n    }\n  };\n\n  private isLeaf = (item: AlignmentNode) => {\n    const { model } = this.props.state;\n    return item.children ? item.children.length === 0 && !model.hasMoreChildren(item) : undefined;\n  };\n\n  private childrenOf = (node: AlignmentNode) => {\n    const { model } = this.props.state;\n    const { children, loading } = node;\n    return { children, loading, hasMoreItems: model.hasMoreChildren(node) };\n  };\n\n  private requestMore = (node: AlignmentNode): void => {\n    const {\n      requestMoreItems,\n      state: { forest },\n    } = this.props;\n    const path = forest.getKeyPath(node);\n    requestMoreItems(path);\n  };\n\n  private onExpandedOrCollapsed = (item: AlignmentNode, expanded: boolean) => {\n    const {\n      onExpandOrCollapse,\n      state: { forest },\n    } = this.props;\n    const path = forest.getKeyPath(item);\n    onExpandOrCollapse(path, expanded);\n  };\n\n  private startDraggingSelection() {\n    const { forest, selection } = this.props.state;\n    const mode = PartialSubtrees<AlignmentNode>();\n    const subtrees = mode.getSelectedSubtrees(selection);\n    if (subtrees.length === 0) {\n      return;\n    }\n\n    const draggedNodes = subtrees.map((selectionRoot) => {\n      const selectionPath = selection.getKeyPath(selectionRoot);\n      const node = forest.fromKeyPath(selectionPath);\n      const excludeFromAlignment = findExcludedChildren(node, selectionRoot, selection);\n      const unloadedNode =\n        node.base.children && node.base.children.length > 0\n          ? Node.set(node.base, { children: undefined, reachedLimit: false })\n          : node.base;\n      const draggedNode = AlignmentNode.set(AlignmentNode.empty, {\n        base: unloadedNode,\n        excludeFromAlignment,\n      });\n      return draggedNode;\n    });\n    this.props.onDragStart(draggedNodes);\n  }\n\n  private onDropInto(path: KeyPath, iri: Rdf.Iri) {\n    const { state, draggedNodes, onCancelExpandingToScroll, onAlign } = this.props;\n    if (state.expandingToScroll) {\n      onCancelExpandingToScroll();\n    }\n\n    if (onAlign && draggedNodes && draggedNodes.some((n) => n.base.iri.equals(iri))) {\n      onAlign(draggedNodes, path);\n    }\n  }\n\n  private renderInfoButton(node: AlignmentNode) {\n    const overlay = <NodeInfoPopover node={node} infoTemplate={this.props.infoTemplate} />;\n    return (\n      <OverlayTrigger\n        key={AlignmentNode.keyOf(node)}\n        trigger=\"click\"\n        rootClose={true}\n        placement=\"right\"\n        overlay={overlay}\n      >\n        <Button bsSize=\"xsmall\" className={styles.nodeInfoButton} onClick={this.onShowNodeInfoClick}>\n          <span className=\"fa fa-info\" aria-hidden=\"true\" />\n        </Button>\n      </OverlayTrigger>\n    );\n  }\n\n  private onShowNodeInfoClick = (e: React.MouseEvent<Button>) => {\n    // prevent expand/collapse on button click\n    e.stopPropagation();\n  };\n\n  private renderUnalignButton(node: AlignmentNode) {\n    const {\n      onUnalign,\n      state: { forest },\n    } = this.props;\n    if (!onUnalign) {\n      return null;\n    }\n    if (!node.aligned || node.alignKind === AlignKind.MatchChild) {\n      return null;\n    }\n    return (\n      <Button\n        bsSize=\"xsmall\"\n        className={styles.unalignButton}\n        onClick={(e) => {\n          e.stopPropagation();\n          const path = forest.getKeyPath(node);\n          onUnalign(path);\n        }}\n      >\n        unalign\n      </Button>\n    );\n  }\n\n  private renderFindAlignedButton(node: AlignmentNode) {\n    const { onFindAligned } = this.props;\n    if (!(onFindAligned && node.matchedTargetNode)) {\n      return null;\n    }\n    return (\n      <Button\n        bsSize=\"xsmall\"\n        className={styles.findAlignedButton}\n        onClick={(e) => {\n          e.stopPropagation();\n          onFindAligned(Node.keyOf(node.matchedTargetNode));\n        }}\n      >\n        <span className=\"fa fa-arrow-right\" aria-hidden=\"true\"></span>\n      </Button>\n    );\n  }\n}\n\nfunction renderAlignedTerm(node: AlignmentNode) {\n  if (node.base && node.aligned) {\n    return (\n      <span>\n        <span className={styles.baseTerm}>{Node.getLabel(node.base)}</span>\n        <span className={styles.alignedTerm}> = {Node.getLabel(node.aligned)}</span>\n      </span>\n    );\n  } else if (node.base) {\n    return <span className={styles.baseTerm}>{Node.getLabel(node.base)}</span>;\n  } else if (node.aligned) {\n    return (\n      <span className={styles.alignedTerm}>\n        {node.alignKind === AlignKind.NarrowerMatch ? '≥ ' : ''}\n        {Node.getLabel(node.aligned)}\n      </span>\n    );\n  } else {\n    return null;\n  }\n}\n\nfunction isExpanded(node: AlignmentNode) {\n  return node.expanded;\n}\n\ninterface NodeInfoPopoverProps {\n  node: AlignmentNode;\n  infoTemplate: string | undefined;\n}\n\nclass NodeInfoPopover extends React.Component<NodeInfoPopoverProps, {}> {\n  render() {\n    const { node, infoTemplate = '<i>No info available</i>', ...delegatedProps } = this.props;\n    const targetNode = node.base || node.aligned;\n    const nodeLabel = Node.getLabel(targetNode);\n    const infoHeader = <ResourceLink resource={targetNode.iri}>{nodeLabel}</ResourceLink>;\n    const popoverProps = delegatedProps as any;\n    return (\n      <Popover\n        id=\"alignment-tool-node-info\"\n        {...popoverProps}\n        className={classnames(styles.nodeInfoPopup, popoverProps.className)}\n        title={infoHeader as any}\n      >\n        <TemplateItem\n          template={{\n            source: infoTemplate,\n            options: {\n              iri: targetNode.iri.value,\n              label: nodeLabel,\n            },\n          }}\n        />\n      </Popover>\n    );\n  }\n}\n"],"sourceRoot":""}