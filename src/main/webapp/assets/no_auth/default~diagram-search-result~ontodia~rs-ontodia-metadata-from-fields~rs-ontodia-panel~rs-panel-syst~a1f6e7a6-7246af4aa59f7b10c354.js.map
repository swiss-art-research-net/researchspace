{"version":3,"sources":["webpack:///./src/main/web/components/3-rd-party/ontodia/authoring/OntodiaPersistenceCommon.ts","webpack:///./src/main/web/components/3-rd-party/ontodia/authoring/FieldBasedMetadataApi.ts"],"names":["convertPropertyToFieldValues","property","isIriProperty","values","map","value","FieldValue","fromLabeled","Rdf","iri","isLiteralProperty","convertLocalizedStringsToFieldValues","language","datatype","literal","langLiteral","undefined","deleteLinkFromCompositeValue","link","composite","metadata","definition","fieldByIri","get","linkTypeId","fields","has","id","update","previous","FieldState","set","filter","v","asRdfNode","targetId","toList","CompositeValue","fetchInitialModel","subject","fieldsToFetch","initial","type","definitions","Immutable","Map","errors","FieldError","noErrors","valuesFetching","toArray","queryValues","selectPattern","bindings","b","state","empty","List","Kefir","zip","nonEmpty","size","toProperty","getEntityMetadata","elementData","allMetadata","types","convertElementModelToCompositeValue","model","withMutations","forEach","fieldId","fieldValues","typeField","imageField","image","labelField","label","properties","convertCompositeValueToElementModel","labels","field","isIri","first","isAtomic","isLiteral","xsdDatatype","applyEventsToCompositeValue","params","newIri","elementIri","currentModel","initialModel","deleted","elements","event","after","changeEvent","applyElementModelToCompositeValue","fieldIri","isObjectProperty","links","sourceId","before","applyLinkModelToCompositeValue","push","newFieldSet","newValueSet","relatedElementIri","Iri","entityMetadata","generateNewElement","ct","Promise","length","typeIri","PLACEHOLDER_ELEMENT_TYPE","observableToCancellablePromise","getLabel","typeLabel","newModel","this","generateIriForModel","firstType","newComposite","generateSubjectByTemplate","newSubjectTemplate","Math","floor","random","toString","substring","canDropOnCanvas","source","typesOfElementsDraggedFrom","then","elementTypes","canDropOnElement","target","possibleLinkTypes","task","combine","outgoing","getPossibleLinkTypes","incoming","linkTypeIri","direction","LinkDirection","out","in","sourceMetadata","targetMetadata","constant","typeRequest","BaseTypeClosureRequest","addAll","query","typeClosure","possibleLinks","Set","hasCompatibleType","domain","range","add","Array","from","resolve","targetTypes","entityType","otherMetadata","propertiesForType","canDeleteElement","element","Boolean","filterConstructibleTypes","constructibleTypes","key","canEditElement","canLinkElement","canDeleteLink","canEditLink","FieldBasedMetadataApi","derivedTypes","preparedQuery","SparqlClient","prepareParsedQuery","BASE_TYPES_QUERY","select","results","baseTypes","binding","base","baseSet","SparqlUtil","parseQuerySync","requiredTypes","targetTypesClosure","targetType","closure","requiredType"],"mappings":"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","file":"default~diagram-search-result~ontodia~rs-ontodia-metadata-from-fields~rs-ontodia-panel~rs-panel-syst~a1f6e7a6-7246af4aa59f7b10c354.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\nimport * as Immutable from 'immutable';\nimport {\n  ElementIri,\n  ElementTypeIri,\n  LocalizedString,\n  Property,\n  ElementModel,\n  LinkModel,\n  AuthoringState,\n  isLiteralProperty,\n  isIriProperty,\n} from 'ontodia';\n\nimport { Rdf } from 'platform/api/rdf';\n\nimport { CompositeValue, EmptyValue, FieldState, FieldValue, FieldError, queryValues } from 'platform/components/forms';\n\nimport { EntityMetadata, isObjectProperty } from './FieldConfigurationCommon';\n\nexport function fetchInitialModel(\n  subject: Rdf.Iri,\n  metadata: EntityMetadata,\n  fieldsToFetch = metadata.fieldByIri\n): Kefir.Property<CompositeValue> {\n  const initial: CompositeValue = {\n    type: CompositeValue.type,\n    subject,\n    definitions: metadata.fieldByIri,\n    fields: Immutable.Map<string, FieldState>(),\n    errors: FieldError.noErrors,\n  };\n\n  const valuesFetching = fieldsToFetch.toArray().map((definition) =>\n    queryValues(definition.selectPattern, subject).map((bindings) => {\n      const values = bindings.map((b) => FieldValue.fromLabeled(b));\n      const state = FieldState.set(FieldState.empty, { values: Immutable.List(values) });\n      return [definition.id, state] as [string, FieldState];\n    })\n  );\n\n  return Kefir.zip(valuesFetching)\n    .map((fields) => {\n      const nonEmpty = fields.filter(([id, state]) => state.values.size > 0);\n      return CompositeValue.set(initial, { fields: Immutable.Map(nonEmpty) });\n    })\n    .toProperty();\n}\n\nexport function getEntityMetadata(\n  elementData: ElementModel,\n  allMetadata: ReadonlyMap<string, EntityMetadata>\n): EntityMetadata | undefined {\n  for (const type of elementData.types) {\n    if (allMetadata.get(type)) {\n      return allMetadata.get(type);\n    }\n  }\n  return undefined;\n}\n\nexport function convertElementModelToCompositeValue(model: ElementModel, metadata: EntityMetadata): CompositeValue {\n  const fields = Immutable.Map<string, FieldState>().withMutations((map) => {\n    metadata.fieldByIri.forEach((definition, fieldId) => {\n      let fieldValues: FieldValue[] = [];\n      if (definition.iri === metadata.typeField.iri) {\n        fieldValues = model.types.map((type) => FieldValue.fromLabeled({ value: Rdf.iri(type) }));\n      } else if (metadata.imageField && definition.iri === metadata.imageField.iri) {\n        fieldValues = model.image ? [FieldValue.fromLabeled({ value: Rdf.iri(model.image) })] : [];\n      } else if (definition.iri === metadata.labelField.iri) {\n        fieldValues = convertLocalizedStringsToFieldValues(model.label.values);\n      } else {\n        const property = model.properties[definition.iri];\n        if (property) {\n          fieldValues = convertPropertyToFieldValues(property);\n        }\n      }\n      map.set(fieldId, {\n        values: Immutable.List(fieldValues),\n        errors: FieldError.noErrors,\n      });\n    });\n  });\n\n  return {\n    type: CompositeValue.type,\n    subject: Rdf.iri(model.id),\n    definitions: metadata.fieldByIri,\n    fields,\n    errors: FieldError.noErrors,\n  };\n}\n\nexport function convertCompositeValueToElementModel(composite: CompositeValue, metadata: EntityMetadata): ElementModel {\n  let types: ElementTypeIri[] | undefined;\n  let labels: LocalizedString[] | undefined;\n  let image: string | undefined;\n  const properties: { [id: string]: Property } = {};\n\n  composite.fields.forEach((field, fieldId) => {\n    const definition = metadata.fieldByIri.get(fieldId);\n    if (definition.iri === metadata.typeField.iri) {\n      types = field.values\n        .map(FieldValue.asRdfNode)\n        .filter((v) => v && v.isIri())\n        .map((v) => v.value as ElementTypeIri)\n        .toArray();\n    } else if (metadata.imageField && definition.iri === metadata.imageField.iri) {\n      image = field.values\n        .map(FieldValue.asRdfNode)\n        .filter((v) => v && v.isIri())\n        .map((v) => v.value)\n        .first();\n    } else if (definition.iri === metadata.labelField.iri) {\n      labels = field.values\n        .map((v) => {\n          if (FieldValue.isAtomic(v) && v.value.isLiteral()) {\n            return FieldValue.asRdfNode(v) as Rdf.Literal;\n          }\n        })\n        .toArray();\n    } else {\n      field.values.forEach((v) => {\n        if (!FieldValue.isAtomic(v)) {\n          return;\n        }\n        if (v.value.isLiteral()) {\n          const { value, language } = FieldValue.asRdfNode(v) as Rdf.Literal;\n          const property = properties[definition.iri] || { type: 'string', values: [] };\n          if (isLiteralProperty(property)) {\n            property.values = [\n              ...property.values,\n              {\n                value,\n                language,\n                datatype: definition.xsdDatatype,\n              },\n            ];\n          }\n          properties[definition.iri] = property;\n        } else if (v.value.isIri()) {\n          const { value } = FieldValue.asRdfNode(v) as Rdf.Iri;\n          const property = properties[definition.iri] || { type: 'uri', values: [] };\n          if (isIriProperty(property)) {\n            property.values = [...property.values, { type: 'uri', value }];\n          }\n          properties[definition.iri] = property;\n        }\n      });\n    }\n  });\n\n  return {\n    id: composite.subject.value as ElementIri,\n    types: types || [],\n    label: { values: labels || [] },\n    image,\n    properties,\n  };\n}\n\nexport function applyEventsToCompositeValue(params: {\n  elementIri: ElementIri;\n  state: AuthoringState;\n  metadata: EntityMetadata;\n  initialModel: CompositeValue;\n}): CompositeValue | EmptyValue {\n  const { elementIri, state, metadata, initialModel } = params;\n\n  let currentModel = initialModel;\n  let deleted = false;\n  let newIri: ElementIri;\n\n  state.elements.forEach((event) => {\n    if (event.deleted) {\n      const { after } = event;\n      if (after.id === elementIri) {\n        deleted = true;\n      }\n    } else {\n      const changeEvent = event;\n      const { after } = changeEvent;\n      if (after.id === elementIri) {\n        currentModel = applyElementModelToCompositeValue(after, currentModel, metadata);\n        newIri = changeEvent.newIri !== currentModel.subject.value ? changeEvent.newIri : undefined;\n      }\n    }\n  });\n\n  state.links.forEach((event) => {\n    if (event.deleted) {\n      const { after } = event;\n      if (after.sourceId === elementIri) {\n        currentModel = deleteLinkFromCompositeValue(after, currentModel, metadata);\n      }\n    } else {\n      const { before, after } = event;\n      if (before && before.sourceId === elementIri) {\n        currentModel = deleteLinkFromCompositeValue(before, currentModel, metadata);\n      }\n      if (after.sourceId === elementIri) {\n        currentModel = applyLinkModelToCompositeValue(after, currentModel, metadata);\n      }\n    }\n  });\n\n  // Filter out fields or field values whose target(value) was deleted\n  const existingFields = currentModel.fields;\n  existingFields.forEach((field, fieldId) => {\n    const updater = (previous: FieldState) => {\n      const newValueSet = previous.values\n        .filter((value) => {\n          const relatedElementIri = FieldValue.asRdfNode(value).value as ElementIri;\n          const event = state.elements.get(relatedElementIri);\n          const isTargetValueDeleted = event && event.deleted;\n          return !isTargetValueDeleted;\n        })\n        .toList();\n      return FieldState.set(previous, { values: newValueSet });\n    };\n    const newFieldSet = currentModel.fields.update(fieldId, updater);\n    currentModel = CompositeValue.set(currentModel, { fields: newFieldSet });\n  });\n\n  if (newIri) {\n    currentModel = {\n      ...currentModel,\n      subject: new Rdf.Iri(newIri),\n    };\n  }\n\n  return deleted ? FieldValue.empty : currentModel;\n}\n\nfunction applyLinkModelToCompositeValue(\n  link: LinkModel,\n  composite: CompositeValue,\n  metadata: EntityMetadata\n): CompositeValue {\n  const value = Rdf.iri(link.targetId);\n  const definition = metadata.fieldByIri.get(link.linkTypeId);\n  if (!definition) {\n    return composite;\n  }\n  const fields = composite.fields.update(definition.id, (previous = FieldState.empty) =>\n    FieldState.set(previous, {\n      values: previous.values.push(FieldValue.fromLabeled({ value })),\n    })\n  );\n  return CompositeValue.set(composite, { fields });\n}\n\nfunction applyElementModelToCompositeValue(\n  model: ElementModel,\n  composite: CompositeValue,\n  metadata: EntityMetadata\n): CompositeValue {\n  let fields = composite.fields;\n\n  metadata.fieldByIri.forEach((definition, fieldIri) => {\n    if (isObjectProperty(definition, metadata)) {\n      return;\n    }\n    let values = [];\n    if (definition.id === metadata.labelField.id) {\n      values = convertLocalizedStringsToFieldValues(model.label.values);\n    } else if (definition.id === metadata.typeField.id) {\n      values = model.types.map((type) => FieldValue.fromLabeled({ value: Rdf.iri(type) }));\n    } else if (metadata.imageField && definition.id === metadata.imageField.id && model.image) {\n      values = [FieldValue.fromLabeled({ value: Rdf.iri(model.image) })];\n    } else {\n      const property = model.properties[fieldIri];\n      if (property) {\n        values = convertPropertyToFieldValues(property);\n      }\n    }\n    fields = fields.set(definition.id, {\n      values: Immutable.List(values),\n      errors: FieldError.noErrors,\n    });\n  });\n\n  return CompositeValue.set(composite, { fields });\n}\n\nfunction convertPropertyToFieldValues(property: Property): FieldValue[] {\n  if (isIriProperty(property)) {\n    return property.values.map(({ value }) => FieldValue.fromLabeled({ value: Rdf.iri(value) }));\n  } else if (isLiteralProperty(property)) {\n    return convertLocalizedStringsToFieldValues(property.values);\n  }\n  return [];\n}\n\nfunction convertLocalizedStringsToFieldValues(property: ReadonlyArray<LocalizedString>) {\n  return property.map(({ value, language, datatype }) => {\n    const literal = language\n      ? Rdf.langLiteral(value, language)\n      : Rdf.literal(value, datatype ? Rdf.iri(datatype.value) : undefined);\n    return FieldValue.fromLabeled({ value: literal });\n  });\n}\n\nfunction deleteLinkFromCompositeValue(\n  link: LinkModel,\n  composite: CompositeValue,\n  metadata: EntityMetadata\n): CompositeValue {\n  const definition = metadata.fieldByIri.get(link.linkTypeId);\n  if (!composite.fields.has(definition.id)) {\n    return composite;\n  }\n  const fields = composite.fields.update(definition.id, (previous) =>\n    FieldState.set(previous, {\n      values: previous.values.filter((v) => FieldValue.asRdfNode(v).value !== link.targetId).toList(),\n    })\n  );\n  return CompositeValue.set(composite, { fields });\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\nimport * as SparqlJs from 'sparqljs';\nimport {\n  CancellationToken,\n  ElementModel,\n  ElementTypeIri,\n  LinkTypeIri,\n  MetadataApi,\n  PropertyTypeIri,\n  LinkModel,\n  ElementIri,\n  LinkDirection,\n  PLACEHOLDER_ELEMENT_TYPE,\n} from 'ontodia';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { SparqlClient, SparqlUtil } from 'platform/api/sparql';\nimport { getLabel } from 'platform/api/services/resource-label';\n\nimport { generateSubjectByTemplate } from 'platform/components/forms';\n\nimport { observableToCancellablePromise } from '../AsyncAdapters';\nimport { EntityMetadata, isObjectProperty } from './FieldConfigurationCommon';\nimport { getEntityMetadata, convertElementModelToCompositeValue } from './OntodiaPersistenceCommon';\n\nexport class FieldBasedMetadataApi implements MetadataApi {\n  constructor(private entityMetadata: Map<ElementTypeIri, EntityMetadata>) {}\n\n  async generateNewElement(types: ReadonlyArray<ElementTypeIri>, ct: CancellationToken): Promise<ElementModel> {\n    let typeIri: ElementTypeIri | undefined;\n    if (types && types.length !== 0) {\n      typeIri = types[0];\n    }\n\n    let typeLabel: string;\n    if (typeIri && typeIri !== PLACEHOLDER_ELEMENT_TYPE) {\n      typeLabel = await observableToCancellablePromise(getLabel(Rdf.iri(typeIri)), ct);\n    } else {\n      typeLabel = 'Entity';\n    }\n\n    const newModel: ElementModel = {\n      id: '' as ElementIri,\n      types: [...types],\n      label: { values: [{ value: `New ${typeLabel}`, language: '' }] },\n      properties: {},\n    };\n    return {\n      ...newModel,\n      id: this.generateIriForModel(newModel),\n    };\n  }\n\n  generateIriForModel(model: ElementModel): ElementIri {\n    let metadata: EntityMetadata | undefined;\n    if (model.types.length > 0) {\n      const firstType = model.types[0];\n      if (firstType !== PLACEHOLDER_ELEMENT_TYPE) {\n        metadata = this.entityMetadata.get(firstType);\n      }\n    }\n    if (metadata) {\n      const newComposite = convertElementModelToCompositeValue({ ...model, id: '' as ElementIri }, metadata);\n      const generatedIri = generateSubjectByTemplate(metadata.newSubjectTemplate, undefined, newComposite);\n      return generatedIri.value as ElementIri;\n    } else {\n      const uuid = () =>\n        Math.floor((1 + Math.random()) * 0x100000000)\n          .toString(16)\n          .substring(1);\n      return `http://researchspace.org/NewEntity-${uuid()}` as ElementIri;\n    }\n  }\n\n  canDropOnCanvas(source: ElementModel, ct: CancellationToken): Promise<boolean> {\n    return this.typesOfElementsDraggedFrom(source, ct).then((elementTypes) => elementTypes.length > 0);\n  }\n\n  canDropOnElement(source: ElementModel, target: ElementModel, ct: CancellationToken): Promise<boolean> {\n    return this.possibleLinkTypes(source, target, ct).then((types) => types.length > 0);\n  }\n\n  possibleLinkTypes(\n    source: ElementModel,\n    target: ElementModel,\n    ct: CancellationToken\n  ): Promise<Array<{ linkTypeIri: LinkTypeIri; direction: LinkDirection }>> {\n    const task = Kefir.combine(\n      {\n        outgoing: this.getPossibleLinkTypes(source, target),\n        incoming: this.getPossibleLinkTypes(target, source),\n      },\n      ({ outgoing, incoming }) => {\n        return [\n          ...outgoing.map((linkTypeIri) => ({ linkTypeIri, direction: LinkDirection.out })),\n          ...incoming.map((linkTypeIri) => ({ linkTypeIri, direction: LinkDirection.in })),\n        ];\n      }\n    );\n    return observableToCancellablePromise(task, ct);\n  }\n\n  private getPossibleLinkTypes(source: ElementModel, target: ElementModel): Kefir.Property<LinkTypeIri[]> {\n    const sourceMetadata = getEntityMetadata(source, this.entityMetadata);\n    const targetMetadata = getEntityMetadata(target, this.entityMetadata);\n    if (!(sourceMetadata && targetMetadata)) {\n      return Kefir.constant([]);\n    }\n\n    const typeRequest = new BaseTypeClosureRequest();\n    typeRequest.addAll(source.types);\n    typeRequest.addAll(target.types);\n\n    return typeRequest.query().map((typeClosure) => {\n      const possibleLinks = new Set<LinkTypeIri>();\n\n      sourceMetadata.fieldByIri.forEach((field, fieldIri) => {\n        const isCompatibleField =\n          isObjectProperty(field, sourceMetadata) &&\n          hasCompatibleType(field.domain, source.types, typeClosure) &&\n          hasCompatibleType(field.range, target.types, typeClosure);\n        if (isCompatibleField) {\n          possibleLinks.add(fieldIri as LinkTypeIri);\n        }\n      });\n\n      return Array.from(possibleLinks);\n    });\n  }\n\n  typesOfElementsDraggedFrom(source: ElementModel, ct: CancellationToken): Promise<ElementTypeIri[]> {\n    const metadata = getEntityMetadata(source, this.entityMetadata);\n    if (!metadata) {\n      return Promise.resolve([]);\n    }\n\n    const typeRequest = new BaseTypeClosureRequest();\n    typeRequest.addAll(source.types);\n\n    const task = typeRequest.query().map((typeClosure) => {\n      const targetTypes = new Set<ElementTypeIri>();\n\n      metadata.fieldByIri.forEach((field) => {\n        const isCompatibleField =\n          isObjectProperty(field, metadata) && hasCompatibleType(field.domain, source.types, typeClosure);\n        if (isCompatibleField) {\n          for (const rangeType of field.range) {\n            const entityType = rangeType.value as ElementTypeIri;\n            if (this.entityMetadata.has(entityType)) {\n              targetTypes.add(entityType);\n            }\n          }\n        }\n      });\n\n      this.entityMetadata.forEach((otherMetadata) => {\n        otherMetadata.fieldByIri.forEach((field) => {\n          const isCompatibleField =\n            isObjectProperty(field, otherMetadata) && hasCompatibleType(field.range, source.types, typeClosure);\n          if (isCompatibleField) {\n            for (const domainType of field.domain) {\n              const entityType = domainType.value as ElementTypeIri;\n              if (this.entityMetadata.has(entityType)) {\n                targetTypes.add(entityType);\n              }\n            }\n          }\n        });\n      });\n\n      return Array.from(targetTypes);\n    });\n    return observableToCancellablePromise(task, ct);\n  }\n\n  propertiesForType(type: ElementTypeIri, ct: CancellationToken): Promise<PropertyTypeIri[]> {\n    return Promise.resolve([]);\n  }\n\n  canDeleteElement(element: ElementModel, ct: CancellationToken): Promise<boolean> {\n    const metadata = getEntityMetadata(element, this.entityMetadata);\n    return Promise.resolve(Boolean(metadata));\n  }\n\n  filterConstructibleTypes(\n    types: ReadonlySet<ElementTypeIri>,\n    ct: CancellationToken\n  ): Promise<ReadonlySet<ElementTypeIri>> {\n    const constructibleTypes = new Set<ElementTypeIri>();\n    this.entityMetadata.forEach((metadata, key: ElementTypeIri) => {\n      if (types.has(key)) {\n        constructibleTypes.add(key);\n      }\n    });\n    return Promise.resolve(constructibleTypes);\n  }\n\n  canEditElement(element: ElementModel, ct: CancellationToken): Promise<boolean> {\n    const metadata = getEntityMetadata(element, this.entityMetadata);\n    return Promise.resolve(Boolean(metadata));\n  }\n\n  canLinkElement(element: ElementModel, ct: CancellationToken): Promise<boolean> {\n    const metadata = getEntityMetadata(element, this.entityMetadata);\n    return Promise.resolve(Boolean(metadata));\n  }\n\n  canDeleteLink(link: LinkModel, source: ElementModel, target: ElementModel, ct: CancellationToken): Promise<boolean> {\n    const metadata = getEntityMetadata(source, this.entityMetadata);\n    return Promise.resolve(Boolean(metadata) && metadata.fieldByIri.has(link.linkTypeId));\n  }\n\n  canEditLink(link: LinkModel, source: ElementModel, target: ElementModel, ct: CancellationToken): Promise<boolean> {\n    const metadata = getEntityMetadata(source, this.entityMetadata);\n    return Promise.resolve(Boolean(metadata) && metadata.fieldByIri.has(link.linkTypeId));\n  }\n}\n\nexport class BaseTypeClosureRequest {\n  private static BASE_TYPES_QUERY = SparqlUtil.parseQuerySync<SparqlJs.SelectQuery>(\n    'PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\\n' +\n      'SELECT REDUCED ?type ?base WHERE { ?type rdfs:subClassOf* ?base }'\n  );\n\n  readonly derivedTypes = new Set<ElementTypeIri>();\n\n  addAll(types: ReadonlyArray<ElementTypeIri>) {\n    for (const type of types) {\n      this.derivedTypes.add(type);\n    }\n  }\n\n  query(): Kefir.Property<Map<ElementTypeIri, Set<ElementTypeIri>>> {\n    const values: Array<{ type: Rdf.Iri }> = [];\n    this.derivedTypes.forEach((type) => {\n      values.push({ type: Rdf.iri(type) });\n    });\n    const preparedQuery = SparqlClient.prepareParsedQuery(values)(BaseTypeClosureRequest.BASE_TYPES_QUERY);\n    return SparqlClient.select(preparedQuery).map(({ results }) => {\n      const baseTypes = new Map<ElementTypeIri, Set<ElementTypeIri>>();\n      for (const binding of results.bindings) {\n        const type = binding.type.value as ElementTypeIri;\n        const base = binding.base.value as ElementTypeIri;\n        let baseSet = baseTypes.get(type);\n        if (!baseSet) {\n          baseSet = new Set<ElementTypeIri>();\n          baseTypes.set(type, baseSet);\n        }\n        baseSet.add(base);\n      }\n      return baseTypes;\n    });\n  }\n}\n\nexport function hasCompatibleType(\n  requiredTypes: ReadonlyArray<Rdf.Iri>,\n  targetTypes: ReadonlyArray<ElementTypeIri>,\n  targetTypesClosure: Map<ElementTypeIri, Set<ElementTypeIri>>\n) {\n  for (const targetType of targetTypes) {\n    const closure = targetTypesClosure.get(targetType);\n    for (const requiredType of requiredTypes) {\n      if (closure.has(requiredType.value as ElementTypeIri)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n"],"sourceRoot":""}