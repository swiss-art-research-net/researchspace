{"version":3,"sources":["webpack:///./src/main/web/components/forms/inputs/DatePickerInput.ts"],"names":["INPUT_XSD_DATE_FORMAT","INPUT_XSD_TIME_FORMAT","OUTPUT_UTC_DATE_FORMAT","OUTPUT_UTC_TIME_FORMAT","onDateSelected","value","parsed","parse","utcMoment","localMomentAsIfItWasUtc","mode","getModeFromDatatype","datatype","formattedDate","format","setAndValidate","this","props","definition","xsdDatatype","vocabularies","xsd","dateTime","render","rdfNode","FieldValue","asRdfNode","dateLiteral","dateLiteralFromRdfNode","node","isLiteral","dateString","types","date","time","find","map","type","Rdf","literal","XsdDataTypeValidation","validate","success","localMoment","utcMomentAsIfItWasLocal","localOffset","moment","utcOffset","clone","subtract","local","utcMomentFromRdfLiteral","displayedDate","undefined","placeholder","defaultPlaceholder","valueType","getPreferredLabel","label","toLocaleLowerCase","D","div","className","createElement","DateTimePicker","onChange","closeOnSelect","viewMode","dateFormat","timeFormat","inputProps","ValidationMessages","errors","getErrors","isoDate","length","empty","AtomicValue","set","makeHandler","AtomicValueInput","makeAtomicHandler","parseXsdDatatype","prefix","localName","parsedMoment","utc","isValid","add","DatePickerInput","SingleValueInput","assertStatic"],"mappings":"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","file":"semantic-form-datetime-input-0a9bf5e0a9d08fc1e11c.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { find } from 'lodash';\nimport { createElement } from 'react';\nimport * as D from 'react-dom-factories';\n\nimport * as DateTimePicker from 'react-datetime';\n\nimport * as moment from 'moment';\nimport Moment = moment.Moment;\n\nimport { Rdf, vocabularies, XsdDataTypeValidation } from 'platform/api/rdf';\n\nimport { FieldDefinition, getPreferredLabel } from '../FieldDefinition';\nimport { FieldValue, AtomicValue, EmptyValue } from '../FieldValues';\nimport { SingleValueInput, AtomicValueInput, AtomicValueInputProps } from './SingleValueInput';\nimport { ValidationMessages } from './Decorations';\n\nimport './datetime.scss';\n\n// input format patterns include timezone offset to be compatible with XSD specification\nexport const INPUT_XSD_DATE_FORMAT = 'YYYY-MM-DDZZ';\nexport const INPUT_XSD_TIME_FORMAT = 'HH:mm:ssZZ';\n// output format patterns for UTC moments (without timezone offset), compatible with ISO and XSD\nexport const OUTPUT_UTC_DATE_FORMAT = 'YYYY-MM-DD';\nexport const OUTPUT_UTC_TIME_FORMAT = 'HH:mm:ss';\n\nexport type DatePickerMode = 'date' | 'time' | 'dateTime';\n\nexport interface DatePickerInputProps extends AtomicValueInputProps {\n  mode?: DatePickerMode;\n  placeholder?: string;\n}\n\nexport class DatePickerInput extends AtomicValueInput<DatePickerInputProps, {}> {\n  private get datatype() {\n    return this.props.definition.xsdDatatype || vocabularies.xsd.dateTime;\n  }\n\n  render() {\n    const rdfNode = FieldValue.asRdfNode(this.props.value);\n    const dateLiteral = dateLiteralFromRdfNode(rdfNode);\n    const utcMoment = utcMomentFromRdfLiteral(dateLiteral);\n    // Important! react-datetime becomes really buggy when Moment value\n    // with \"UTC\" internal representation is provided as value, so we need to:\n    // 1. intially convert it to \"local\" internal representation\n    //    as if current time zone was UTC+00;\n    // 2. after date picker returns changed Momeent value we should\n    //    convert it back using `localMomentAsIfItWasUtc()`\n    const localMoment = utcMomentAsIfItWasLocal(utcMoment);\n\n    const mode = this.props.mode || getModeFromDatatype(this.datatype);\n\n    const displayedDate = localMoment\n      ? localMoment\n      : dateLiteral\n      ? dateLiteral.value\n      : rdfNode && rdfNode.isLiteral()\n      ? rdfNode.value\n      : undefined;\n\n    const placeholder =\n      typeof this.props.placeholder === 'undefined'\n        ? defaultPlaceholder(this.props.definition, mode)\n        : this.props.placeholder;\n\n    return D.div(\n      { className: 'date-picker-field' },\n\n      createElement(DateTimePicker, {\n        className: 'date-picker-field__date-picker',\n        onChange: this.onDateSelected, // for keyboard changes\n        closeOnSelect: true,\n        value: displayedDate as any, // TODO: fix typings (value could be Moment)\n        viewMode: mode === 'time' ? 'time' : 'days',\n        dateFormat: mode === 'date' || mode === 'dateTime' ? OUTPUT_UTC_DATE_FORMAT : null,\n        timeFormat: mode === 'time' || mode === 'dateTime' ? OUTPUT_UTC_TIME_FORMAT : null,\n        inputProps: { placeholder },\n      }),\n\n      createElement(ValidationMessages, { errors: FieldValue.getErrors(this.props.value) })\n    );\n  }\n\n  private onDateSelected = (value: string | Moment) => {\n    let parsed;\n    if (typeof value === 'string') {\n      // if user enter a string without using the date picker\n      // we pass direclty to validation\n      parsed = this.parse(value);\n    } else {\n      // otherwise we format to UTC\n      const utcMoment = localMomentAsIfItWasUtc(value);\n      const mode = getModeFromDatatype(this.datatype);\n      const formattedDate =\n        mode === 'date'\n          ? utcMoment.format(OUTPUT_UTC_DATE_FORMAT)\n          : mode === 'time'\n          ? utcMoment.format(OUTPUT_UTC_TIME_FORMAT)\n          : utcMoment.format();\n      parsed = this.parse(formattedDate);\n    }\n    this.setAndValidate(parsed);\n  };\n\n  private parse(isoDate: string): AtomicValue | EmptyValue {\n    if (isoDate.length === 0) {\n      return FieldValue.empty;\n    }\n    return AtomicValue.set(this.props.value, {\n      value: Rdf.literal(isoDate, this.datatype),\n    });\n  }\n\n  static makeHandler = AtomicValueInput.makeAtomicHandler;\n}\n\nexport function getModeFromDatatype(datatype: Rdf.Iri): DatePickerMode {\n  const parsed = XsdDataTypeValidation.parseXsdDatatype(datatype);\n  if (parsed && parsed.prefix === 'xsd') {\n    switch (parsed.localName) {\n      case 'date':\n        return 'date';\n      case 'time':\n        return 'time';\n    }\n  }\n  return 'dateTime';\n}\n\nfunction dateLiteralFromRdfNode(node: Rdf.Node | undefined): Rdf.Literal | undefined {\n  if (!node || !node.isLiteral()) {\n    return undefined;\n  }\n  const dateString = node.value;\n  const types = [vocabularies.xsd.date, vocabularies.xsd.time, vocabularies.xsd.dateTime];\n  return find(\n    types.map((type) => Rdf.literal(dateString, type)),\n    (literal) => XsdDataTypeValidation.validate(literal).success\n  );\n}\n\nexport function utcMomentFromRdfLiteral(literal: Rdf.Literal | undefined): Moment | undefined {\n  if (!literal) {\n    return undefined;\n  }\n  const mode = getModeFromDatatype(literal.datatype);\n  const parsedMoment =\n    mode === 'date'\n      ? moment.utc(literal.value, INPUT_XSD_DATE_FORMAT)\n      : mode === 'time'\n      ? moment.utc(literal.value, INPUT_XSD_TIME_FORMAT)\n      : moment.utc(literal.value);\n  return parsedMoment.isValid() ? parsedMoment : undefined;\n}\n\nfunction utcMomentAsIfItWasLocal(utcMoment: Moment | undefined): Moment | undefined {\n  if (!utcMoment) {\n    return undefined;\n  }\n  const localOffset = moment().utcOffset();\n  return utcMoment.clone().subtract(localOffset, 'm').local();\n}\n\nfunction localMomentAsIfItWasUtc(localMoment: Moment) {\n  const localOffset = moment().utcOffset();\n  return localMoment.clone().utc().add(localOffset, 'm');\n}\n\nfunction defaultPlaceholder(definition: FieldDefinition, mode: DatePickerMode) {\n  const valueType = mode === 'time' ? 'time' : 'date';\n  const fieldName = (getPreferredLabel(definition.label) || valueType).toLocaleLowerCase();\n  return `Select or enter ${fieldName} here...`;\n}\n\nSingleValueInput.assertStatic(DatePickerInput);\n\nexport default DatePickerInput;\n"],"sourceRoot":""}