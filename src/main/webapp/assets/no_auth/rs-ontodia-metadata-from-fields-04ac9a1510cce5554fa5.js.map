{"version":3,"sources":["webpack:///./src/main/web/components/ontodia/MetadataFromFields.tsx"],"names":["render","getRequiredFields","props","ct","Promise","fieldsQuery","observableToCancellablePromise","SparqlClient","select","context","repository","results","fieldIris","bindings","field","isIri","push","configure","fieldByIri","typeField","get","typeIri","Error","labelField","defaultLabelIri","imageField","defaultImageIri","undefined","directTypeSet","Set","forEach","domain","type","add","value","queryAllRelatedTypes","entityTypeSet","entityTypes","Array","from","typeRequest","BaseTypeClosureRequest","addAll","query","typeClosure","entityType","collectedMetadata","has","headFields","otherFields","filter","iri","hasCompatibleType","sortBy","f","order","toArray","entityFields","set","fields","Immutable","Map","map","newSubjectTemplate","defaultSubjectTemplate","datatypeFields","formChildren","React","Component","MetadataFromFields","assertFieldConfigurationItem","ALL_TYPES_QUERY","SparqlUtil","parseQuerySync","values","Rdf","preparedQuery","prepareParsedQuery","relatedTypes","relatedType"],"mappings":"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","file":"rs-ontodia-metadata-from-fields-04ac9a1510cce5554fa5.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2015-2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Immutable from 'immutable';\nimport * as Kefir from 'kefir';\nimport * as React from 'react';\nimport * as SparqlJs from 'sparqljs';\nimport { ElementTypeIri, CancellationToken } from 'ontodia';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { SparqlClient, SparqlUtil } from 'platform/api/sparql';\n\nimport { observableToCancellablePromise } from 'platform/components/3-rd-party/ontodia/AsyncAdapters';\nimport {\n  BaseTypeClosureRequest,\n  hasCompatibleType,\n} from 'platform/components/3-rd-party/ontodia/authoring/FieldBasedMetadataApi';\nimport {\n  FieldConfigurationContext,\n  assertFieldConfigurationItem,\n} from 'platform/components/3-rd-party/ontodia/authoring/FieldConfigurationCommon';\n\nexport interface MetadataFromFieldsProps {\n  /**\n   * Selects applicable fields to create field configuration from.\n   * This query will be sent to the `assets` repository.\n   *\n   * Required output bindings:\n   *   - `?field` - field IRI to include into metadata generation process;\n   *\n   * Default query:\n   * ```\n   * PREFIX field: <http://www.researchspace.org/resource/system/fields/>\n   * SELECT REDUCED ?field WHERE {\n   *   ?field a field:Field\n   * }\n   * ```\n   */\n  fieldsQuery?: string;\n}\n\nconst DEFAULT_FIELDS_QUERY = `PREFIX field: <http://www.researchspace.org/resource/system/fields/>\nSELECT REDUCED ?field WHERE {\n  ?field a field:Field\n}`;\n\n/**\n * Generates metadata configuration for Ontodia based on provided fields.\n *\n * This field configuration item uses domain and range types from all fields to\n * construct full set of sub- and super-classes to use as entities and attaches\n * compatible fields based on the domain (both datatype and object properties).\n */\nexport class MetadataFromFields extends React.Component<MetadataFromFieldsProps, {}> {\n  render(): null {\n    return null;\n  }\n\n  static async getRequiredFields(props: MetadataFromFieldsProps, ct: CancellationToken): Promise<Rdf.Iri[]> {\n    const { fieldsQuery = DEFAULT_FIELDS_QUERY } = props;\n    const { results } = await observableToCancellablePromise(\n      SparqlClient.select(fieldsQuery, { context: { repository: 'assets' } }),\n      ct\n    );\n    const fieldIris: Rdf.Iri[] = [];\n    for (const { field } of results.bindings) {\n      if (field && field.isIri()) {\n        fieldIris.push(field);\n      }\n    }\n    return fieldIris;\n  }\n\n  static async configure(props: MetadataFromFieldsProps, context: FieldConfigurationContext): Promise<void> {\n    const { fieldByIri, cancellationToken: ct } = context;\n\n    const typeField = fieldByIri.get(context.typeIri);\n    if (!typeField) {\n      throw new Error(`<rs-metadata-from-fields>: missing type field <${context.typeIri}>`);\n    }\n    const labelField = fieldByIri.get(context.defaultLabelIri);\n    if (!labelField) {\n      throw new Error(`<rs-metadata-from-fields>: missing label field <${context.defaultLabelIri}>`);\n    }\n    const imageField = context.defaultImageIri ? fieldByIri.get(context.defaultImageIri) : undefined;\n\n    const directTypeSet = new Set<ElementTypeIri>();\n    context.fieldByIri.forEach((field) => {\n      if (field.domain) {\n        for (const type of field.domain) {\n          directTypeSet.add(type.value as ElementTypeIri);\n        }\n      }\n    });\n\n    const entityTypeSet = await observableToCancellablePromise(queryAllRelatedTypes(directTypeSet), ct);\n    const entityTypes = Array.from(entityTypeSet);\n\n    const typeRequest = new BaseTypeClosureRequest();\n    typeRequest.addAll(entityTypes);\n    const typeClosure = await observableToCancellablePromise(typeRequest.query(), ct);\n\n    for (const entityType of entityTypes) {\n      if (context.collectedMetadata.has(entityType)) {\n        continue;\n      }\n\n      const headFields = [typeField, labelField];\n      if (labelField) {\n        headFields.push(imageField);\n      }\n\n      const otherFields = fieldByIri\n        .filter((field) => {\n          if (field.iri === typeField.iri) {\n            return false;\n          }\n          if (field.iri === labelField.iri) {\n            return false;\n          }\n          if (imageField && field.iri === imageField.iri) {\n            return false;\n          }\n          return !field.domain || hasCompatibleType(field.domain, [entityType], typeClosure);\n        })\n        .sortBy((f) => f.iri)\n        .sortBy((f) => f.order)\n        .toArray();\n\n      const entityFields = [...headFields, ...otherFields];\n\n      context.collectedMetadata.set(entityType, {\n        entityType,\n        fields: entityFields,\n        fieldByIri: Immutable.Map(entityFields.map((f) => [f.iri, f] as [string, typeof f])),\n        typeField,\n        newSubjectTemplate: context.defaultSubjectTemplate,\n        labelField,\n        imageField,\n        datatypeFields: Immutable.Set(context.datatypeFields as string[]),\n        formChildren: undefined,\n      });\n    }\n  }\n}\n\nassertFieldConfigurationItem(MetadataFromFields);\n\nconst ALL_TYPES_QUERY = SparqlUtil.parseQuerySync(`\n  PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n  SELECT REDUCED ?relatedType WHERE {\n    { ?type rdfs:subClassOf* ?relatedType }\n    UNION\n    { ?relatedType rdfs:subClassOf* ?type }\n  }`) as SparqlJs.SelectQuery;\n\nfunction queryAllRelatedTypes(directTypeSet: ReadonlySet<ElementTypeIri>): Kefir.Property<Set<ElementTypeIri>> {\n  const values: Array<{ type: Rdf.Iri }> = [];\n  directTypeSet.forEach((type) => {\n    values.push({ type: Rdf.iri(type) });\n  });\n  const preparedQuery = SparqlClient.prepareParsedQuery(values)(ALL_TYPES_QUERY);\n  return SparqlClient.select(preparedQuery).map(({ results }) => {\n    const relatedTypes = new Set<ElementTypeIri>();\n    for (const { relatedType } of results.bindings) {\n      if (relatedType && relatedType.isIri()) {\n        relatedTypes.add(relatedType.value as ElementTypeIri);\n      }\n    }\n    return relatedTypes;\n  });\n}\n\nexport default MetadataFromFields;\n"],"sourceRoot":""}