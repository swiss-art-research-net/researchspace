{"version":3,"sources":["webpack:///./node_modules/hmac-drbg/lib/hmac-drbg.js"],"names":["hash","utils","assert","HmacDRBG","options","this","predResist","outLen","outSize","minEntropy","hmacStrength","_reseed","reseedInterval","K","V","entropy","toArray","entropyEnc","nonce","nonceEnc","pers","persEnc","length","_init","module","exports","prototype","init","seed","concat","Array","i","_update","_hmac","hmac","update","kmac","digest","reseed","add","addEnc","generate","len","enc","Error","temp","res","slice","encode"],"mappings":"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","file":"npm.hmac-drbg-45213d56641a719752de.js","sourcesContent":["'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n"],"sourceRoot":""}