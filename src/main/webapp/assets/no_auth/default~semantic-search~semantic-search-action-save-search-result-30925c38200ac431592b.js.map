{"version":3,"sources":["webpack:///./src/main/web/components/semantic/search/data/search/Serialization.ts"],"names":["serializeConjunct","conjunct","kind","ConjunctKinds","Relation","relation","range","compactIRI","iri","disjuncts","map","serializeRelationDisjunct","uniqueId","Text","text","d","value","Error","disjunct","serializeResource","serialize","serializeState","state","search","this","serializeSearch","undefined","facet","serializeFacet","result","datasets","alignment","graphScopeSearch","domain","conjuncts","ast","resource","SparqlUtil","compactIriUsingPrefix","Serializer","store","deserializeConjunct","conjunctIndex","Array","isArray","deserializeRelation","deserializeCategory","index","deserializeRelationDisjunct","deserializeTextDisjunct","deserializeState","Maybe","Nothing","deserialize","deserializeSearch","deserializeFacet","deserialized","disjunctIndex","length","serialized","deserializeResource","TextDisjunctKind","categoryIri","expandIri","category","categories","get","relationIri","domainIri","rangeIri","relations","RelationKey","key","resolveIris","Deserializer","FullToCompact","type","CompactToFull","invert","deepMapObject","target","propertyMapper","item","Object","keys","mapped","child","packState","rawKey","mapper","startsWith","unpackState","packedKey","substring","baseQuery","packed","packedJson","JSON","stringify","compressToEncodedURIComponent"],"mappings":"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","file":"default~semantic-search~semantic-search-action-save-search-result-30925c38200ac431592b.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { invert } from 'lodash';\nimport { compressToEncodedURIComponent } from 'lz-string';\nimport * as Maybe from 'data.maybe';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { SparqlUtil } from 'platform/api/sparql';\nimport { serialize, deserialize } from 'platform/api/json';\n\nimport { SearchProfileStore } from '../profiles/SearchProfileStore';\nimport * as FacetModel from '../facet/Model';\nimport {\n  Category,\n  Relation,\n  Search,\n  Resource,\n  Conjunct,\n  ConjunctKinds,\n  TextDisjunctKind,\n  RelationConjunct,\n  TextConjunct,\n  RelationDisjunct,\n  TextDisjunct,\n  DisjunctIndex,\n  RelationKey,\n  GraphScopeSearch,\n} from './Model';\nimport { Dataset, Alignment } from '../datasets/Model';\n\nexport interface RawState {\n  search: Search | undefined;\n  facet: FacetModel.Ast;\n  result: { [componentId: string]: object };\n  datasets: Array<Dataset>;\n  alignment: Data.Maybe<Alignment>;\n  graphScopeSearch: Data.Maybe<GraphScopeSearch>;\n}\n\nexport interface SerializedState {\n  search: SerializedSearch;\n  facet: SerializedFacet;\n  result: object;\n  datasets: object;\n  alignment: object;\n  graphScopeSearch: object;\n}\n\ninterface SerializedSearch {\n  domain: string;\n  conjuncts: SerializedConjunct[];\n}\n\ntype SerializedConjunct = {\n  uniqueId: number;\n  relation?: SerializedConjunctBody;\n  text?: SerializedConjunctBody;\n};\n\ninterface SerializedConjunctBody {\n  range: string;\n  disjuncts: SerializedDisjunct[];\n  relation?: string;\n}\n\ntype SerializedDisjunct = [string, any] | string;\n\ntype SerializedFacet = SerializedConjunct[];\n\nexport class Serializer {\n  serializeState(state: RawState): SerializedState {\n    return {\n      search: state.search ? this.serializeSearch(state.search) : undefined,\n      facet: state.facet ? this.serializeFacet(state.facet) : undefined,\n      result: state.result ? serialize(state.result) : undefined,\n      datasets: state.datasets ? serialize(state.datasets) : undefined,\n      alignment: state.alignment ? serialize(state.alignment) : undefined,\n      graphScopeSearch: state.graphScopeSearch ? serialize(state.graphScopeSearch) : undefined,\n    };\n  }\n\n  private serializeSearch(search: Search): SerializedSearch {\n    return {\n      domain: this.compactIRI(search.domain.iri),\n      conjuncts: search.conjuncts.map(this.serializeConjunct),\n    };\n  }\n\n  private serializeFacet(ast: FacetModel.Ast): SerializedFacet {\n    return ast.conjuncts.map(this.serializeConjunct);\n  }\n\n  private serializeConjunct = (conjunct: Conjunct): SerializedConjunct => {\n    if (conjunct.kind === ConjunctKinds.Relation) {\n      const relation = {\n        range: this.compactIRI(conjunct.range.iri),\n        relation: this.compactIRI(conjunct.relation.iri),\n        disjuncts: conjunct.disjuncts.map(this.serializeRelationDisjunct),\n      };\n      return { relation, uniqueId: conjunct.uniqueId };\n    } else if (conjunct.kind === ConjunctKinds.Text) {\n      const text = {\n        range: this.compactIRI(conjunct.range.iri),\n        disjuncts: conjunct.disjuncts.map((d) => d.value),\n      };\n      return { text, uniqueId: conjunct.uniqueId };\n    } else {\n      throw new Error(`Unknown conjunct kind`);\n    }\n  };\n\n  private serializeRelationDisjunct = (disjunct: RelationDisjunct): SerializedDisjunct => {\n    const value = disjunct.kind === 'Resource' ? this.serializeResource(disjunct.value) : serialize(disjunct.value);\n    return [disjunct.kind, value];\n  };\n\n  private serializeResource(resource: Resource): any {\n    // TODO: optimize here\n    return serialize(resource);\n    // return this.compactIRI(disjunct.value.iri);\n  }\n\n  private compactIRI(iri: Rdf.Iri): string {\n    return SparqlUtil.compactIriUsingPrefix(iri);\n  }\n}\n\nexport class Deserializer {\n  constructor(private store: SearchProfileStore) {}\n\n  deserializeState(state: SerializedState): RawState {\n    if (!state || typeof state !== 'object' || !state.search) {\n      return {\n        search: undefined,\n        facet: undefined,\n        result: {},\n        datasets: [],\n        alignment: Maybe.Nothing<Alignment>(),\n        graphScopeSearch: state.graphScopeSearch\n          ? deserialize<Data.Maybe<GraphScopeSearch>>(state.graphScopeSearch)\n          : Maybe.Nothing<GraphScopeSearch>(),\n      };\n    }\n    const result = state.result ? (deserialize(state.result) as any) : undefined;\n    return {\n      search: this.deserializeSearch(state.search),\n      facet: this.deserializeFacet(state.facet, state.search.domain),\n      result: result || {},\n      datasets: state.datasets ? deserialize<Array<Dataset>>(state.datasets) : [],\n      alignment: state.alignment ? deserialize<Data.Maybe<Alignment>>(state.alignment) : Maybe.Nothing<Alignment>(),\n      graphScopeSearch: state.graphScopeSearch\n        ? deserialize<Data.Maybe<GraphScopeSearch>>(state.graphScopeSearch)\n        : Maybe.Nothing<GraphScopeSearch>(),\n    };\n  }\n\n  private deserializeSearch(search: SerializedSearch): Search {\n    return {\n      domain: this.deserializeCategory(search.domain),\n      conjuncts: search.conjuncts.map((conjunct, index) => this.deserializeConjunct(conjunct, index, search.domain)),\n    };\n  }\n\n  private deserializeFacet(facet: SerializedFacet, domain: string): FacetModel.Ast {\n    if (!facet) {\n      return undefined;\n    }\n    const conjuncts = facet.map((conjunct, index) => {\n      const deserialized = this.deserializeConjunct(conjunct, index, domain);\n      if (deserialized.kind !== ConjunctKinds.Relation) {\n        throw new Error(`Unexpected conjunct kind for facet: ${deserialized.kind}`);\n      }\n      return deserialized as FacetModel.FacetRelationConjunct;\n    });\n    return { conjuncts };\n  }\n\n  private deserializeConjunct = (conjunct: SerializedConjunct, conjunctIndex: number, domain: string): Conjunct => {\n    if (conjunct.relation) {\n      const disjuncts = conjunct.relation.disjuncts;\n      if (!(disjuncts && Array.isArray(disjuncts))) {\n        throw new Error('Invalid disjuncts for serialized relation conjunct');\n      }\n      const relational: RelationConjunct = {\n        uniqueId: conjunct.uniqueId,\n        kind: ConjunctKinds.Relation,\n        relation: this.deserializeRelation({\n          iri: conjunct.relation.relation,\n          domain,\n          range: conjunct.relation.range,\n        }),\n        range: this.deserializeCategory(conjunct.relation.range),\n        conjunctIndex: [conjunctIndex],\n        disjuncts: disjuncts.map((disjunct, index) =>\n          this.deserializeRelationDisjunct(disjunct, [conjunctIndex, index])\n        ),\n      };\n      return relational;\n    } else if (conjunct.text) {\n      const disjuncts = conjunct.text.disjuncts;\n      if (!(disjuncts && Array.isArray(disjuncts))) {\n        throw new Error('Invalid disjuncts for serialized text conjunct');\n      }\n      const text: TextConjunct = {\n        uniqueId: conjunct.uniqueId,\n        kind: ConjunctKinds.Text,\n        range: this.deserializeCategory(conjunct.text.range),\n        conjunctIndex: [conjunctIndex],\n        disjuncts: disjuncts.map((disjunct, index) => this.deserializeTextDisjunct(disjunct, [conjunctIndex, index])),\n      };\n      return text;\n    } else {\n      throw new Error('Invalid serialized conjunct');\n    }\n  };\n\n  private deserializeRelationDisjunct(disjunct: SerializedDisjunct, disjunctIndex: DisjunctIndex): RelationDisjunct {\n    if (!(disjunct && Array.isArray(disjunct) && disjunct.length === 2)) {\n      throw new Error('Invalid serialized relation disjunct');\n    }\n    const [kind, serialized] = disjunct;\n    const value = kind === 'Resource' ? this.deserializeResource(serialized) : deserialize(serialized); // is deserialization vulnerable to XSS attacks?\n    return { kind, value, disjunctIndex } as RelationDisjunct;\n  }\n\n  private deserializeTextDisjunct(disjunct: SerializedDisjunct, disjunctIndex: DisjunctIndex): TextDisjunct {\n    if (typeof disjunct !== 'string') {\n      throw new Error('Invalid serialized text disjunct');\n    }\n    return { kind: TextDisjunctKind, value: disjunct, disjunctIndex };\n  }\n\n  private deserializeCategory(iri: string): Category {\n    if (!iri) {\n      throw new Error('Category IRI cannot be empty');\n    }\n    const categoryIri = this.expandIri(iri);\n    const category = this.store.categories.get(categoryIri);\n    if (!category) {\n      throw new Error(`Category not found: ${categoryIri}`);\n    }\n    return category;\n  }\n\n  private deserializeRelation({ iri, domain, range }: { iri: string; domain: string; range: string }): Relation {\n    if (!iri) {\n      throw new Error('Relation IRI cannot be empty');\n    }\n    const relationIri = this.expandIri(iri);\n    const domainIri = this.expandIri(domain);\n    const rangeIri = this.expandIri(range);\n    const relation = this.store.relations.get(\n      RelationKey.key({ iri: relationIri, domain: domainIri, range: rangeIri })\n    );\n    if (!relation) {\n      throw new Error(`Relation not found: ${relationIri}`);\n    }\n    return relation;\n  }\n\n  private deserializeResource(resource: any): Resource {\n    // TODO: optimize here\n    return deserialize<Resource>(resource);\n    // return (?? load by IRI here ??)\n  }\n\n  private expandIri(iri: string): Rdf.Iri {\n    return SparqlUtil.resolveIris([iri])[0];\n  }\n}\n\n/**\n * Mapping between full and compact key representations for\n * `packState` and `unpackState` functions.\n */\nconst FullToCompact: Record<string, string> = {\n  search: 's',\n  facet: 'f',\n  type: 't',\n  domain: 'do',\n  range: 'ra',\n  relation: 're',\n  text: 'te',\n  conjuncts: 'c',\n  disjuncts: 'd',\n  '#type': 'T',\n  '#value': 'V',\n};\n\nconst CompactToFull = invert(FullToCompact) as Record<string, string>;\n\ntype PropertyMapper = (\n  key: string,\n  value: any,\n  mapper: (target: any) => any\n) => { key: string; value: any } | undefined;\n\nfunction deepMapObject(target: any, propertyMapper: PropertyMapper): any {\n  if (target === undefined && target === null) {\n    return target;\n  } else if (Array.isArray(target)) {\n    return target.map((item) => deepMapObject(item, propertyMapper));\n  } else if (typeof target === 'object') {\n    const result: any = {};\n    for (const key of Object.keys(target)) {\n      const value = target[key];\n      const mapped = propertyMapper(key, value, (child) => deepMapObject(child, propertyMapper));\n      if (mapped) {\n        result[mapped.key] = mapped.value;\n      }\n    }\n    return result;\n  } else {\n    return target;\n  }\n}\n\nexport function packState(state: SerializedState): any {\n  return deepMapObject(state, (rawKey, value, mapper) => {\n    let packedKey: string;\n    if (rawKey.startsWith('@') || rawKey in CompactToFull) {\n      packedKey = '@' + rawKey;\n    } else {\n      packedKey = FullToCompact[rawKey] || rawKey;\n    }\n    return { key: packedKey, value: mapper(value) };\n  });\n}\n\nexport function unpackState(state: any): SerializedState {\n  return deepMapObject(state, (packedKey, value, mapper) => {\n    let rawKey: string;\n    if (packedKey.startsWith('@')) {\n      rawKey = packedKey.substring(1);\n    } else {\n      rawKey = CompactToFull[packedKey] || packedKey;\n    }\n    return { key: rawKey, value: mapper(value) };\n  });\n}\n\nexport function serializeSearch(\n  baseQuery: Search,\n  facet?: FacetModel.Ast,\n  result?: { [componentId: string]: object },\n  datasets?: Array<Dataset>,\n  alignment?: Data.Maybe<Alignment>,\n  graphScopeSearch?: Data.Maybe<GraphScopeSearch>\n): string {\n  const serialized = new Serializer().serializeState({\n    search: baseQuery,\n    facet: facet,\n    result: result,\n    datasets,\n    alignment,\n    graphScopeSearch,\n  });\n\n  const packed = packState(serialized);\n  const packedJson = JSON.stringify(packed);\n  return compressToEncodedURIComponent(packedJson);\n}\n"],"sourceRoot":""}