{"version":3,"sources":["webpack:///./src/main/web/components/arguments/FieldSelection.tsx"],"names":["props","context","repositories","getRepositoryStatus","map","repos","keySeq","toArray","fieldsSelection","fields","style","height","ref","component","fieldSelection","multi","multiSelection","clearable","onChange","onFieldSelectionChange","options","field","value","iri","label","getPreferredLabel","state","selectedFields","placeholder","selected","closeMenu","setState","isMultiSelection","filter","_","some","onSave","selectedField","find","fetchFields","record","types","Maybe","Nothing","getExistingFieldsForRecord","onValue","Just","getFieldsForRecord","flatMap","Kefir","combine","checkField","check","toProperty","fieldFilter","repo","executeFieldTestForRepository","repository","query","SparqlUtil","parseQuerySync","selectPattern","askQuery","prefixes","type","queryType","where","SparqlClient","ask","setBindings","subject","FIELDS_QUERY","Sparql","select","prepareParsedQuery","__type__","res","results","bindings","binding","iris","getArgumentsFieldDefinition","componentDidMount","this","componentWillReceiveProps","isEqual","render","isEmpty","getOrElse","React","Component","FieldSelection"],"mappings":"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","file":"default~rs-premise~rs-simple-assertion-082ec9948bdfbadadc23.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2015-2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as React from 'react';\nimport * as Maybe from 'data.maybe';\nimport * as _ from 'lodash';\nimport * as Kefir from 'kefir';\nimport ReactSelect from 'react-select';\nimport * as SparqlJs from 'sparqljs';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { SparqlClient, SparqlUtil } from 'platform/api/sparql';\nimport { getPreferredLabel } from 'platform/components/forms';\nimport { getRepositoryStatus } from 'platform/api/services/repository';\n\nimport { getArgumentsFieldDefinition } from './FieldUtils';\nimport { ArgumentsFieldDefinition } from './ArgumentsApi';\n\nexport interface BaseFieldSelectionProps {\n  record: Rdf.Iri;\n  types: Array<Rdf.Iri>;\n  placeholder: string;\n  onCancel: () => void;\n  multiSelection: boolean;\n\n  /**\n   * Show only fields that satisfy some condition.\n   */\n  fieldFilter?: (field: ArgumentsFieldDefinition) => Kefir.Property<boolean>;\n}\nexport interface MultiFieldSelectionProps extends BaseFieldSelectionProps {\n  onSave: (fields: Array<ArgumentsFieldDefinition>) => void;\n}\nexport interface SingleFieldSelectionProps extends BaseFieldSelectionProps {\n  onSave: (field: ArgumentsFieldDefinition) => void;\n}\nexport type FieldSelectionProps = MultiFieldSelectionProps | SingleFieldSelectionProps;\nfunction isMultiSelection(props: FieldSelectionProps): props is MultiFieldSelectionProps {\n  return props.multiSelection;\n}\n\ninterface SelectedField {\n  value: string;\n  label: string;\n}\n\ninterface State {\n  fields: Data.Maybe<Array<ArgumentsFieldDefinition>>;\n  selectedFields: Array<SelectedField> | SelectedField;\n}\n\ninterface UndocumentedReactSelect {\n  closeMenu?(): void;\n}\n\n/**\n * Provides the ability to select multiple Fields for some Record.\n * 1) Only fields that have range matching type of the Record can be selected.\n * 2) Only fields with canonical values (values from default repository)\n *    for the give record can be selected.\n */\nexport class FieldSelection extends React.Component<FieldSelectionProps, State> {\n  private fieldSelection: ReactSelect;\n  private repositories = getRepositoryStatus().map((repos) => repos.keySeq().toArray());\n\n  constructor(props: FieldSelectionProps, context) {\n    super(props, context);\n    this.state = {\n      fields: Maybe.Nothing<Array<ArgumentsFieldDefinition>>(),\n      selectedFields: props.multiSelection ? [] : null,\n    };\n  }\n\n  componentDidMount() {\n    this.fetchFields(this.props);\n  }\n\n  componentWillReceiveProps(props: FieldSelectionProps) {\n    if (!_.isEqual(props, this.props)) {\n      this.fetchFields(props);\n    }\n  }\n\n  render() {\n    const { fields: maybeFields } = this.state;\n    return maybeFields\n      .map((fields) => (_.isEmpty(fields) ? <p>'No applicable field for the record'</p> : this.fieldsSelection(fields)))\n      .getOrElse(<p>Loading fields ... </p>);\n  }\n\n  private fieldsSelection = (fields: Array<ArgumentsFieldDefinition>) => (\n    <div style={{ height: 400 }}>\n      <ReactSelect\n        ref={(component) => (this.fieldSelection = component)}\n        multi={this.props.multiSelection}\n        clearable={true}\n        onChange={this.onFieldSelectionChange(fields)}\n        options={fields.map((field) => ({ value: field.iri, label: getPreferredLabel(field.label) }))}\n        value={this.state.selectedFields}\n        placeholder={this.props.placeholder}\n      />\n    </div>\n  );\n\n  private onFieldSelectionChange = (fields: Array<ArgumentsFieldDefinition>) => (\n    selected: Array<SelectedField> | SelectedField\n  ) => {\n    (this.fieldSelection as UndocumentedReactSelect).closeMenu();\n    this.setState({ selectedFields: selected });\n    if (isMultiSelection(this.props)) {\n      const multiSelectd = selected as Array<SelectedField>;\n      const selectedFields = fields.filter((field) => _.some(multiSelectd, ({ value }) => field.iri === value));\n      this.props.onSave(selectedFields);\n    } else {\n      const selectedField = fields.find((field) => (selected as SelectedField).value === field.iri);\n      this.props.onSave(selectedField);\n    }\n  };\n\n  private fetchFields = (props: FieldSelectionProps) => {\n    const { record, types } = props;\n    this.setState({ fields: Maybe.Nothing<Array<ArgumentsFieldDefinition>>() });\n    this.getExistingFieldsForRecord(record, types).onValue((fields) => this.setState({ fields: Maybe.Just(fields) }));\n  };\n\n  private getExistingFieldsForRecord = (\n    record: Rdf.Iri,\n    types: Array<Rdf.Iri>\n  ): Kefir.Property<Array<ArgumentsFieldDefinition>> => {\n    const allFields = this.getFieldsForRecord(record, types);\n    return allFields\n      .flatMap((fields) =>\n        Kefir.combine(\n          fields.map((field) =>\n            this.checkField(field).map<[ArgumentsFieldDefinition, boolean]>((check) => [field, check])\n          )\n        )\n      )\n      .map((fields) => fields.filter(([, check]) => check).map(([field]) => field))\n      .toProperty();\n  };\n\n  private checkField = (field: ArgumentsFieldDefinition): Kefir.Property<boolean> => {\n    if (this.props.fieldFilter) {\n      return this.props.fieldFilter(field);\n    } else {\n      return this.repositories\n        .flatMap((repos) => Kefir.combine(repos.map((repo) => this.executeFieldTestForRepository(field, repo))))\n        .map(_.some)\n        .toProperty();\n    }\n  };\n\n  private executeFieldTestForRepository = (field: ArgumentsFieldDefinition, repository: string) => {\n    const query = SparqlUtil.parseQuerySync<SparqlJs.SelectQuery>(field.selectPattern);\n    const askQuery: SparqlJs.AskQuery = {\n      prefixes: query.prefixes,\n      type: 'query',\n      queryType: 'ASK',\n      where: query.where,\n    };\n    return SparqlClient.ask(SparqlClient.setBindings(askQuery, { subject: this.props.record }), {\n      context: { repository: repository },\n    });\n  };\n\n  private FIELDS_QUERY = SparqlUtil.Sparql`\n    SELECT ?field {\n    ?field <http://www.researchspace.org/resource/system/fields/domain> ?__type__ .\n    <http://www.researchspace.org/resource/system/fieldDefinitionContainer> <http://www.w3.org/ns/ldp#contains> ?field .\n    }\n  ` as SparqlJs.SelectQuery;\n  private getFieldsForRecord = (\n    record: Rdf.Iri,\n    types: Array<Rdf.Iri>\n  ): Kefir.Property<Array<ArgumentsFieldDefinition>> => {\n    const fieldIris = SparqlClient.select(\n      SparqlClient.prepareParsedQuery(types.map((type) => ({ __type__: type })))(this.FIELDS_QUERY),\n      { context: { repository: 'assets' } }\n    ).map((res) => res.results.bindings.map((binding) => binding['field'] as Rdf.Iri));\n\n    const fieldsData = fieldIris.flatMap((iris) =>\n      Kefir.combine(iris.map((field) => getArgumentsFieldDefinition(field)))\n    );\n    return fieldsData.toProperty();\n  };\n}\n"],"sourceRoot":""}