{"version":3,"sources":["webpack:///./src/main/web/components/ui/TargetedPopover.tsx"],"names":["props","hovering","onPopoverMount","popover","onPotentialSizeChange","onObservedChildMount","target","observer","disconnect","MutationObserver","observe","subtree","attributes","childList","characterData","findDOMNode","undefined","offsetWidth","offsetHeight","setState","contentSize","width","height","onMouseEnter","restartTimeout","onMouseLeave","onHideByTimeout","onHide","state","render","arrowOffsetLeft","arrowOffsetTop","id","targetLeft","targetTop","popoverSide","arrowAlignment","arrowOffset","children","positionLeft","positionTop","Popover","ref","this","style","whiteSpace","maxWidth","placement","componentDidMount","componentDidUpdate","prevProps","Boolean","componentWillUnmount","clearTimeout","showTimeout","setTimeout","hideTimeout","defaultProps","React","Component","TargetedPopover","choosePopoverSide","targetX","targetY","areaWidth","areaHeight","x","y","topOrLeft"],"mappings":"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","file":"default~field-editor~mp-sparql-query-editor~mp-spin-query-editor~mp-spin-query-template-editor~rs-te~4e92bf49-1c1af54a371823b4b987.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport * as React from 'react';\nimport { findDOMNode } from 'react-dom';\nimport { Popover } from 'react-bootstrap';\n\nexport interface TargetedPopoverProps {\n  id: string;\n  targetLeft: number;\n  targetTop: number;\n  popoverSide: 'left' | 'right' | 'top' | 'bottom';\n  arrowAlignment: 'start' | 'center' | 'end';\n  arrowOffset?: number;\n  onHide?: () => void;\n  hideTimeout?: number;\n}\n\ninterface State {\n  contentSize?: { width: number; height: number };\n}\n\nexport class TargetedPopover extends React.Component<TargetedPopoverProps, State> {\n  static defaultProps: Partial<TargetedPopoverProps> = {\n    arrowOffset: 15,\n    hideTimeout: 2000,\n  };\n\n  private popover: Popover | undefined;\n  private observer: MutationObserver | undefined;\n\n  private hovering = false;\n  private showTimeout: any;\n\n  constructor(props: TargetedPopoverProps) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    const { id, targetLeft, targetTop, popoverSide, arrowAlignment, arrowOffset, children } = this.props;\n    const { contentSize } = this.state;\n\n    let positionLeft = targetLeft;\n    let positionTop = targetTop;\n    let arrowOffsetLeft: number | undefined;\n    let arrowOffsetTop: number | undefined;\n\n    if (contentSize) {\n      switch (popoverSide) {\n        case 'left':\n        case 'right':\n          arrowOffsetTop =\n            arrowAlignment === 'start'\n              ? arrowOffset\n              : arrowAlignment === 'end'\n              ? contentSize.height - arrowOffset\n              : contentSize.height / 2;\n          positionTop -= arrowOffsetTop;\n          break;\n        case 'top':\n        case 'bottom':\n          arrowOffsetLeft =\n            arrowAlignment === 'start'\n              ? arrowOffset\n              : arrowAlignment === 'end'\n              ? contentSize.width - arrowOffset\n              : contentSize.width / 2;\n          positionLeft -= arrowOffsetLeft;\n          break;\n      }\n\n      if (popoverSide === 'left') {\n        positionLeft -= contentSize.width;\n      } else if (popoverSide === 'top') {\n        positionTop -= contentSize.height;\n      }\n    }\n\n    return (\n      <Popover\n        ref={this.onPopoverMount}\n        id={id}\n        style={{ whiteSpace: 'nowrap', maxWidth: 'unset' }}\n        onMouseEnter={this.onMouseEnter}\n        onMouseLeave={this.onMouseLeave}\n        placement={popoverSide}\n        positionLeft={positionLeft}\n        positionTop={positionTop}\n        arrowOffsetLeft={arrowOffsetLeft}\n        arrowOffsetTop={arrowOffsetTop}\n      >\n        <div ref={this.onObservedChildMount}>{children}</div>\n      </Popover>\n    );\n  }\n\n  private onPopoverMount = (popover: Popover | undefined) => {\n    this.popover = popover;\n    this.onPotentialSizeChange();\n  };\n\n  private onObservedChildMount = (target: HTMLElement | undefined) => {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    if (target) {\n      this.observer = new MutationObserver(this.onPotentialSizeChange);\n      this.observer.observe(target, { subtree: true, attributes: true, childList: true, characterData: true });\n      this.onPotentialSizeChange();\n    }\n  };\n\n  private onPotentialSizeChange = () => {\n    const target = this.popover ? (findDOMNode(this.popover) as HTMLElement | undefined) : undefined;\n    if (target) {\n      const width = target.offsetWidth;\n      const height = target.offsetHeight;\n      this.setState(\n        ({ contentSize }): State => {\n          if (!(contentSize && width === contentSize.width && height === contentSize.height)) {\n            return { contentSize: { width, height } };\n          }\n          return null;\n        }\n      );\n    }\n  };\n\n  componentDidMount() {\n    this.restartTimeout();\n  }\n\n  componentDidUpdate(prevProps: TargetedPopoverProps) {\n    if (Boolean(this.props.onHide) !== Boolean(prevProps.onHide)) {\n      this.restartTimeout();\n    }\n  }\n\n  componentWillUnmount() {\n    this.clearTimeout();\n  }\n\n  private onMouseEnter = () => {\n    this.hovering = true;\n    this.restartTimeout();\n  };\n\n  private onMouseLeave = () => {\n    this.hovering = false;\n    this.restartTimeout();\n  };\n\n  private restartTimeout() {\n    this.clearTimeout();\n    if (this.props.onHide && !this.hovering) {\n      this.showTimeout = setTimeout(this.onHideByTimeout, this.props.hideTimeout);\n    }\n  }\n\n  private clearTimeout() {\n    if (this.showTimeout) {\n      clearTimeout(this.showTimeout);\n      this.showTimeout = undefined;\n    }\n  }\n\n  private onHideByTimeout = () => {\n    const { onHide } = this.props;\n    if (onHide && !this.hovering) {\n      onHide();\n    }\n  };\n}\n\nexport function choosePopoverSide(\n  targetX: number,\n  targetY: number,\n  areaWidth: number,\n  areaHeight: number\n): Pick<TargetedPopoverProps, 'popoverSide' | 'arrowAlignment'> {\n  const x = targetX / areaWidth;\n  const y = targetY / areaHeight;\n\n  const topOrRight = y > x;\n  const topOrLeft = y > 1 - x;\n  const popoverSide = topOrRight ? (topOrLeft ? 'top' : 'right') : topOrLeft ? 'left' : 'bottom';\n\n  let arrowAlignment: TargetedPopoverProps['arrowAlignment'] = 'center';\n  if (popoverSide === 'top' || popoverSide === 'bottom') {\n    if (x < 0.1) {\n      arrowAlignment = 'start';\n    } else if (x > 0.9) {\n      arrowAlignment = 'end';\n    }\n  }\n\n  return { popoverSide, arrowAlignment };\n}\n"],"sourceRoot":""}