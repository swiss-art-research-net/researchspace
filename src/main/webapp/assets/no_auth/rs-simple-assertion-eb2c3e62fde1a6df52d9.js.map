{"version":3,"sources":["webpack:///./src/main/web/components/arguments/SimpleAssertion.tsx"],"names":["render","selection","closeMenu","menuTitle","title","types","repositories","TypedSelectionActionComponent","isDisabled","s","length","dialogType","dialogSize","renderDialog","SimpleAssertionDialog","props","defaultProps","React","Component","SimpleAssertion","context","createTargetOptions","selectionIris","_","map","Rdf","iri","getLabels","onValue","labels","targetOptions","toArray","label","i","value","setState","onError","error","targetSelection","targetValue","FormGroup","ControlLabel","targetSelectionLabel","placeholder","targetSelectionPlaceholder","options","onChange","onTargetSelectionChange","fieldSelection","fieldSelectionLabel","FieldSelection","multiSelection","record","state","targetTypes","onCancel","onFieldSelectionChange","onSave","fieldFilter","assertedValues","values","key","ResourceLinkComponent","guessRepository","uri","createAssertionButton","className","Button","onClick","onCreateAssertion","bsStyle","showAssertionDialog","field","filter","Kefir","combine","getTypes","flatten","intersectionBy","t","toProperty","flatMap","valueTypes","constructInitialBeliefs","beliefs","assertion","Maybe","Nothing","belief","type","target","originRepository","beliefType","isCanonical","Immutable","Map","constant","some","vt","range","getRepositoryStatus","repos","keySeq","resource","r","getTypesFromRepository","uniqWith","a","b","equals","TYPES_QUERY","SparqlUtil","Sparql","repository","SparqlClient","select","setBindings","__resource__","result","results","bindings","binding","undefined","componentDidMount","this","QuickAssertionComponent","fieldIri","valueTemplate","formTemplate","editMode","initialBeliefs","postAction","style","height","isEmpty"],"mappings":"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","file":"rs-simple-assertion-eb2c3e62fde1a6df52d9.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2015-2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as React from 'react';\nimport * as Kefir from 'kefir';\nimport * as _ from 'lodash';\nimport { FormGroup, ControlLabel, Button } from 'react-bootstrap';\nimport * as Maybe from 'data.maybe';\nimport ReactSelect, { Option, Options } from 'react-select';\nimport * as Immutable from 'immutable';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { getRepositoryStatus } from 'platform/api/services/repository';\nimport { SparqlClient, SparqlUtil } from 'platform/api/sparql';\nimport { getLabels } from 'platform/api/services/resource-label';\nimport { Component } from 'platform/api/components';\nimport { ResourceLinkComponent } from 'platform/api/navigation/components/ResourceLinkComponent';\nimport { TypedSelectionActionComponent } from 'platform/components/sets/TypedSelectionActionComponent';\nimport { MenuProps } from 'platform/components/ui/selection/SelectionActionProps';\nimport { AllTitleProps, TypeProps } from 'platform/components/sets/TypedSelectionActionProps';\nimport { FieldSelection } from './FieldSelection';\nimport { QuickAssertionComponent } from './QuickAssertionComponent';\nimport { ArgumentsFieldDefinition, AssertedBelief } from './ArgumentsApi';\n\ninterface BaseConfig extends AllTitleProps, TypeProps, MenuProps {\n  selection: Array<string>;\n  targetSelectionPlaceholder?: string;\n  targetSelectionLabel?: string;\n  fieldSelectionLabel?: string;\n  valueTemplate: string;\n  formTemplate: string;\n}\n\ninterface WithFixedField extends BaseConfig {\n  field: string;\n}\n\nexport type SimpleAssertionConfig = BaseConfig | WithFixedField;\n\n/**\n * Component that can be used to quickly initiate assertion from the clipboard.\n *\n * 1) User selects some entities that should be used in the assertion.\n * 2) User triggers action.\n * 3) User selects the entity that is the target of the assertion, all other entities that\n *    were selected as part of step 1. are used as values for the assertion.\n * 4) User selects fields for the assertion. User can select only the field that has\n *    the same domain as a target and the same range that is shared for all values.\n */\nexport class SimpleAssertion extends React.Component<SimpleAssertionConfig, void> {\n  static defaultProps = {\n    menuTitle: 'Quick Assertion',\n    title: 'Assert',\n  };\n\n  render() {\n    const { selection, closeMenu, menuTitle, title, types, repositories } = this.props;\n    return (\n      <TypedSelectionActionComponent\n        title={title}\n        isDisabled={(s) => s.length < 1}\n        selection={selection}\n        menuTitle={menuTitle}\n        repositories={repositories}\n        closeMenu={closeMenu}\n        types={types}\n        dialogType=\"modal\"\n        dialogSize=\"large\"\n        renderDialog={(s) => <SimpleAssertionDialog {...this.props} selection={s} />}\n      />\n    );\n  }\n}\nexport default SimpleAssertion;\n\ninterface State {\n  targetOptions: Options;\n  targetValue?: Option<string>;\n  targetTypes: Array<Rdf.Iri>;\n  valueTypes: Array<Rdf.Iri>;\n  values: Array<Rdf.Iri>;\n  field?: ArgumentsFieldDefinition;\n  showAssertionDialog: boolean;\n  error?: any;\n}\n\nclass SimpleAssertionDialog extends Component<SimpleAssertionConfig, State> {\n  constructor(props, context) {\n    super(props, context);\n    this.state = {\n      showAssertionDialog: false,\n      targetOptions: [],\n      targetValue: undefined,\n      error: undefined,\n      targetTypes: [],\n      valueTypes: [],\n      values: [],\n    };\n  }\n\n  static defaultProps = {\n    targetSelectionPlaceholder: 'Please select the target record for the assertion',\n    targetSelectionLabel: 'Assertion Target Record',\n    fieldSelectionLabel: 'Assertion Field',\n  };\n\n  componentDidMount() {\n    this.createTargetOptions(this.props.selection);\n  }\n\n  private createTargetOptions = (selection: Array<string>) => {\n    const selectionIris = _.map(selection, Rdf.iri);\n    getLabels(selectionIris)\n      .onValue((labels) => {\n        const targetOptions = _.map(labels.toArray(), (label, i) => ({ value: selection[i], label }));\n        this.setState({ targetOptions });\n      })\n      .onError((error) => this.setState({ error: error }));\n  };\n\n  render() {\n    if (this.state.showAssertionDialog) {\n      return (\n        <QuickAssertionComponent\n          fieldIri={this.state.field.iri}\n          target={this.state.targetValue.value}\n          valueTemplate={this.props.valueTemplate}\n          formTemplate={this.props.formTemplate}\n          editMode={false}\n          initialBeliefs={this.constructInitialBeliefs()}\n          postAction=\"redirect\"\n        />\n      );\n    } else {\n      return (\n        <div style={{ height: 400 }}>\n          {this.targetSelection()}\n          {_.isEmpty(this.state.values) ? null : this.assertedValues()}\n          {this.state.targetValue && !_.isEmpty(this.state.targetTypes) ? this.fieldSelection() : null}\n          {_.isEmpty(this.state.values) ? null : this.createAssertionButton()}\n        </div>\n      );\n    }\n  }\n\n  private targetSelection = () => {\n    const { targetOptions, targetValue } = this.state;\n    return (\n      <FormGroup>\n        <ControlLabel>{this.props.targetSelectionLabel}</ControlLabel>\n        <ReactSelect\n          placeholder={this.props.targetSelectionPlaceholder}\n          value={targetValue}\n          options={targetOptions}\n          onChange={this.onTargetSelectionChange}\n        />\n      </FormGroup>\n    );\n  };\n\n  private fieldSelection = () => {\n    const { targetValue } = this.state;\n    return (\n      <FormGroup>\n        <ControlLabel>{this.props.fieldSelectionLabel}</ControlLabel>\n        <FieldSelection\n          multiSelection={false}\n          placeholder=\"Select field for assertion\"\n          record={Rdf.iri(targetValue.value)}\n          types={this.state.targetTypes}\n          onCancel={() => this.onFieldSelectionChange(null)}\n          onSave={this.onFieldSelectionChange}\n          fieldFilter={this.fieldFilter}\n        />\n      </FormGroup>\n    );\n  };\n\n  private assertedValues = () => (\n    <div>\n      <p>Values that will be asserted for the given target:</p>\n      <ul>\n        {_.map(this.state.values, (value) => (\n          <li key={value.value}>\n            <ResourceLinkComponent guessRepository={true} uri={value.value} />\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n\n  private createAssertionButton = () => (\n    <div className=\"pull-right\">\n      <Button onClick={this.onCreateAssertion} bsStyle=\"primary\">\n        Continue\n      </Button>\n    </div>\n  );\n\n  private onCreateAssertion = () => this.setState({ showAssertionDialog: true });\n\n  private onFieldSelectionChange = (field: ArgumentsFieldDefinition) => {\n    this.setState({ field });\n  };\n\n  private onTargetSelectionChange = (targetValue: Option<string>) => {\n    if (targetValue) {\n      const values = _.map(\n        _.filter(this.props.selection, (selection) => selection !== targetValue.value),\n        Rdf.iri\n      );\n\n      // get common types for all values that are going to be asserted\n      const valueTypesProperty = Kefir.combine(_.map(values, this.getTypes))\n        .map(_.flatten)\n        .map((types) => _.intersectionBy(types, (t) => t.value))\n        .toProperty();\n\n      this.getTypes(Rdf.iri(targetValue.value))\n        .flatMap((targetTypes) => valueTypesProperty.map((valueTypes) => ({ targetTypes, valueTypes })))\n        .onValue(({ targetTypes, valueTypes }) => this.setState({ targetTypes, valueTypes, targetValue, values }));\n    } else {\n      this.setState({ targetValue, values: [] });\n    }\n  };\n\n  private constructInitialBeliefs = () => {\n    const beliefs: Array<[Rdf.Node, AssertedBelief]> = _.map(\n      this.state.values,\n      (assertion) =>\n        [\n          assertion,\n          {\n            iri: Maybe.Nothing<Rdf.Iri>(),\n            belief: {\n              type: 'simple',\n              value: 'Agree',\n            },\n            target: Rdf.iri(this.state.targetValue.value),\n            originRepository: 'default',\n            field: this.state.field,\n            beliefType: 'AssertedBelief',\n            targetValue: assertion,\n            isCanonical: false,\n          },\n        ] as [Rdf.Node, AssertedBelief]\n    );\n    return Immutable.Map(beliefs);\n  };\n\n  private fieldFilter = (field: ArgumentsFieldDefinition): Kefir.Property<boolean> => {\n    return Kefir.constant(_.some(this.state.valueTypes, (vt) => vt.value === (field.range as string)));\n  };\n\n  private repositories = getRepositoryStatus().map((repos) => repos.keySeq().toArray());\n  private getTypes = (resource: Rdf.Iri): Kefir.Property<Array<Rdf.Iri>> =>\n    this.repositories\n      .flatMap((repos) => Kefir.combine(repos.map((r) => this.getTypesFromRepository(r, resource))))\n      .map(_.flatten)\n      .map((types) => _.uniqWith(types, (a, b) => a.equals(b)))\n      .toProperty();\n\n  private TYPES_QUERY = SparqlUtil.Sparql`SELECT DISTINCT ?type WHERE { ?__resource__ a ?type }`;\n  private getTypesFromRepository = (repository: string, resource: Rdf.Iri): Kefir.Property<Array<Rdf.Iri>> =>\n    SparqlClient.select(SparqlClient.setBindings(this.TYPES_QUERY, { __resource__: resource }), {\n      context: { repository: repository },\n    }).map((result) => result.results.bindings.map((binding) => binding['type'] as Rdf.Iri));\n}\n"],"sourceRoot":""}