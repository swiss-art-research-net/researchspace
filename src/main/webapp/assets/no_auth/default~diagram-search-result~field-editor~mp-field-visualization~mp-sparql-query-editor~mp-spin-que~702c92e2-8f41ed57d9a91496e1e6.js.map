{"version":3,"sources":["webpack:///./src/main/web/components/forms/FieldDefinition.ts"],"names":["normalizeFieldDefinition","definitionProp","definition","_","cloneDeep","label","Rdf","langLiteral","Array","isArray","categories","map","category","iri","minOccurs","parseInt","maxOccurs","Infinity","order","domain","range","xsdDatatype","datatype","XsdDataTypeValidation","parseXsdDatatype","replaceDatatypeAliases","xsd","anyURI","defaultValues","testSubject","askPattern","sparqlAskContraint","validatePattern","message","constraints","push","getPreferredLabel","selected","selectPreferredLabel","value","undefined"],"mappings":"gIAmBA,YAEA,QACA,SAEA,SA0KA,oCAAgBA,yBAAyBC,GACvC,IAAMC,EAAyDC,EAAEC,UAAUH,GAsD3E,GApDgC,iBAArBC,EAAWG,QACpBH,EAAWG,MAAQ,CAAC,EAAAC,IAAIC,YAAYL,EAAWG,MAAO,MAGpDG,MAAMC,QAAQP,EAAWQ,YAC3BR,EAAWQ,WAAaR,EAAWQ,WAAWC,KAAI,SAACC,GACjD,MAAoB,iBAAbA,EAAwB,EAAAN,IAAIO,IAAID,GAAYA,KAGrDV,EAAWQ,WAAa,GAGrBR,EAAWY,WAAsC,YAAzBZ,EAAWY,UAGtCZ,EAAWY,UAAYC,SAASb,EAAWY,UAAW,IAFtDZ,EAAWY,UAAY,EAKpBZ,EAAWc,WAAsC,YAAzBd,EAAWc,UAGtCd,EAAWc,UAAYD,SAASb,EAAWc,UAAW,IAFtDd,EAAWc,UAAYC,IAKpBf,EAAWgB,OAA8B,YAArBhB,EAAWgB,MAGlChB,EAAWgB,MAAQH,SAASb,EAAWgB,MAAO,IAF9ChB,EAAWgB,MAAQ,EAKY,iBAAtBhB,EAAWiB,OACpBjB,EAAWiB,OAAS,CAAC,EAAAb,IAAIO,IAAIX,EAAWiB,SAC/BX,MAAMC,QAAQP,EAAWiB,UAClCjB,EAAWiB,OAASjB,EAAWiB,OAAOR,KAAI,SAACQ,GACzC,MAAsB,iBAAXA,EACF,EAAAb,IAAIO,IAAIM,GAEVA,MAIqB,iBAArBjB,EAAWkB,MACpBlB,EAAWkB,MAAQ,EAAAd,IAAIO,IAAIX,EAAWkB,OAC7BZ,MAAMC,QAAQP,EAAWkB,SAClClB,EAAWkB,MAAQlB,EAAWkB,MAAMT,KAAI,SAACS,GACvC,MAAqB,iBAAVA,EACF,EAAAd,IAAIO,IAAIO,GAEVA,MAI2B,iBAA3BlB,EAAWmB,YAA0B,CAC9C,IAAMC,EAAW,EAAAC,sBAAsBC,iBAAiBtB,EAAWmB,aACnEnB,EAAWmB,YAAcC,EAAWA,EAAST,IAAM,EAAAP,IAAIO,IAAIX,EAAWmB,aAiBxE,GAdInB,EAAWmB,YACbnB,EAAWmB,YAAc,EAAAE,sBAAsBE,uBAAuBvB,EAAWmB,aACxEnB,EAAWkB,QACpBlB,EAAWmB,YAAc,EAAAK,IAAIC,QAG1BzB,EAAW0B,gBACd1B,EAAW0B,cAAgB,IAGS,iBAA3B1B,EAAW2B,cACpB3B,EAAW2B,YAAc,EAAAvB,IAAIO,IAAIX,EAAW2B,cAGT,iBAA1B3B,EAAW4B,WAAyB,CAC7C,IAAMC,EAAqB,CACzBC,gBAAiB9B,EAAW4B,WAC5BG,QAAS,4CAEPzB,MAAMC,QAAQP,EAAWgC,aAC3BhC,EAAWgC,YAAYC,KAAKJ,GAE5B7B,EAAWgC,YAAc,CAACH,QAElBvB,MAAMC,QAAQP,EAAWgC,eACnChC,EAAWgC,YAAc,IAE3B,OAAOhC,GAWT,6BAAgBkC,kBAAkB/B,GAChC,QAAqB,IAAVA,GAA0C,iBAAVA,EACzC,OAAOA,EAET,IAAMgC,EAAW,EAAAC,qBAAqBjC,GACtC,OAAOgC,EAAWA,EAASE,WAAQC","file":"default~diagram-search-result~field-editor~mp-field-visualization~mp-sparql-query-editor~mp-spin-que~702c92e2-8f41ed57d9a91496e1e6.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as _ from 'lodash';\n\nimport { Rdf, XsdDataTypeValidation } from 'platform/api/rdf';\nimport { xsd } from 'platform/api/rdf/vocabularies/vocabularies';\n\nimport { selectPreferredLabel } from 'platform/api/services/language';\n\nimport { ComplexTreePatterns, LightwightTreePatterns } from 'platform/components/semantic/lazy-tree';\n\nexport interface FieldDefinition {\n  /**\n   * Unique identifier of the field definition,\n   * in most cases it will be the IRI of the field definition, but might be an alias as well.\n   */\n  id: string;\n\n  /**\n   * IRI of field definition.\n   */\n  iri?: string;\n\n  /**\n   * Label used for refering to field on form (e.g. {@link FormErrors}) and\n   * rendering the field, for example as an HTML input label before the input element.\n   */\n  label?: ReadonlyArray<Rdf.Literal>;\n  /**\n   * Description of a field, might be rendered e.g. onHover or\n   * as an info icon next to the field.\n   */\n  description?: string;\n  /**\n   * A set of categories as additional metadata for improved organisation.\n   */\n  categories: ReadonlyArray<Rdf.Iri>;\n  /**\n   * Domain restriction on classes this field applicable to.\n   */\n  domain?: ReadonlyArray<Rdf.Iri>;\n  /**\n   * A full or prefix XSD IRI datatype identifier as specified in RDF 1.1\n   * https://www.w3.org/TR/rdf11-concepts/#xsd-datatypes\n   */\n  xsdDatatype?: Rdf.Iri;\n  /**\n   * Range restriction on allowed classes of objects for the field values.\n   * Only applicable if `xsdDatatype` is `xsd:anyURI`.\n   */\n  range?: ReadonlyArray<Rdf.Iri>;\n  /**\n   * XSD schema minimum cardinality (including).\n   */\n  minOccurs: number;\n  /**\n   * XSD schema maximum cardinality (including).\n   */\n  maxOccurs: number;\n  /**\n   * Number used for ordering Field Definition.\n   */\n  order: number;\n  /**\n   * List of default values assigned to field.\n   */\n  defaultValues: ReadonlyArray<string>;\n  /**\n   * SparQL SELECT query string to read initial values for the field.\n   *\n   * Query bindings:\n   *   $subject refers to the current entity.\n   * Exposed projection variables:\n   *   value: (required) as intial value of the field;\n   *   label: (optional) as label of this value;\n   *   further projection variables might be exposed\n   *     to format the rendering within the input element.\n   */\n  selectPattern?: string;\n  /**\n   * Constraints (SparQL ASK queries) to validate values entered by\n   * the user against the database.\n   */\n  constraints: ReadonlyArray<FieldConstraint>;\n  /**\n   * SparQL SELECT query to generate a fixed list (choices) of values\n   * that the user may choose from.\n   *\n   * Exposed projection variables:\n   *   value: (required) as initial value of the field;\n   *   label: (optional) as label of this value;\n   *   further projection variables might be exposed\n   *     to format the rendering within the input element.\n   */\n  valueSetPattern?: string;\n  /**\n   * SparQL DELETE query to remove previous value from the database\n   * before inserting a new one.\n   *\n   * Query bindings:\n   *   $subject refers to the current entity;\n   *   $value refers to value to remove.\n   */\n  deletePattern?: string;\n  /**\n   * SparQL INSERT query to add new value to the database.\n   *\n   * Query bindings:\n   *   $subject refers to the current entity;\n   *   $value refers to value to insert.\n   */\n  insertPattern?: string;\n  /**\n   * SparQL SELECT query to generate a dynamic suggestion list based on\n   * textindex or regex search.\n   *\n   * Query bindings:\n   *   $token refers to text token the user is typing.\n   * Exposed projection variables:\n   *   value: (required) as initial value of the field;\n   *   label: (optional) as label of this value;\n   *   further projection variables might be exposed\n   *     to format the rendering within the input element.\n   */\n  autosuggestionPattern?: string;\n  /**\n   * Sparql configuration to select terms from an hierarchical thesaurus.\n   * Can be either `simple` or `full` (specified in the `type` attribute).\n   */\n  treePatterns?: TreeQueriesConfig;\n\n  /**\n   * Test subject IRI that is used for forms preview in the field editor.\n   */\n  testSubject?: Rdf.Iri;\n}\n\n/** @see FieldDefinition */\nexport interface FieldDefinitionProp {\n  id: string;\n  iri?: string;\n  label?: string | ReadonlyArray<Rdf.Literal>;\n  description?: string;\n  categories?: ReadonlyArray<string | Rdf.Iri>;\n  domain?: string | Rdf.Iri | ReadonlyArray<string | Rdf.Iri>;\n  xsdDatatype?: string | Rdf.Iri;\n  range?: string | Rdf.Iri | ReadonlyArray<string | Rdf.Iri>;\n  minOccurs?: number | 'unbound';\n  maxOccurs?: number | 'unbound';\n  order?: number | 'unbound';\n  defaultValues?: ReadonlyArray<string>;\n  selectPattern?: string;\n  askPattern?: string;\n  constraints?: ReadonlyArray<FieldConstraint>;\n  valueSetPattern?: string;\n  deletePattern?: string;\n  insertPattern?: string;\n  autosuggestionPattern?: string;\n  treePatterns?: TreeQueriesConfig;\n  testSubject?: string | Rdf.Iri;\n}\n\nexport interface FieldConstraint {\n  validatePattern: string;\n  message: string;\n}\n\nexport type TreeQueriesConfig = SimpleTreeConfig | FullTreeConfig;\n\nexport interface SimpleTreeConfig extends LightwightTreePatterns {\n  type: 'simple';\n}\n\nexport interface FullTreeConfig extends ComplexTreePatterns {\n  type: 'full';\n}\n\nexport function normalizeFieldDefinition(definitionProp: FieldDefinitionProp): FieldDefinition {\n  const definition: { [K in keyof FieldDefinitionProp]?: any } = _.cloneDeep(definitionProp);\n\n  if (typeof definition.label === 'string') {\n    definition.label = [Rdf.langLiteral(definition.label, '')];\n  }\n\n  if (Array.isArray(definition.categories)) {\n    definition.categories = definition.categories.map((category) =>\n      typeof category === 'string' ? Rdf.iri(category) : category\n    );\n  } else {\n    definition.categories = [];\n  }\n\n  if (!definition.minOccurs || definition.minOccurs === 'unbound') {\n    definition.minOccurs = 0;\n  } else {\n    definition.minOccurs = parseInt(definition.minOccurs, 10);\n  }\n\n  if (!definition.maxOccurs || definition.maxOccurs === 'unbound') {\n    definition.maxOccurs = Infinity;\n  } else {\n    definition.maxOccurs = parseInt(definition.maxOccurs, 10);\n  }\n\n  if (!definition.order || definition.order === 'unbound') {\n    definition.order = 0;\n  } else {\n    definition.order = parseInt(definition.order, 10);\n  }\n\n  if (typeof definition.domain === 'string') {\n    definition.domain = [Rdf.iri(definition.domain)];\n  } else if (Array.isArray(definition.domain)) {\n    definition.domain = definition.domain.map((domain) => {\n      if (typeof domain === 'string') {\n        return Rdf.iri(domain);\n      }\n      return domain;\n    });\n  }\n\n  if (typeof definition.range === 'string') {\n    definition.range = Rdf.iri(definition.range);\n  } else if (Array.isArray(definition.range)) {\n    definition.range = definition.range.map((range) => {\n      if (typeof range === 'string') {\n        return Rdf.iri(range);\n      }\n      return range;\n    });\n  }\n\n  if (typeof definition.xsdDatatype === 'string') {\n    const datatype = XsdDataTypeValidation.parseXsdDatatype(definition.xsdDatatype);\n    definition.xsdDatatype = datatype ? datatype.iri : Rdf.iri(definition.xsdDatatype);\n  }\n\n  if (definition.xsdDatatype) {\n    definition.xsdDatatype = XsdDataTypeValidation.replaceDatatypeAliases(definition.xsdDatatype);\n  } else if (definition.range) {\n    definition.xsdDatatype = xsd.anyURI;\n  }\n\n  if (!definition.defaultValues) {\n    definition.defaultValues = [];\n  }\n\n  if (typeof definition.testSubject === 'string') {\n    definition.testSubject = Rdf.iri(definition.testSubject);\n  }\n\n  if (typeof definition.askPattern === 'string') {\n    const sparqlAskContraint = {\n      validatePattern: definition.askPattern,\n      message: 'Value does not pass the SPARQL ASK test.',\n    };\n    if (Array.isArray(definition.constraints)) {\n      definition.constraints.push(sparqlAskContraint);\n    } else {\n      definition.constraints = [sparqlAskContraint];\n    }\n  } else if (!Array.isArray(definition.constraints)) {\n    definition.constraints = [];\n  }\n  return definition as FieldDefinition;\n}\n\n// tslint:disable-next-line:no-unused-variable\nfunction compileTimeAssertDefinitionAssignableToProp(): FieldDefinitionProp {\n  const definition: FieldDefinition = {} as any;\n  // Checks `FieldDefinition` -> `FieldDefinitionProp` assignment compatibility.\n  // (It should be possible to pass \"normalized\" definition to another component.)\n  return definition;\n}\n\nexport function getPreferredLabel(label: string | ReadonlyArray<Rdf.Literal> | undefined): string | undefined {\n  if (typeof label === 'undefined' || typeof label === 'string') {\n    return label;\n  }\n  const selected = selectPreferredLabel(label);\n  return selected ? selected.value : undefined;\n}\n"],"sourceRoot":""}