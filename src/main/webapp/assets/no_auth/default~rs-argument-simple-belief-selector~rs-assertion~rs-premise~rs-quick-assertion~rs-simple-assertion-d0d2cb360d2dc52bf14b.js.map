{"version":3,"sources":["webpack:///./src/main/web/components/arguments/ArgumentsApi.ts"],"names":["SimpleBeliefValue","AssertedBeliefTypeKind","ObservationType","BeliefAdoptionType","InferenceType","BeliefTypeArgumentsKind","ArgumentsBeliefTypeAssertionKind","ArgumentsBeliefTypeFieldKind","ArgumentsContextTypes","changeBelief","PropTypes","any","isRequired","getBeliefValue","removeBelief","matchBelief","matcher","belief","beliefType","matchArgument","argument","argumentType","matchArgumentsBelief","argumentBeliefType"],"mappings":"iIAkBA,YAcA,SAAYA,GACV,gBACA,sBACA,yBAHF,CAAY,EAAAA,oBAAA,EAAAA,kBAAiB,KAkBhB,EAAAC,uBAAyB,iBA0BzB,EAAAC,gBAAkB,cAClB,EAAAC,mBAAqB,iBACrB,EAAAC,cAAgB,YAuBhB,EAAAC,wBAA0B,kBAC1B,EAAAC,iCAAmC,kBACnC,EAAAC,6BAA+B,cA2B/B,EAAAC,sBAAwB,CACnCC,aAAcC,EAAUC,IAAIC,WAC5BC,eAAgBH,EAAUC,IAAIC,WAC9BE,aAAcJ,EAAUC,IAAIC,YAI9B,uBAAgBG,YAAeC,GAC7B,OAAO,SAAUC,GACf,OAAQA,EAAOC,YACb,KAAK,EAAAjB,uBAEL,KAAK,EAAAI,wBACH,OAAOW,EAAQC,EAAOC,YAAYD,MAS1C,yBAAgBE,cAAiBH,GAC/B,OAAO,SAAUI,GACf,OAAQA,EAASC,cACf,KAAK,EAAAjB,cAEL,KAAK,EAAAF,gBAEL,KAAK,EAAAC,mBACH,OAAOa,EAAQI,EAASC,cAAcD,MAU9C,gCAAgBE,qBAAwBN,GACtC,OAAO,SAAUC,GACf,OAAQA,EAAOM,oBACb,KAAK,EAAAjB,iCAEL,KAAK,EAAAC,6BACH,OAAOS,EAAQC,EAAOM,oBAAoBN","file":"default~rs-argument-simple-belief-selector~rs-assertion~rs-premise~rs-quick-assertion~rs-simple-assertion-d0d2cb360d2dc52bf14b.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2015-2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as PropTypes from 'prop-types';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { FieldDefinitionProp } from 'platform/components/forms/FieldDefinition';\n\nexport interface ArgumentsFieldDefinition extends FieldDefinitionProp {\n  iri: string;\n}\n\nexport type BeliefValue = SimpleBelief;\nexport interface SimpleBelief {\n  type: 'simple';\n  value: SimpleBeliefValue;\n}\nexport enum SimpleBeliefValue {\n  Agree = 'Agree',\n  Disagree = 'Disagree',\n  NoOpinion = 'No Opinion',\n}\n\nexport interface BaseBelief {\n  iri: Data.Maybe<Rdf.Iri>;\n  belief: BeliefValue;\n}\n\n// Assertions\nexport interface FieldBasedBelief extends BaseBelief {\n  target: Rdf.Iri;\n  originRepository: string;\n  field: ArgumentsFieldDefinition;\n}\n\nexport const AssertedBeliefTypeKind = 'AssertedBelief';\nexport interface AssertedBelief extends FieldBasedBelief {\n  beliefType: typeof AssertedBeliefTypeKind;\n  targetValue: Rdf.Node;\n  isCanonical: boolean;\n}\n\nexport type Belief = AssertedBelief | ArgumentsBelief;\n\nexport interface Assertion {\n  iri: Data.Maybe<Rdf.Iri>;\n  title: string;\n  note?: string;\n  narrative?: Rdf.Iri;\n  target: Rdf.Iri;\n  field: ArgumentsFieldDefinition;\n  beliefs: Array<AssertedBelief>;\n}\n\nexport type PropositionSet = Array<Proposition>;\nexport type Proposition = Rdf.Triple;\n\n// -- Assertions\n\n// Arguments\nexport type Argument = Observation | BeliefAdoption | Inference;\nexport const ObservationType = 'Observation';\nexport const BeliefAdoptionType = 'BeliefAdoption';\nexport const InferenceType = 'Inference';\nexport type ArgumentType = typeof ObservationType | typeof BeliefAdoptionType | typeof InferenceType;\n\nexport interface BaseArgument {\n  iri: Data.Maybe<Rdf.Iri>;\n  argumentType: ArgumentType;\n  title: string;\n  note?: string;\n  // array of conclusion beliefs IRIs\n  conclusions?: Array<Rdf.Node>;\n}\n\nexport interface Observation extends BaseArgument {\n  argumentType: typeof ObservationType;\n  place: Rdf.Iri;\n  date: Rdf.Literal;\n}\n\nexport interface BeliefAdoption extends BaseArgument {\n  argumentType: typeof BeliefAdoptionType;\n  belief: ArgumentsBelief;\n}\n\nexport const BeliefTypeArgumentsKind = 'ArgumentsBelief';\nexport const ArgumentsBeliefTypeAssertionKind = 'AssertionBelief';\nexport const ArgumentsBeliefTypeFieldKind = 'FieldBelief';\nexport type ArgumentsBeliefType = typeof ArgumentsBeliefTypeAssertionKind | typeof ArgumentsBeliefTypeFieldKind;\nexport type ArgumentsBelief = ArgumentsAssertionBelief | ArgumentsFieldBelief;\nexport interface ArgumentsAssertionBelief extends BaseBelief {\n  beliefType: typeof BeliefTypeArgumentsKind;\n  argumentBeliefType: typeof ArgumentsBeliefTypeAssertionKind;\n  assertion: Rdf.Iri;\n}\n\nexport interface ArgumentsFieldBelief extends FieldBasedBelief {\n  beliefType: typeof BeliefTypeArgumentsKind;\n  argumentBeliefType: typeof ArgumentsBeliefTypeFieldKind;\n}\n\nexport interface Inference extends BaseArgument {\n  argumentType: typeof InferenceType;\n  logicType: Rdf.Iri;\n  premises: Array<ArgumentsAssertionBelief | ArgumentsFieldBelief>;\n}\n// -- Arguments\n\nexport interface ArgumentsContext {\n  changeBelief(belief: AssertedBelief);\n  removeBelief(belief: AssertedBelief);\n  getBeliefValue(forValue: string, isCanonical: boolean): AssertedBelief;\n}\n\nexport const ArgumentsContextTypes = {\n  changeBelief: PropTypes.any.isRequired,\n  getBeliefValue: PropTypes.any.isRequired,\n  removeBelief: PropTypes.any.isRequired,\n};\n\n// helpers\nexport function matchBelief<T>(matcher: BeliefMatcher<T>) {\n  return function (belief: Belief): T {\n    switch (belief.beliefType) {\n      case AssertedBeliefTypeKind:\n        return matcher[belief.beliefType](belief);\n      case BeliefTypeArgumentsKind:\n        return matcher[belief.beliefType](belief);\n    }\n  };\n}\nexport interface BeliefMatcher<T> {\n  AssertedBelief: (belief: AssertedBelief) => T;\n  ArgumentsBelief: (belief: ArgumentsBelief) => T;\n}\n\nexport function matchArgument<T>(matcher: ArgumentMatcher<T>) {\n  return function (argument: Argument): T {\n    switch (argument.argumentType) {\n      case InferenceType:\n        return matcher[argument.argumentType](argument);\n      case ObservationType:\n        return matcher[argument.argumentType](argument);\n      case BeliefAdoptionType:\n        return matcher[argument.argumentType](argument);\n    }\n  };\n}\nexport interface ArgumentMatcher<T> {\n  Inference: (argument: Inference) => T;\n  Observation: (observation: Observation) => T;\n  BeliefAdoption: (beliefAdoption: BeliefAdoption) => T;\n}\n\nexport function matchArgumentsBelief<T>(matcher: ArgumentsBeliefMatcher<T>) {\n  return function (belief: ArgumentsBelief) {\n    switch (belief.argumentBeliefType) {\n      case ArgumentsBeliefTypeAssertionKind:\n        return matcher[belief.argumentBeliefType](belief);\n      case ArgumentsBeliefTypeFieldKind:\n        return matcher[belief.argumentBeliefType](belief);\n    }\n  };\n}\nexport interface ArgumentsBeliefMatcher<T> {\n  AssertionBelief: (belief: ArgumentsAssertionBelief) => T;\n  FieldBelief: (belief: ArgumentsFieldBelief) => T;\n}\n"],"sourceRoot":""}