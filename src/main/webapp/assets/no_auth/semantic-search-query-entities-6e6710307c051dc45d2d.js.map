{"version":3,"sources":["webpack:///./src/main/web/components/semantic/search/web-components/EntitySearch.tsx"],"names":["render","SemanticSearchContext","Consumer","context","EntitySearchInner","props","Component","onSelected","binding","isEmptySelection","setBaseQuery","Maybe","Nothing","query","variableName","resourceBindingName","parsedQuery","SparqlUtil","parseQuerySync","multi","value","map","node","resource","SparqlClient","prepareParsedQuery","setBindings","Just","componentDidMount","setSearchDomain","this","domain","componentWillReceiveProps","searchProfileStore","isJust","isNothing","Error","placeholder","style","className","template","searchQuery","defaultQuery","escapeLuceneSyntax","SimpleSearch","Array","isArray","length","defaultProps","React","EntitySearch"],"mappings":"6IAkBA,QACA,OAGA,QACA,QAEA,UACA,UAEA,UA0EA,sC,+CAQA,OAR2B,4BACzB,uBAAAA,OAAA,sBACE,OACE,gBAAC,EAAAC,sBAAsBC,SAAQ,MAC5B,SAACC,GAAY,uBAACC,EAAiB,cAAK,EAAKC,MAAK,CAAEF,QAASA,SAIlE,aARA,CAA2B,EAAAG,WAc3B,yF,OAyDE,EAAAC,WAAa,SAACC,G,MAEZ,GAAI,EAAKC,iBAAiBD,GACxB,OAAO,EAAKH,MAAMF,QAAQO,aAAaC,EAAMC,WAE/C,IAEIC,EAFEC,EAAe,EAAKT,MAAMU,oBAC1BC,EAAc,EAAAC,WAAWC,eAAqC,EAAKb,MAAMQ,OAG/E,GAAI,EAAKR,MAAMc,MAAO,CAEpB,IAAMC,EAAQZ,EAAQa,KAAI,SAACC,G,MAAS,aAAIR,GAAeQ,EAAKC,SAAQ,KACpEV,EAAQ,EAAAW,aAAaC,mBAAmBL,EAAhC,CAAuCJ,QAG/CH,EAAQ,EAAAW,aAAaE,YAAYV,IAAW,MAAKF,GAAeN,EAAQM,GAAa,IAGvF,EAAKT,MAAMF,QAAQO,aAAaC,EAAMgB,KAAKd,K,EAM/C,OAjFgC,iCAgB9B,4BAAAe,kBAAA,WACE,EAAAC,gBAAgBC,KAAKzB,MAAM0B,OAAQD,KAAKzB,MAAMF,UAGhD,4BAAA6B,0BAAA,SAA0B3B,GAChB,IAAAF,EAAA,EAAAA,QACJA,EAAQ8B,mBAAmBC,QAAU/B,EAAQ4B,OAAOI,WACtD,EAAAN,gBAAgBxB,EAAM0B,OAAQ5B,IAIlC,4BAAAH,OAAA,WACE,IAAK8B,KAAKzB,MAAMQ,MACd,MAAM,IAAIuB,MAAM,6DAGZ,iBACJC,EAAA,EAAAA,YAGAlB,GAFA,EAAAmB,MACA,EAAAC,UACA,EAAApB,OACAqB,EAAA,EAAAA,SACAC,EAAA,EAAAA,YACA1B,EAAA,EAAAA,oBACA2B,EAAA,EAAAA,aACAC,EAAA,EAAAA,mBAEF,OACE,gBAAC,EAAAC,aAAY,CACX/B,MAAO4B,EACPlC,WAAYuB,KAAKvB,WACjBiC,SAAUA,EACVrB,MAAOA,EACPkB,YAAaA,EACbtB,oBAAqBA,EACrB2B,aAAcA,EACdC,mBAAoBA,KA0B1B,4BAAAlC,iBAAA,SAAiBD,GACf,OAAQqC,MAAMC,QAAQtC,KAAaA,EAAQuC,SAAYvC,GA9ElD,kBAAAwC,aAAe,CACpBP,YAAa,oeAUbD,SAAU,8DACVzB,oBAAqB,YAoEzB,kBAjFA,CAAgCkC,EAAM3C,WAmFtC,UAAe4C","file":"semantic-search-query-entities-6e6710307c051dc45d2d.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport * as Maybe from 'data.maybe';\nimport * as React from 'react';\nimport * as SparqlJs from 'sparqljs';\n\nimport { Component } from 'platform/api/components';\nimport { SparqlClient, SparqlUtil } from 'platform/api/sparql';\n\nimport { SimpleSearch, SimpleSearchProps } from '../../simple-search/SimpleSearch';\nimport { setSearchDomain } from '../commons/Utils';\nimport { BaseConfig } from './KeywordSearch';\nimport { SemanticSearchContext, InitialQueryContext } from './SemanticSearchApi';\n\nexport interface SemanticEntitySearchConfig extends BaseConfig<string>, SimpleSearchProps {\n  /**\n   * SPARQL Select query string, which will be provided to the search framework as base query.\n   * The query stringwill be parameterized through the values as selected by the user from\n   * auto-suggestion list, which is generated through the `search-query`. Selected values will be\n   * injected using the same binding variable name as specified by the `resource-binding-name`\n   * attribute i.e. effectively using the same as variable name as returned by the `search-query`.\n   */\n  query: string;\n\n  /**\n     * SPARQL Select query string which is used to provide a autosuggestion list of resources.\n     * Needs to expose result using a projection variable equal to the `resource-binding-name`\n     * attribute.\n     *\n     * @default `PREFIX skos: <http://www.w3.org/2004/02/skos/core#>\n            PREFIX bds: <http://www.bigdata.com/rdf/search#>\n            SELECT ?resource WHERE {\n                ?resource rdfs:label|skos:prefLabel ?label .\n                ?label bds:search ?__token__ ;\n                bds:minRelevance \"0.5\" ;\n                bds:relevance ?score ;\n                bds:matchAllTerms \"true\" .\n                BIND(STRLEN(?label) as ?length)\n            } ORDER BY DESC(?score) ?length`\n     */\n  searchQuery?: string;\n\n  /**\n   * Whether multi-selection of values should be allowed. If set to `true`,\n   * VALUES clause will be used to inject the values into the base `query` for filtering.\n   * If set to `false`, only a single value can be selected from the autosuggestion.\n   * The value will be injected by replacement of the binding variable.\n   *\n   * @default false\n   */\n  multi: boolean;\n\n  /**\n   * Name of the bind variable (whithout question mark), which is returned\n   * (a) as projection variable by the `search-query`\n   * and\n   * (b) used to inject the selected values into the base `query`.\n   *\n   * @default resource\n   */\n  resourceBindingName?: string;\n}\n\ninterface EntitySearchProps extends SemanticEntitySearchConfig {}\n\n/**\n * @example\n <semantic-search>\n  <semantic-search-query-entities\n        domain=\"<http://www.w3.org/2000/01/rdf-schema#Resource>\"\n        template='<span>\n                <mp-label iri=\"{{resource.value}}\"></mp-label> - ({{resource.value}})\n            </span>'\n    multi='true'\n    query='SELECT DISTINCT ?subject WHERE {?subject a ?resource} LIMIT 10'\n    default-query='SELECT DISTINCT ?resource WHERE {?resource a owl:Class} LIMIT 2'\n     >\n  </semantic-search-query-entities>\n\n  <semantic-search-result-holder>\n    <semantic-search-result>\n      <semantic-table id=\"table\" query=\"SELECT ?subject WHERE { }\"></semantic-table>\n    </semantic-search-result>\n  </semantic-search-result-holder>\n</semantic-search>\n */\nclass EntitySearch extends Component<EntitySearchProps, {}> {\n  render() {\n    return (\n      <SemanticSearchContext.Consumer>\n        {(context) => <EntitySearchInner {...this.props} context={context} />}\n      </SemanticSearchContext.Consumer>\n    );\n  }\n}\n\ninterface InnerProps extends EntitySearchProps {\n  context: InitialQueryContext;\n}\n\nclass EntitySearchInner extends React.Component<InnerProps, {}> {\n  static defaultProps = {\n    searchQuery: `PREFIX skos: <http://www.w3.org/2004/02/skos/core#>\n            PREFIX bds: <http://www.bigdata.com/rdf/search#>\n            SELECT ?resource WHERE {\n                ?resource rdfs:label|skos:prefLabel ?label .\n                ?label bds:search ?__token__ ;\n                bds:minRelevance \"0.5\" ;\n                bds:relevance ?score ;\n                bds:matchAllTerms \"true\" .\n                BIND(STRLEN(?label) as ?length)\n            } ORDER BY DESC(?score) ?length`,\n    template: '<span><mp-label iri=\"{{resource.value}}\"></mp-label></span>',\n    resourceBindingName: 'resource',\n  };\n\n  componentDidMount() {\n    setSearchDomain(this.props.domain, this.props.context);\n  }\n\n  componentWillReceiveProps(props: InnerProps) {\n    const { context } = props;\n    if (context.searchProfileStore.isJust && context.domain.isNothing) {\n      setSearchDomain(props.domain, context);\n    }\n  }\n\n  render() {\n    if (!this.props.query) {\n      throw new Error(`The mandatory configuration attribute \"query\" is not set.`);\n    }\n\n    const {\n      placeholder,\n      style,\n      className,\n      multi,\n      template,\n      searchQuery,\n      resourceBindingName,\n      defaultQuery,\n      escapeLuceneSyntax,\n    } = this.props;\n    return (\n      <SimpleSearch\n        query={searchQuery}\n        onSelected={this.onSelected}\n        template={template}\n        multi={multi}\n        placeholder={placeholder}\n        resourceBindingName={resourceBindingName}\n        defaultQuery={defaultQuery}\n        escapeLuceneSyntax={escapeLuceneSyntax}\n      ></SimpleSearch>\n    );\n  }\n\n  onSelected = (binding: SparqlClient.Binding & SparqlClient.Binding[]) => {\n    // reset search if selection is emtpy e.g. after removal of initial selections\n    if (this.isEmptySelection(binding)) {\n      return this.props.context.setBaseQuery(Maybe.Nothing());\n    }\n    const variableName = this.props.resourceBindingName;\n    const parsedQuery = SparqlUtil.parseQuerySync<SparqlJs.SelectQuery>(this.props.query);\n    let query;\n\n    if (this.props.multi) {\n      // use values clause for multi value parameterization i.e. filtering\n      const value = binding.map((node) => ({ [variableName]: node.resource }));\n      query = SparqlClient.prepareParsedQuery(value)(parsedQuery);\n    } else {\n      // use setBinding i.e. replacement for single selection paramerization\n      query = SparqlClient.setBindings(parsedQuery, { [variableName]: binding[variableName] });\n    }\n\n    this.props.context.setBaseQuery(Maybe.Just(query));\n  };\n\n  isEmptySelection(binding: SparqlClient.Binding & SparqlClient.Binding[]) {\n    return (Array.isArray(binding) && !binding.length) || !binding;\n  }\n}\n\nexport default EntitySearch;\n"],"sourceRoot":""}