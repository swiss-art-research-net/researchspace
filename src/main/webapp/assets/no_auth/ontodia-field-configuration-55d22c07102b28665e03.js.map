{"version":3,"sources":["webpack:///./src/main/web/components/3-rd-party/ontodia/authoring/OntodiaFieldConfiguration.ts"],"names":["render","Component","OntodiaFieldConfiguration","extractFieldConfiguration","props","ct","Promise","collectedMetadata","Map","collectedInputOverrides","fieldByIri","Immutable","datatypeFields","authoringMode","enforceConstraints","metadata","undefined","persistence","allFields","inputOverrides","typeIri","defaultLabelIri","defaultImageIri","defaultSubjectTemplate","allowRequestFields","passedFields","forceDatatypeFields","Error","steps","Children","toArray","children","filter","child","isValidChild","isConfigurationItem","type","configure","requestedFields","requestedFieldSet","Set","field","add","iri","has","push","Rdf","step","getRequiredFields","fieldIri","value","length","map","toString","join","observableToCancellablePromise","FieldService","getGeneratedFieldDefinitions","fetchedFields","concat","rawField","Forms","normalizeFieldDefinition","id","datatypeFieldIri","set","get","context","cancellationToken","finalConfig","Boolean","size","valueSeq","debug","console","log"],"mappings":"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","file":"ontodia-field-configuration-55d22c07102b28665e03.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { Children, ReactNode } from 'react';\nimport * as Immutable from 'immutable';\nimport { ElementTypeIri, CancellationToken } from 'ontodia';\n\nimport { Component } from 'platform/api/components';\nimport { Rdf } from 'platform/api/rdf';\nimport * as FieldService from 'platform/api/services/ldp-field';\n\nimport * as Forms from 'platform/components/forms';\nimport { isValidChild } from 'platform/components/utils';\n\nimport { observableToCancellablePromise } from '../AsyncAdapters';\nimport {\n  EntityMetadata,\n  FieldConfiguration,\n  FieldConfigurationContext,\n  FieldConfigurationItem,\n  OntodiaPersistenceMode,\n} from './FieldConfigurationCommon';\n\nexport interface OntodiaFieldConfigurationConfig {\n  /**\n   * Switches Ontodia to authoring mode.\n   *\n   * Authoring mode requires entity metadata to be specified (using semantic forms as children)\n   * in order to work.\n   */\n  authoringMode?: boolean;\n\n  /**\n   * Defines persistence mode to use in authoring mode.\n   * @default {type: \"form\"}\n   */\n  persistence?: OntodiaPersistenceMode;\n\n  /**\n   * Renders debug info into DOM when placed as stand-alone component and also to the console.\n   * @default false\n   */\n  debug?: boolean;\n\n  /**\n   * Fields to be used in Ontodia instance. Could be populated inline or with backend helper.\n   * @see Reading Field Definitions from the Database from Help:SemanticForm\n   */\n  fields?: ReadonlyArray<Forms.FieldDefinitionProp>;\n\n  /**\n   * Allows to fetch field definitions from the backend API.\n   * @default true\n   */\n  allowRequestFields?: boolean;\n\n  /**\n   * Field that is used for entity type. In most cases field should use rdf:type as a property.\n   */\n  typeIri: string;\n\n  /**\n   * Default field to be used for entity label\n   */\n  defaultLabelIri?: string;\n\n  /**\n   * Default field to be used for entity image\n   */\n  defaultImageIri?: string;\n\n  /**\n   * Default template to create Iri for new entities.\n   * @see new-subject-template from Help:SemanticForm\n   */\n  defaultSubjectTemplate?: string;\n\n  /**\n   * Forces certain fields of xsd:anyUri datatype to be treated as entity properties\n   * to be modified inside entity form instead of object properties treated and modified\n   * as an edge in the graph, like entity image Iri, or some vocabulary reference.\n   */\n  forceDatatypeFields?: ReadonlyArray<string>;\n\n  /**\n   * Allow user to persist changes only if there are no validation errors.\n   *\n   * @default false\n   */\n  enforceConstraints?: boolean;\n\n  /**\n   * Children can be either ontodia-entity-metadata or ontodia-field-input-override\n   */\n  readonly children: object;\n}\n\nexport interface OntodiaFieldConfigurationProps extends OntodiaFieldConfigurationConfig {\n  readonly children: ReactNode & object;\n}\n\nexport class OntodiaFieldConfiguration extends Component<OntodiaFieldConfigurationProps, {}> {\n  render(): null {\n    return null;\n  }\n}\n\nexport async function extractFieldConfiguration(\n  props: OntodiaFieldConfigurationProps | undefined,\n  ct: CancellationToken\n): Promise<FieldConfiguration> {\n  const collectedMetadata = new Map<ElementTypeIri, EntityMetadata>();\n  const collectedInputOverrides: Forms.InputOverride[] = [];\n\n  let fieldByIri = Immutable.Map<string, Forms.FieldDefinition>();\n  const datatypeFields = new Map<string, Forms.FieldDefinition>();\n\n  if (!props) {\n    return {\n      authoringMode: false,\n      enforceConstraints: false,\n      metadata: undefined,\n      persistence: undefined,\n      allFields: [],\n      datatypeFields,\n      inputOverrides: collectedInputOverrides,\n    };\n  }\n\n  const {\n    typeIri,\n    defaultLabelIri,\n    defaultImageIri,\n    defaultSubjectTemplate,\n    allowRequestFields = true,\n    fields: passedFields = [],\n    forceDatatypeFields = [],\n    enforceConstraints = false,\n  } = props;\n  if (typeof typeIri !== 'string') {\n    throw new Error(`Missing 'typeIri' property for ontodia-field-configuration`);\n  }\n\n  type ConfigurationStep = {\n    props: object;\n    type: FieldConfigurationItem;\n  };\n  const steps = Children.toArray(props.children).filter(\n    (child): child is ConfigurationStep => isValidChild(child) && isConfigurationItem(child.type)\n  );\n\n  const requestedFields: Rdf.Iri[] = [];\n  const requestedFieldSet = new Set<string>();\n  for (const field of passedFields) {\n    // do not request fields that were passed manually in the props\n    requestedFieldSet.add(field.iri);\n  }\n\n  if (!requestedFieldSet.has(typeIri)) {\n    requestedFieldSet.add(typeIri);\n    requestedFields.push(Rdf.iri(typeIri));\n  }\n\n  // find all required fields from each configuration item\n  for (const step of steps) {\n    if (step.type.getRequiredFields) {\n      for (const fieldIri of await step.type.getRequiredFields(step.props, ct)) {\n        if (requestedFieldSet.has(fieldIri.value)) {\n          continue;\n        }\n        requestedFieldSet.add(fieldIri.value);\n        requestedFields.push(fieldIri);\n      }\n    }\n  }\n\n  let allFields = passedFields;\n  if (requestedFields.length > 0) {\n    if (!allowRequestFields) {\n      throw new Error(\n        'Fetching following fields is disallowed by configuration:\\n' +\n          requestedFields.map((iri) => iri.toString()).join(',\\n')\n      );\n    }\n    const fetchedFields = await observableToCancellablePromise(\n      FieldService.getGeneratedFieldDefinitions(requestedFields),\n      ct\n    );\n    allFields = allFields.concat(fetchedFields);\n  }\n\n  fieldByIri = Immutable.Map(\n    allFields.map((rawField) => {\n      let field = Forms.normalizeFieldDefinition(rawField);\n      // replace field ID by field IRI\n      field = { ...field, id: field.iri };\n      return [field.iri, field] as [string, Forms.FieldDefinition];\n    })\n  );\n\n  for (const datatypeFieldIri of forceDatatypeFields) {\n    datatypeFields.set(datatypeFieldIri, fieldByIri.get(datatypeFieldIri));\n  }\n\n  const context: FieldConfigurationContext = {\n    fieldByIri,\n    typeIri,\n    defaultLabelIri,\n    defaultImageIri,\n    defaultSubjectTemplate,\n    datatypeFields: forceDatatypeFields,\n    cancellationToken: ct,\n    collectedMetadata,\n    collectedInputOverrides,\n  };\n\n  // execute configuration steps from each configuration item\n  for (const step of steps) {\n    await step.type.configure(step.props, context);\n  }\n\n  const finalConfig: FieldConfiguration = {\n    authoringMode: props ? Boolean(props.authoringMode) : false,\n    enforceConstraints,\n    metadata: collectedMetadata.size > 0 ? collectedMetadata : undefined,\n    persistence: props ? props.persistence : undefined,\n    allFields: fieldByIri.valueSeq().toArray(),\n    datatypeFields,\n    inputOverrides: collectedInputOverrides,\n  };\n  if (props.debug) {\n    console.log('Ontodia field configuration:', finalConfig);\n  }\n  return finalConfig;\n}\n\nfunction isConfigurationItem(type: unknown): type is FieldConfigurationItem {\n  if (typeof type !== 'function') {\n    return false;\n  }\n  return typeof (type as Partial<FieldConfigurationItem>).configure === 'function';\n}\n\nexport default OntodiaFieldConfiguration;\n"],"sourceRoot":""}