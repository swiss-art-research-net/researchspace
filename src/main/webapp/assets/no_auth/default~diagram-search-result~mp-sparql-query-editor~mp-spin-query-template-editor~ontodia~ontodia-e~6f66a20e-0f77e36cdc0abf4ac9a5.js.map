{"version":3,"sources":["webpack:///./src/main/web/components/forms/inputs/SingleValueInput.ts"],"names":["props","context","dataState","DataState","Ready","canEdit","this","Verifying","assertStatic","constructor","getHandlerOrDefault","componentType","handlerProps","makeHandler","SingleValueInput","defaultHandler","inputKind","InputKind","validate","value","finalize","owner","Kefir","constant","Component","AtomicValueHandler","assertAtomicOrEmpty","componentWillReceiveProps","setAndValidate","updateValue","handler","makeAtomicHandler","AtomicValueInput","definition","selected","atomic","FieldValue","isEmpty","newValue","validateType","xsdDatatype","AtomicValue","set","errors","filter","error","kind","ErrorKind","Input","Validation","toList","concat","getErrors","isAtomic","Error","datatype","empty","fromLabeled","XsdDataTypeValidation","sameXsdDatatype","vocabularies","xsd","anyURI","isLiteral","literal","withInputError","datatypeToString","validation","Rdf","success","message","coerced","coerceTo","_string","rdf","langString","label","FieldError","noErrors","push"],"mappings":"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","file":"default~diagram-search-result~mp-sparql-query-editor~mp-spin-query-template-editor~ontodia~ontodia-e~6f66a20e-0f77e36cdc0abf4ac9a5.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\n\nimport { Component } from 'platform/api/components';\nimport { Rdf, vocabularies, XsdDataTypeValidation } from 'platform/api/rdf';\n\nimport { FieldDefinition } from '../FieldDefinition';\nimport {\n  FieldValue,\n  AtomicValue,\n  CompositeValue,\n  LabeledValue,\n  EmptyValue,\n  DataState,\n  FieldError,\n  ErrorKind,\n} from '../FieldValues';\n\nimport { InputKind } from './InputCommpons';\n\nexport interface SingleValueInputProps {\n  /** Key to associate with FieldDefinition by name */\n  for?: string;\n  handler?: SingleValueHandler;\n  definition?: FieldDefinition;\n  dataState?: DataState;\n  value?: FieldValue;\n  updateValue?: (reducer: (value: FieldValue) => FieldValue) => void;\n  /** @see MultipleValuesProps.renderHeader */\n  renderHeader?: boolean;\n}\n\nexport interface SingleValueHandler {\n  validate(value: FieldValue): FieldValue;\n  finalize(value: FieldValue, owner: EmptyValue | CompositeValue): Kefir.Property<FieldValue>;\n  finalizeSubject?(value: FieldValue, owner: EmptyValue | CompositeValue): CompositeValue;\n}\n\nexport interface SingleValueHandlerProps<InputProps> {\n  definition: FieldDefinition | undefined;\n  baseInputProps: InputProps;\n}\n\ninterface SingleValueInputStatic {\n  makeHandler(props: SingleValueHandlerProps<any>): SingleValueHandler;\n}\n\nexport abstract class SingleValueInput<P extends SingleValueInputProps, S> extends Component<P, S> {\n  public static readonly inputKind: InputKind = InputKind.SingleValueInput;\n\n  constructor(props: P, context: any) {\n    super(props, context);\n  }\n\n  dataState(): DataState {\n    return DataState.Ready;\n  }\n\n  protected canEdit() {\n    const dataState = this.props.dataState;\n    return dataState === DataState.Ready || dataState === DataState.Verifying;\n  }\n\n  static readonly defaultHandler: SingleValueHandler = {\n    validate: (value) => value,\n    finalize: (value, owner) => Kefir.constant(value),\n  };\n\n  static assertStatic(constructor: SingleValueInputStatic) {\n    /* nothing */\n  }\n\n  static getHandlerOrDefault(\n    componentType: Partial<SingleValueInputStatic>,\n    handlerProps: SingleValueHandlerProps<any>\n  ): SingleValueHandler {\n    if (!(componentType && componentType.makeHandler)) {\n      return SingleValueInput.defaultHandler;\n    }\n    return componentType.makeHandler(handlerProps);\n  }\n}\n\nexport interface AtomicValueInputProps extends SingleValueInputProps {\n  value?: AtomicValue | EmptyValue;\n}\n\nexport class AtomicValueInput<P extends AtomicValueInputProps, S> extends SingleValueInput<P, S> {\n  constructor(props: P, context: any) {\n    super(props, context);\n    AtomicValueHandler.assertAtomicOrEmpty(props.value);\n  }\n\n  componentWillReceiveProps(props: P) {\n    AtomicValueHandler.assertAtomicOrEmpty(props.value);\n  }\n\n  protected setAndValidate(value: FieldValue) {\n    this.props.updateValue(() => this.props.handler.validate(value));\n  }\n\n  static makeAtomicHandler(props: SingleValueHandlerProps<AtomicValueInputProps>) {\n    return new AtomicValueHandler(props);\n  }\n}\n\nexport class AtomicValueHandler implements SingleValueHandler {\n  private definition: FieldDefinition;\n\n  constructor(props: SingleValueHandlerProps<AtomicValueInputProps>) {\n    this.definition = props.definition;\n  }\n\n  validate(selected: EmptyValue): EmptyValue;\n  validate(selected: FieldValue): AtomicValue;\n  validate(selected: FieldValue): AtomicValue | EmptyValue {\n    const atomic = AtomicValueHandler.assertAtomicOrEmpty(selected);\n    if (FieldValue.isEmpty(atomic)) {\n      return atomic;\n    }\n    const newValue = validateType(atomic, this.definition.xsdDatatype);\n    return AtomicValue.set(newValue, {\n      // preserve non-validation errors\n      errors: atomic.errors\n        .filter((error) => error.kind !== ErrorKind.Input && error.kind !== ErrorKind.Validation)\n        .toList()\n        .concat(FieldValue.getErrors(newValue)),\n    });\n  }\n\n  static assertAtomicOrEmpty(value: FieldValue): AtomicValue | EmptyValue {\n    if (FieldValue.isEmpty(value) || FieldValue.isAtomic(value)) {\n      return value;\n    } else {\n      throw new Error('Expected atomic or empty value');\n    }\n  }\n\n  finalize(value: FieldValue, owner: EmptyValue | CompositeValue) {\n    return SingleValueInput.defaultHandler.finalize(value, owner);\n  }\n}\n\nexport function validateType(selected: LabeledValue, datatype: Rdf.Iri | undefined): AtomicValue | EmptyValue {\n  if (!selected.value) {\n    return FieldValue.empty;\n  }\n  if (!datatype) {\n    return FieldValue.fromLabeled(selected);\n  }\n\n  if (XsdDataTypeValidation.sameXsdDatatype(datatype, vocabularies.xsd.anyURI)) {\n    if (selected.value.isLiteral()) {\n      const literal = selected.value as Rdf.Literal;\n      return withInputError(\n        selected,\n        `Selected value is ${XsdDataTypeValidation.datatypeToString(literal.datatype)} ` + `where IRI expected`\n      );\n    } else {\n      const validation: XsdDataTypeValidation.ValidationResult = XsdDataTypeValidation.validate(\n        Rdf.literal(selected.value.value, vocabularies.xsd.anyURI)\n      );\n      if (validation.success) {\n        return FieldValue.fromLabeled(selected);\n      } else {\n        return withInputError(selected, validation.message);\n      }\n    }\n  } else {\n    if (selected.value.isLiteral()) {\n      const literal = selected.value as Rdf.Literal;\n      const coerced = coerceTo(datatype, literal);\n      if (coerced) {\n        const validation = XsdDataTypeValidation.validate(coerced);\n        if (validation.success) {\n          return FieldValue.fromLabeled({ value: coerced, label: selected.label });\n        } else {\n          return withInputError({ value: coerced, label: selected.label }, validation.message);\n        }\n      } else {\n        return withInputError(\n          selected,\n          `XSD datatype of selected value is ` +\n            `${XsdDataTypeValidation.datatypeToString(literal.datatype)} where ` +\n            `${XsdDataTypeValidation.datatypeToString(datatype)} expected`\n        );\n      }\n    } else {\n      return withInputError(\n        selected,\n        `Selected value is IRI where ${XsdDataTypeValidation.datatypeToString(datatype)} expected`\n      );\n    }\n  }\n}\n\nfunction coerceTo(datatype: Rdf.Iri, value: Rdf.Literal): Rdf.Literal {\n  if (XsdDataTypeValidation.sameXsdDatatype(datatype, value.datatype)) {\n    return value;\n  } else if (\n    XsdDataTypeValidation.sameXsdDatatype(datatype, vocabularies.xsd._string) &&\n    XsdDataTypeValidation.sameXsdDatatype(value.datatype, vocabularies.rdf.langString)\n  ) {\n    // langString -> string\n    return Rdf.literal(value.value, datatype);\n  } else if (\n    XsdDataTypeValidation.sameXsdDatatype(datatype, vocabularies.rdf.langString) &&\n    XsdDataTypeValidation.sameXsdDatatype(value.datatype, vocabularies.xsd._string)\n  ) {\n    // string -> langString\n    return value;\n  } else {\n    return undefined;\n  }\n}\n\nfunction withInputError(value: LabeledValue, error: string) {\n  return FieldValue.fromLabeled(\n    value,\n    FieldError.noErrors.push({\n      kind: ErrorKind.Input,\n      message: error,\n    })\n  );\n}\n"],"sourceRoot":""}