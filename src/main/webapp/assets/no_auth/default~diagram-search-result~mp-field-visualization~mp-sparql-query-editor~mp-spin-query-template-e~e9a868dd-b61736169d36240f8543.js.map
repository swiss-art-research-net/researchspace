{"version":3,"sources":["webpack:///./src/main/web/components/forms/FieldValues.ts"],"names":["ErrorKind","FieldError","EmptyValue","AtomicValue","DataState","CompositeValue","LabeledValue","set","source","props","SparqlBindingValue","noErrors","Immutable","List","isPreventSubmit","error","kind","Configuration","Input","Validation","kindToString","Loading","type","Error","value","errors","mergeDataState","a","b","Verifying","Ready","FieldState","empty","values","undefined","isPlaceholder","subject","length","FieldValue","unknownFieldType","isEmpty","isAtomic","isComposite","fromLabeled","label","isForcedDefault","asRdfNode","getErrors","setErrors","replaceError","v","nonEmpty","Rdf","iri","push"],"mappings":"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","file":"default~diagram-search-result~mp-field-visualization~mp-sparql-query-editor~mp-spin-query-template-e~e9a868dd-b61736169d36240f8543.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Immutable from 'immutable';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { SparqlClient } from 'platform/api/sparql';\n\nimport { FieldDefinition } from './FieldDefinition';\n\nexport interface LabeledValue {\n  readonly value: Rdf.Node;\n  readonly label?: string;\n  readonly isForcedDefault?: boolean;\n}\nexport namespace LabeledValue {\n  export function set(source: LabeledValue, props: Partial<LabeledValue>): LabeledValue {\n    return { ...source, ...props };\n  }\n}\n\n/**\n * Extension of the LabeledValue carrying the original SPARQL result bindings i.e.\n * if LabeledValue is constructed from SPARQL select query (as for example for the valueSet)\n * we can still access the original bindings, for example, for custom renderings in the dropdown.\n */\nexport interface SparqlBindingValue extends LabeledValue {\n  readonly binding: SparqlClient.Binding;\n}\nexport namespace SparqlBindingValue {\n  export function set(source: SparqlBindingValue, props: Partial<SparqlBindingValue>): SparqlBindingValue {\n    return { ...source, ...props };\n  }\n}\n\nexport enum ErrorKind {\n  /**\n   * Error in form configuration (e.g. invalid or missing FieldDefinition)\n   */\n  Configuration,\n  /**\n   * Error happened while form was loading (e.g. invalid 'selectPattern')\n   */\n  Loading,\n  /**\n   * Invalid value found by input component (e.g. wrong XSD datatype)\n   */\n  Input,\n  /**\n   * Invalid value found by form validation (e.g. by 'askPattern')\n   */\n  Validation,\n}\n\nexport interface FieldError {\n  readonly kind: ErrorKind;\n  readonly message: string;\n}\nexport namespace FieldError {\n  export const noErrors = Immutable.List<FieldError>();\n\n  export function isPreventSubmit(error: FieldError) {\n    return (\n      error.kind === ErrorKind.Configuration || error.kind === ErrorKind.Input || error.kind === ErrorKind.Validation\n    );\n  }\n\n  export function kindToString(kind: ErrorKind) {\n    switch (kind) {\n      case ErrorKind.Configuration:\n        return 'configuration';\n      case ErrorKind.Loading:\n        return 'loading';\n      case ErrorKind.Input:\n        return 'input';\n      case ErrorKind.Validation:\n        return 'validation';\n      default:\n        return 'unknown';\n    }\n  }\n}\n\nexport interface EmptyValue {\n  type: 'empty';\n}\nexport namespace EmptyValue {\n  export const type = 'empty';\n}\n\nexport interface AtomicValue extends LabeledValue {\n  readonly type: 'atomic';\n  readonly errors: Immutable.List<FieldError>;\n}\nexport namespace AtomicValue {\n  export const type = 'atomic';\n\n  export function set(source: AtomicValue | EmptyValue, props: Partial<AtomicValue>): AtomicValue {\n    if (source.type === EmptyValue.type && !('value' in props)) {\n      throw new Error('AtomicValue.value is required to create AtomicValue from EmptyValue');\n    } else if ('value' in props && !props.value) {\n      throw new Error('AtomicValue.value cannot be null or undefined');\n    } else if ('errors' in props && !props.errors) {\n      throw new Error('AtomicValue.errors cannot be null or undefined');\n    }\n    return source.type === EmptyValue.type\n      ? { type: AtomicValue.type, errors: FieldError.noErrors, ...(props as AtomicValue) }\n      : { ...source, ...props };\n  }\n}\n\nexport enum DataState {\n  /** Field is loading intial value and/or value set. */\n  Loading = 1,\n  /** Field is intialized and ready to user input. */\n  Ready,\n  /** Field is currently validating by {@link FormModel}. */\n  Verifying,\n}\n\nexport function mergeDataState(a: DataState, b: DataState) {\n  if (a === DataState.Loading || b === DataState.Loading) {\n    return DataState.Loading;\n  } else if (a === DataState.Verifying || b === DataState.Verifying) {\n    return DataState.Verifying;\n  } else {\n    return DataState.Ready;\n  }\n}\n\nexport interface FieldState {\n  readonly values: Immutable.List<FieldValue>;\n  readonly errors: Immutable.List<FieldError>;\n}\nexport namespace FieldState {\n  export const empty: FieldState = {\n    values: Immutable.List<FieldValue>(),\n    errors: Immutable.List<FieldError>(),\n  };\n\n  export function set(source: FieldState, props: Partial<FieldState>): FieldState {\n    if ('values' in props && props.values === undefined) {\n      throw new Error('FieldState.values cannot be undefined');\n    } else if ('errors' in props && props.errors === undefined) {\n      throw new Error('FieldState.errors cannot be undefined');\n    }\n    return { ...source, ...props };\n  }\n}\n\nexport interface CompositeValue {\n  readonly type: 'composite';\n  readonly subject: Rdf.Iri;\n  readonly definitions: Immutable.Map<string, FieldDefinition>;\n  /**\n   * Discriminator field value for form switch component to match composite value\n   * with corresponding switch case.\n   */\n  readonly discriminator?: Rdf.Node;\n  readonly fields: Immutable.Map<string, FieldState>;\n  /**\n   * Errors related to form (e.g. configuration errors),\n   * doesn't include errors from individual fields.\n   */\n  readonly errors: Immutable.List<FieldError>;\n}\nexport namespace CompositeValue {\n  export const type = 'composite';\n\n  export function set(source: CompositeValue, props: Partial<CompositeValue>): CompositeValue {\n    return { ...source, ...props };\n  }\n\n  export function isPlaceholder(subject: Rdf.Iri) {\n    return subject.value.length === 0;\n  }\n}\n\nexport type FieldValue = EmptyValue | AtomicValue | CompositeValue;\nexport namespace FieldValue {\n  export const empty: EmptyValue = { type: EmptyValue.type };\n\n  export function isEmpty(value: FieldValue): value is EmptyValue {\n    return value.type === EmptyValue.type;\n  }\n\n  export function isAtomic(value: FieldValue): value is AtomicValue {\n    return value.type === AtomicValue.type;\n  }\n\n  export function isComposite(value: FieldValue): value is CompositeValue {\n    return value.type === CompositeValue.type;\n  }\n\n  export function fromLabeled({ value, label, isForcedDefault }: LabeledValue, errors = FieldError.noErrors): AtomicValue {\n    if (!value) {\n      throw new Error('LabeledValue.value cannot be null or undefined');\n    }\n    return { type: AtomicValue.type, value, label, isForcedDefault, errors };\n  }\n\n  export function asRdfNode(value: FieldValue): Rdf.Node | undefined {\n    switch (value.type) {\n      case EmptyValue.type:\n        return undefined;\n      case AtomicValue.type:\n        return value.value;\n      case CompositeValue.type:\n        return value.subject.value.length > 0 ? value.subject : undefined;\n    }\n    unknownFieldType(value);\n  }\n\n  export function getErrors(value: FieldValue) {\n    switch (value.type) {\n      case EmptyValue.type:\n        return FieldError.noErrors;\n      case AtomicValue.type:\n        return value.errors;\n      case CompositeValue.type:\n        return value.errors;\n    }\n    unknownFieldType(value);\n  }\n\n  export function setErrors(\n    value: AtomicValue | CompositeValue,\n    errors: Immutable.List<FieldError>\n  ): AtomicValue | CompositeValue {\n    if (!errors) {\n      throw new Error('Cannot set field value errors to null or undefined');\n    }\n    switch (value.type) {\n      case AtomicValue.type:\n        return { ...value, errors };\n      case CompositeValue.type:\n        return { ...value, errors };\n    }\n    unknownFieldType(value);\n  }\n\n  export function replaceError(v: FieldValue, error: FieldError) {\n    const nonEmpty = FieldValue.isEmpty(v) ? FieldValue.fromLabeled({ value: Rdf.iri('') }) : v;\n    const errors = FieldError.noErrors.push(error);\n    return FieldValue.setErrors(nonEmpty, errors);\n  }\n\n  export function unknownFieldType(value: never) {\n    throw new Error(`Unknown field value type: ${(value as FieldValue).type}`);\n  }\n}\n"],"sourceRoot":""}