{"version":3,"sources":["webpack:///./src/main/web/components/semantic/search/web-components/SemanticSearchFormQuery.tsx"],"names":["PLACEHOLDER_SUBJECT","Rdf","iri","vocabularies","VocabPlatform","_NAMESPACE","render","SemanticSearchContext","Consumer","context","FormQueryInner","props","React","Component","FormQuery","queryTemplate","defs","multi","onKeyDown","e","keyCode","executeSearch","setFormRef","form","onFormChanged","model","setState","onFormLoaded","validationErrors","each","arguments","argument","argumentId","validateArgumentAndField","field","push","kind","ErrorKind","Configuration","message","argumentType","XsdDataTypeValidation","parseXsdDatatype","type","sameXsdDatatype","xsdDatatype","definitions","get","CompositeValue","set","errors","concat","onFormStateChanged","modelState","mapChildren","children","Children","map","element","isValidChild","name","cloneElement","disabled","canSubmit","state","onClick","length","validate","domainField","setSearchDomain","FieldValue","asRdfNode","fields","values","first","value","parametrized","parametrizeQueryFromForm","parsedQuery","SparqlUtil","parseQuery","queryString","queryType","Error","queryArguments","bindings","Object","keys","reduce","query","maxOccurs","size","optional","rdfNode","parameters","forEach","SparqlClient","prepareParsedQuery","setBindings","setBaseQuery","Just","normalizeFieldDefinition","def","id","minOccurs","componentWillReceiveProps","searchProfileStore","isJust","domain","isNothing","SemanticForm","ref","this","fromLabeled","onChanged","onLoaded","onUpdated","DataState","Ready","readyToSubmit","error"],"mappings":"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","file":"semantic-search-form-query-a05e6a096c7ddb32b230.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport * as React from 'react';\nimport { each } from 'lodash';\nimport * as SparqlJs from 'sparqljs';\nimport { Just } from 'data.maybe';\n\nimport { Rdf, XsdDataTypeValidation, vocabularies } from 'platform/api/rdf';\nimport { SparqlUtil, SparqlClient } from 'platform/api/sparql';\n\nimport { isValidChild } from 'platform/components/utils';\n\nimport {\n  SemanticForm,\n  CompositeValue,\n  FieldDefinitionProp,\n  FieldValue,\n  DataState,\n  readyToSubmit,\n  FieldDefinition,\n  normalizeFieldDefinition,\n  FieldError,\n  ErrorKind,\n} from 'platform/components/forms';\n\nimport { SemanticSearchContext, InitialQueryContext } from './SemanticSearchApi';\nimport { setSearchDomain } from '../commons/Utils';\n\nexport interface SemanticFormBasedQueryConfig {\n  /**\n   * Query template for form parametrization. Each query argument must have\n   * corresponding form field definition.\n   */\n  queryTemplate: QueryTemplate;\n  /**\n   * Definitions for form fields. Every field `id` must be map exactly to a\n   * single argument as defined in the arguments map of the `queryTemplate`\n   * as well as must be referenced by the `for=` attribute of the HTML form input elements.\n   *\n   * - `maxOccurs` will be overridden to 1 (if the `multi` property set to `false`);\n   * - `minOccurs` will be overridden to 0 or 1 depending on whether\n   * corresponding query argument is optional or not.\n   */\n  fields: FieldDefinitionProp[];\n\n  /**\n   * Specifies the search domain category IRI (full IRI enclosed in <>).\n   * Required, if component is used together with facets.\n   */\n  domain?: string;\n\n  domainField?: string;\n\n  /**\n   * Enables multi-value injection.\n   * If set to `true`, VALUES clause will be used to parametrize the base query for arguments with more than one value.\n   * If set to `false`, the first value will be used to parametrize the base query by replacement of the binding variable.\n   * To disable multi-value parameterization for particular variables, one can explicitly set `maxOccurs: 1` for corresponding fields.\n   *\n   * @default false\n   */\n  multi?: boolean;\n}\n\nexport interface QueryTemplate {\n  /**\n   * The SPARQL query string, which is supposed to be parameterized, i.e. the query must\n   * have query variables as listed in the arguments maps.\n   */\n  queryString: string;\n  /**\n   * A map of query arguments.\n   * The key of every map entry must be equal to the query variable in the SPARQL queryString.\n   */\n  arguments: { [id: string]: QueryTemplateArgument };\n}\n\nexport interface QueryTemplateArgument {\n  /**\n   * The RDF datatype of the expected value, i.e. xsd:anyURI, xsd:string, xsd:integer etc.\n   */\n  type: string;\n  /**\n   * Whether the argument is optional.\n   * @default false\n   */\n  optional?: boolean;\n}\n\n/**\n * Virtual subject for search form to make sure that it sends `selectPattern` queries to\n * simulate default values for fields. Currently the form assumes as an optimization\n * that every field is empty because form subject is a placeholder (subject IRI == <>).\n */\nconst PLACEHOLDER_SUBJECT = Rdf.iri(vocabularies.VocabPlatform._NAMESPACE + 'FormQuerySubject');\n\n/**\n * Form-based query formulation component, where the fields in the form\n * are used to provide values for a parameterized query (template).\n *\n * @example\n *  <semantic-search-form-query\n *    query-template='{\n *      \"queryString\": \"SELECT * WHERE { ?s a ?type }\",\n *      \"arguments\": {\n *        \"type\": {\"type\": \"xsd:anyURI\"},\n *        \"label\": {\"type\": \"xsd:string\"}\n *      }\n *    }'\n *    fields='[\n *      {\n *        \"id\": \"type\",\n *        \"label\": \"Type\",\n *        \"description\": \"The type of the instance\",\n *        \"xsdDatatype\": \"xsd:anyURI\",\n *        \"minOccurs\": \"1\",\n *        \"maxOccurs\": \"2\",\n *        \"valueSetPattern\": \"SELECT $value $label WHERE { VALUES ($value $label)\n *        { (<http://www.cidoc-crm.org/cidoc-crm/E22_Man-Made_Object> \\\"Man Made Object\\\")\n *        (<http://www.cidoc-crm.org/cidoc-crm/E73_Information_Object> \\\"Information Object\\\") } }\",\n *        \"selectPattern\": \"SELECT $value WHERE { $subject a $value }\"\n *      },\n *      {\"id\": \"label\", \"label\": \"Label\", \"xsdDatatype\": \"xsd:string\"}\n *    ]'>\n *      <semantic-form-select-input for=\"type\"></semantic-form-select-input>\n *      <semantic-form-text-input for=\"label\"></semantic-form-text-input>\n *      <button type='button' name='submit' className='btn btn-default'>Search</button>\n *  </semantic-search-form-query>\n */\nexport class FormQuery extends React.Component<SemanticFormBasedQueryConfig> {\n  render() {\n    return (\n      <SemanticSearchContext.Consumer>\n        {(context) => <FormQueryInner {...this.props} context={context} />}\n      </SemanticSearchContext.Consumer>\n    );\n  }\n}\n\ninterface InnerProps extends SemanticFormBasedQueryConfig {\n  context: InitialQueryContext;\n}\n\ninterface State {\n  readonly definitions?: ReadonlyArray<FieldDefinition>;\n  readonly model?: CompositeValue;\n  readonly modelState?: DataState;\n}\n\nclass FormQueryInner extends React.Component<InnerProps, State> {\n  private form: SemanticForm;\n\n  constructor(props: InnerProps) {\n    super(props);\n    this.state = {\n      definitions: adjustDefinitionsToTemplate({\n        queryTemplate: this.props.queryTemplate,\n        defs: this.props.fields,\n        multi: this.props.multi,\n      }),\n    };\n  }\n\n  componentWillReceiveProps(props: InnerProps) {\n    const { context } = props;\n    if (context.searchProfileStore.isJust && context.domain.isNothing) {\n      setSearchDomain(props.domain, context);\n    }\n  }\n\n  render() {\n    return (\n      <SemanticForm\n        ref={this.setFormRef}\n        fields={this.state.definitions}\n        model={this.state.model || FieldValue.fromLabeled({ value: PLACEHOLDER_SUBJECT })}\n        onChanged={this.onFormChanged}\n        onLoaded={this.onFormLoaded}\n        onUpdated={this.onFormStateChanged}\n      >\n        <div onKeyDown={this.onKeyDown}>{this.mapChildren(this.props.children)}</div>\n      </SemanticForm>\n    );\n  }\n\n  private onKeyDown = (e: React.KeyboardEvent<HTMLElement>) => {\n    if (e.keyCode === 13) {\n      this.executeSearch();\n    }\n  };\n\n  private setFormRef = (form: SemanticForm) => {\n    this.form = form;\n  };\n\n  private onFormChanged = (model: CompositeValue) => {\n    this.setState({ model });\n  };\n\n  private onFormLoaded = (model: CompositeValue) => {\n    const { queryTemplate } = this.props;\n\n    const validationErrors: FieldError[] = [];\n    each(queryTemplate.arguments, (argument, argumentId) => {\n      const field = model.definitions.get(argumentId);\n      validateArgumentAndField(argumentId, argument, field, validationErrors);\n    });\n\n    this.setState({\n      model: CompositeValue.set(model, {\n        errors: model.errors.concat(validationErrors),\n      }),\n    });\n  };\n\n  private onFormStateChanged = (modelState: DataState) => {\n    this.setState({ modelState });\n  };\n\n  private mapChildren = (children: React.ReactNode): React.ReactNode => {\n    return React.Children.map(children, (element) => {\n      if (!isValidChild(element)) {\n        return element;\n      }\n      const { type, props } = element;\n\n      if (type === 'button') {\n        if (props.name === 'submit') {\n          return React.cloneElement(element, {\n            disabled: !this.canSubmit(this.state.model),\n            onClick: this.executeSearch,\n          });\n        }\n      }\n\n      if (props.children && props.children.length > 0) {\n        return React.cloneElement(element, {}, this.mapChildren(props.children));\n      }\n\n      return element;\n    });\n  };\n\n  private executeSearch = () => {\n    const model = this.form.validate(this.state.model);\n    this.setState({ model });\n\n    if (!this.canSubmit(model)) {\n      return;\n    }\n\n    if (this.props.domainField) {\n      setSearchDomain(\n        '<' + FieldValue.asRdfNode(model.fields.get(this.props.domainField).values.first()).value + '>',\n        this.props.context\n      );\n    }\n\n    const parametrized = parametrizeQueryFromForm(this.props.queryTemplate, model);\n\n    return this.props.context.setBaseQuery(Just(parametrized));\n  };\n\n  private canSubmit(model: CompositeValue) {\n    return this.state.modelState === DataState.Ready && readyToSubmit(model, (error) => true);\n  }\n}\n\nfunction adjustDefinitionsToTemplate({\n  queryTemplate,\n  defs,\n  multi,\n}: {\n  queryTemplate: QueryTemplate;\n  defs: FieldDefinitionProp[];\n  multi: boolean;\n}) {\n  return defs.map(normalizeFieldDefinition).map<FieldDefinition>((def) => {\n    const argument = queryTemplate.arguments[def.id];\n    if (!argument) {\n      return def;\n    }\n    return { ...def, maxOccurs: multi ? def.maxOccurs : 1, minOccurs: argument.optional ? 0 : 1 };\n  });\n}\n\n/**\n * Performs configuration validation for query `argument` with ID `argumentId`\n * and corresponding field definition `field` and writes any detected errors\n * into `validationErrors`.\n *\n * Currently checks for:\n * - missing field definition for argument;\n * - invalid XSD datatype for query argument;\n * - mismatched datatypes of query argument and field definition.\n */\nfunction validateArgumentAndField(\n  argumentId: string,\n  argument: QueryTemplateArgument,\n  field: FieldDefinition,\n  validationErrors: FieldError[]\n) {\n  if (!field) {\n    validationErrors.push({\n      kind: ErrorKind.Configuration,\n      message: `Missing field definition or input for argument '${argumentId}'`,\n    });\n    return;\n  }\n\n  const argumentType = XsdDataTypeValidation.parseXsdDatatype(argument.type);\n  if (argumentType) {\n    if (!XsdDataTypeValidation.sameXsdDatatype(argumentType.iri, field.xsdDatatype)) {\n      validationErrors.push({\n        kind: ErrorKind.Configuration,\n        message: `Mismatched argument type ${argumentType.iri} and field type ${field.xsdDatatype}`,\n      });\n    }\n  } else {\n    validationErrors.push({\n      kind: ErrorKind.Configuration,\n      message: `Invalid XSD datatype '${argument.type}' for argument '${argumentId}'`,\n    });\n  }\n}\n\nfunction parametrizeQueryFromForm(queryTemplate: QueryTemplate, model: CompositeValue): SparqlJs.SelectQuery {\n  let parsedQuery = SparqlUtil.parseQuery(queryTemplate.queryString);\n  if (parsedQuery.type !== 'query' || parsedQuery.queryType !== 'SELECT') {\n    throw new Error('Query must be SELECT SPARQL query');\n  }\n  const queryArguments = queryTemplate.arguments;\n  const bindings: SparqlClient.Dictionary<Rdf.Node> = {};\n\n  parsedQuery = Object.keys(queryArguments).reduce((query, argumentId) => {\n    const argument = queryArguments[argumentId];\n\n    const { values } = model.fields.get(argumentId);\n    const { maxOccurs } = model.definitions.get(argumentId);\n\n    if (values.size === 0) {\n      if (argument.optional) {\n        return query;\n      }\n      throw new Error(`No field value for query argument ${argumentId}`);\n    }\n\n    // use variable replacement if an argument has cardinality equals 1 or it has only one value\n    if (maxOccurs === 1 || values.size === 1) {\n      const rdfNode = FieldValue.asRdfNode(values.first());\n      if (!rdfNode) {\n        if (argument.optional) {\n          return query;\n        }\n        throw new Error(`Empty field value for query argument ${argumentId}`);\n      }\n      bindings[argumentId] = rdfNode;\n\n      return query;\n    }\n\n    const parameters: SparqlClient.Dictionary<Rdf.Node>[] = [];\n    values.forEach((value) => {\n      const rdfNode = FieldValue.asRdfNode(value);\n      if (!rdfNode) {\n        if (argument.optional) {\n          return;\n        }\n        throw new Error(`Empty field value for query argument ${argumentId}`);\n      }\n      parameters.push({ [argumentId]: rdfNode });\n    });\n\n    return SparqlClient.prepareParsedQuery(parameters)(query);\n  }, parsedQuery);\n\n  return SparqlClient.setBindings(parsedQuery, bindings);\n}\n\nexport default FormQuery;\n"],"sourceRoot":""}