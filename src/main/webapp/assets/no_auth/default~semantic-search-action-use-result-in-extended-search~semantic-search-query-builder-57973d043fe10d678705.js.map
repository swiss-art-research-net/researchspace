{"version":3,"sources":["webpack:///./src/main/web/components/search/query-builder/SearchSummary.ts"],"names":["domainText","domain","nlp","noun","label","pluralize","className","styles","text","clausesText","clauses","_","dropRight","map","clauseText","reduce","reduceClauses","list","clause","disjuncts","term","orSeparator","flatten","value","concat","chunks","andSeparator","Model","matchConjunct","Relation","relationConjunctText","Text","textConjunctText","conjunct","disjunctsText","relationText","relation","disjunct","disjunctText","kind","EntityDisjunctKinds","Search","SearchSummary","summaryToString","disjunctToString","separator","render","D","div","span","start","this","props","search","VOCABULARY","SUMMARY_PREFIX","EMPTY","htmlSummary","textAst","searchSummary","statement","acc","x","classNames","word","searchText","conjuncts","UNKNOWN_CLAUSE","RELATION_PLACEHOLDER","PLACEHOLDER","Component"],"mappings":"6IAsBA,OACA,QACA,QACA,UACA,OAEA,UACA,UACA,UAqBA,qF,OA+CU,EAAAA,WAAa,SAACC,GACpB,IAAMD,EAAaE,EAAIC,KAAKF,EAAOG,OAAOC,YAC1C,MAAO,CACLC,UAAWC,EAAON,OAClBO,KAAMR,IAIF,EAAAS,YAAc,SAACC,GACrB,OAAOC,EAAEC,UAAUD,EAAED,GAASG,IAAI,EAAKC,YAAYC,OAAO,EAAKC,cAAe,IAAK,IAG7E,EAAAA,cAAgB,SAACC,EAAwBC,GAC/C,IAAMC,EAAYR,EAAEO,EAAOC,WACxBN,KAAI,SAACO,GAAS,OAACA,EAAM,EAAKC,kBAC1BC,UACAV,UAAU,GACVW,QACH,OAAON,EAAKO,OAAON,EAAOO,OAAQN,EAAW,CAAC,EAAKO,kBAG7C,EAAAZ,WAAa,SAACI,GACpB,OAAOS,EAAMC,cAAc,CACzBC,SAAU,EAAKC,qBACfC,KAAM,EAAKC,kBAFNL,CAGJT,IAGG,EAAAc,iBAAmB,SAACC,GAA2C,OACrER,OAAQ,GACRN,UAAW,EAAKe,cAAcD,EAASd,aAGjC,EAAAW,qBAAuB,SAACG,GAC9B,IAAME,EAAeF,EAASG,SAAShC,MACvC,MAAO,CACLqB,OAAQ,CACN,CACEnB,UAAWC,EAAO6B,SAClB5B,KAAM2B,IAGVhB,UAAW,EAAKe,cAAcD,EAASd,aAInC,EAAAe,cAAgB,SAACG,GAAmD,OAAA1B,EAAEE,IAAIwB,EAAU,EAAKC,eAEzF,EAAAA,aAAe,SAACD,GACtB,OAAIA,EAASE,OAASZ,EAAMa,oBAAoBC,OACvC,CACLnC,UAAWC,EAAO8B,EAASE,MAC3B/B,KAAM6B,EAASd,MAAMtB,OAAOG,MAAQ,UAAYsC,cAAcC,gBAAgBN,EAASd,QAGlF,CACLjB,UAAWC,EAAO8B,EAASE,MAC3B/B,KAAM,EAAAoC,iBAAiBP,KAKrB,EAAAhB,YAAc,WAAiB,OACrCf,UAAWC,EAAOsC,UAClBrC,KAAM,OAGA,EAAAkB,aAAe,WAAiB,OACtCpB,UAAWC,EAAOsC,UAClBrC,KAAM,Q,EAEV,OAtHmC,6BASjC,wBAAAsC,OAAA,WACE,OAAOC,EAAEC,IACP,CAAE1C,UAAW,kBACbyC,EAAEE,KACA,CAAE3C,UAAWC,EAAO2C,OACpBC,KAAKC,MAAMC,OAASX,cAAcY,WAAWC,eAAiBb,cAAcY,WAAWE,OAEzFL,KAAKC,MAAMC,OAASF,KAAKM,YAAYN,KAAKC,MAAMC,QAAU,OAQhD,cAAAV,gBAAd,SAA8BU,GAC5B,IAAMK,EAAU,IAAIhB,cAAc,MAAMiB,cAAcN,GACtD,OAAO1C,EAAE+C,GACN7C,KAAI,SAAC+C,GAAc,OAACA,EAAUpD,KAAM,QACpCc,UACAV,UAAU,GACVG,QAAO,SAAC8C,EAAKC,GAAM,OAAAD,EAAMC,IAAG,KAGzB,wBAAAL,YAAR,SAAoBJ,GAClB,OAAOF,KAAKQ,cAAcN,GAAQxC,KAAI,SAAC+C,GACrC,OAAAb,EAAEE,KAAK,CAAE3C,UAAWyD,EAAWxD,EAAOyD,KAAMJ,EAAUtD,YAAcsD,EAAUpD,UAI1E,wBAAAmD,cAAR,SAAsBN,GACpB,OAAOF,KAAKc,WAAWZ,IAGjB,wBAAAY,WAAR,SAAmBZ,GACjB,MAAO,CAACF,KAAKnD,WAAWqD,EAAOpD,SAASuB,OAAO2B,KAAK1C,YAAY4C,EAAOa,aA3C1D,cAAAZ,WAAa,CAC1BE,MAAO,4BACPD,eAAgB,QAChBY,eAAgB,4BAChBC,qBAAsB,qBACtBC,YAAa,OAgHjB,cAtHA,CAAmC,EAAAC,WAAtB,EAAA5B,gBAuHb,UAAeA","file":"default~semantic-search-action-use-result-in-extended-search~semantic-search-query-builder-57973d043fe10d678705.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2015-2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @author Artem Kozlov <ak@metaphacts.com>\n */\n\nimport { Component, ReactElement } from 'react';\nimport * as D from 'react-dom-factories';\nimport * as _ from 'lodash';\nimport * as nlp from 'nlp_compromise';\nimport * as classNames from 'classnames';\n\nimport * as Model from 'platform/components/semantic/search/data/search/Model';\nimport { disjunctToString } from 'platform/components/semantic/search/data/search/ModelUtils';\nimport * as styles from './SearchSummary.scss';\n\ninterface Props {\n  search: Model.Search;\n}\n\ninterface ChunkText {\n  className: string;\n  text: string;\n}\n\ninterface DisjunctText extends ChunkText {}\n\ninterface ConjunctText {\n  chunks: Array<ChunkText>;\n  disjuncts: Array<DisjunctText>;\n}\n\n/**\n * Human readable, search query representation component.\n */\nexport class SearchSummary extends Component<Props, {}> {\n  private static VOCABULARY = {\n    EMPTY: 'What do you want to find?',\n    SUMMARY_PREFIX: 'Find:',\n    UNKNOWN_CLAUSE: 'unknow search clause type',\n    RELATION_PLACEHOLDER: '... related to ...',\n    PLACEHOLDER: '...',\n  };\n\n  render() {\n    return D.div(\n      { className: 'search-summary' },\n      D.span(\n        { className: styles.start },\n        this.props.search ? SearchSummary.VOCABULARY.SUMMARY_PREFIX : SearchSummary.VOCABULARY.EMPTY\n      ),\n      this.props.search ? this.htmlSummary(this.props.search) : null\n    );\n  }\n\n  /**\n   * Converts search AST into human readable query representation.\n   * E.g. 'Find Actors has met The Portland Vase Disc' etc.\n   */\n  public static summaryToString(search): string {\n    const textAst = new SearchSummary(null).searchSummary(search);\n    return _(textAst)\n      .map((statement) => [statement.text, ' '])\n      .flatten()\n      .dropRight(1)\n      .reduce((acc, x) => acc + x, '');\n  }\n\n  private htmlSummary(search: Model.Search): Array<ReactElement<any>> {\n    return this.searchSummary(search).map((statement) =>\n      D.span({ className: classNames(styles.word, statement.className) }, statement.text)\n    );\n  }\n\n  private searchSummary(search: Model.Search): Array<ChunkText> {\n    return this.searchText(search);\n  }\n\n  private searchText(search: Model.Search): Array<ChunkText> {\n    return [this.domainText(search.domain)].concat(this.clausesText(search.conjuncts));\n  }\n\n  private domainText = (domain: Model.Category): ChunkText => {\n    const domainText = nlp.noun(domain.label).pluralize();\n    return {\n      className: styles.domain,\n      text: domainText,\n    };\n  };\n\n  private clausesText = (clauses: Model.Conjuncts): Array<ChunkText> => {\n    return _.dropRight(_(clauses).map(this.clauseText).reduce(this.reduceClauses, []), 1);\n  };\n\n  private reduceClauses = (list: Array<ChunkText>, clause: ConjunctText): Array<ChunkText> => {\n    const disjuncts = _(clause.disjuncts)\n      .map((term) => [term, this.orSeparator()])\n      .flatten<ChunkText>()\n      .dropRight(1)\n      .value();\n    return list.concat(clause.chunks, disjuncts, [this.andSeparator()]);\n  };\n\n  private clauseText = (clause: Model.Conjunct): ConjunctText => {\n    return Model.matchConjunct({\n      Relation: this.relationConjunctText,\n      Text: this.textConjunctText,\n    })(clause);\n  };\n\n  private textConjunctText = (conjunct: Model.Conjunct): ConjunctText => ({\n    chunks: [],\n    disjuncts: this.disjunctsText(conjunct.disjuncts),\n  });\n\n  private relationConjunctText = (conjunct: Model.RelationConjunct): ConjunctText => {\n    const relationText = conjunct.relation.label;\n    return {\n      chunks: [\n        {\n          className: styles.relation,\n          text: relationText,\n        },\n      ],\n      disjuncts: this.disjunctsText(conjunct.disjuncts),\n    };\n  };\n\n  private disjunctsText = (disjunct: Model.Disjuncts): Array<DisjunctText> => _.map(disjunct, this.disjunctText);\n\n  private disjunctText = (disjunct: Model.Disjunct): DisjunctText => {\n    if (disjunct.kind === Model.EntityDisjunctKinds.Search) {\n      return {\n        className: styles[disjunct.kind],\n        text: disjunct.value.domain.label + ' where ' + SearchSummary.summaryToString(disjunct.value),\n      };\n    } else {\n      return {\n        className: styles[disjunct.kind],\n        text: disjunctToString(disjunct),\n      };\n    }\n  };\n\n  private orSeparator = (): ChunkText => ({\n    className: styles.separator,\n    text: 'or',\n  });\n\n  private andSeparator = (): ChunkText => ({\n    className: styles.separator,\n    text: 'and',\n  });\n}\nexport default SearchSummary;\n"],"sourceRoot":""}