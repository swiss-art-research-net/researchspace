{"version":3,"sources":["webpack:///./src/main/web/components/forms/inputs/CompositeInput.ts","webpack:///./src/main/web/components/forms/FormModel.ts","webpack:///./src/main/web/components/forms/FieldMapping.ts","webpack:///./src/main/web/components/forms/inputs/CardinalitySupport.ts"],"names":["READY_INPUT_STATE","dataState","DataState","Ready","validation","Cancellation","cancelled","props","context","cancellation","compositeOperations","derive","shouldReload","compositeState","inputRefs","Map","inputStates","onFieldValuesChanged","def","reducer","updateValue","previous","setFieldValue","dataStateForField","fieldId","get","onMountInput","inputId","inputIndex","inputRef","refs","set","getHandler","handler","CompositeHandler","Error","componentDidMount","this","tryLoadComposite","componentWillReceiveProps","value","componentWillUnmount","cancelAll","FieldValue","isComposite","fields","size","definitions","loadComposite","deriveAndCancel","filter","item","inputs","has","toMap","rawComposite","createRawComposite","configurationErrors","Loading","clear","map","loadDefaults","flatMap","v","Kefir","later","observe","change","loaded","mergeInitialValues","base","patch","CompositeValue","state","oldValue","newValue","reduceFieldValue","fieldState","FieldState","empty","updatedState","values","errors","id","isInputLoading","startValidatingField","ref","modelChange","tryBeginValidation","Verifying","current","validated","result","toArray","mergeDataState","render","composite","createElement","Spinner","children","renderFields","handlers","className","makeHandler","inputKind","InputKind","CompositeInput","SingleValueInput","baseInputProps","newSubjectTemplate","normalizeDefinitons","rawFields","Immutable","withMutations","raw","parsed","normalizeFieldDefinition","mappings","mapping","MultipleValuesInput","getHandlerOrDefault","inputType","definition","for","element","validate","length","finalize","owner","finalizedComposite","finalizeSubject","zipImmutableMap","mapAsArray","kefirValue","key","zip","newMap","toProperty","constant","finalizing","FieldError","noErrors","sourceValue","ownerSubject","subject","undefined","generateSubjectByTemplate","type","getSubject","fieldInitialState","isAtomic","node","asRdfNode","isIri","Rdf","iri","assertStatic","template","replacer","makeDefaultSubjectReplacer","isPlaceholder","replace","match","placeholder","p","startsWith","trim","URI","scheme","SparqlUtil","RegisteredPrefixes","Default","combinedPath","joinPaths","toString","pathname","uuid","v4","first","valueContent","getLocalName","encodeIri","setSizeAndFill","list","newSize","fillValue","clone","i","lookForDefaultValues","defaultValue","defaultValues","forceDefaults","fieldValues","parseDefaultValue","isForcedDefault","atomic","createDefaultValue","xsdDatatype","fromLabeled","literal","XsdDataTypeValidation","sameXsdDatatype","vocabularies","xsd","anyURI","success","message","AtomicValue","push","kind","ErrorKind","restoreLabel","formatError","error","status","wasIriGeneratedByTemplate","generatedIri","escapeTable","UUID","FIELD_VALUE_LOCAL_NAME","newGeneratedIri","comp","escaped","regexpEscaped","escapeRegExp","RegExp","test","readyToSubmit","isConsideredError","freeOfErrors","every","getErrors","initialValues","loadInitialOrDefaultValues","isPlaceholderSubject","shouldLoadInitials","selectPattern","shouldLoadDefaults","fetchInitialValues","queryValues","Math","max","minOccurs","isEmpty","requiredCount","FieldMapping","List","flatMapErrors","noChanges","results","model","states","mergeFetchedIntoModel","field","previousComposite","newComposite","constraints","oldValues","newValues","streams","index","currentComposite","is","update","valueCount","min","maxOccurs","setSize","DISALLOWED_CHARACTERS","COLLAPSE_UNDERSCORES","fileName","transformed","mapChildToComponent","child","isValidChild","elementIsSingleValueInput","singleValueInputType","CardinalitySupport","React","elementHasInputType","MultiValuesInput","StaticInput","staticType","collectDefinitionErrors","store","member","ValidationError","Configuration","validateQueryPattern","valueSetPattern","deletePattern","validateDeletePattern","pattern","query","parseQuery","updates","SparqlTypeGuards","isInsertDeleteOperation","updateType","insert","insertPattern","validateInsertPattern","delete","autosuggestionPattern","validatePattern","queryType","err","isInput","componentHasInputType","isStatic","isOtherElement","assertNever","console","validateFieldConfiguration","asMutable","collectFieldConfiguration","collectedInputs","collectedErrors","Children","forEach","componentDisplayName","asImmutable","inputChildren","inputHandlers","getDataState","onValuesChanged","onInputMounted","inputIndices","mapChild","baseProvidedProps","updateValues","inputOverride","input","InputDecorator","cloneElement","override","mappedChildren","mapChildren","universalChildren","COMPONENT_NAME","valueKeys","addNewValue","removeValue","valueIndex","splice","remove","CardinalitySupportHandler","shouldComponentUpdate","nextProps","nextState","lastRenderedDataState","renderHeader","D","div","canEdit","canAddValue","canRemoveValue","fieldLabel","label","getPreferredLabel","toLowerCase","renderChildren","a","classnames","onClick","ensureValueKeys","childIsInputGroup","isInputGroup","childCount","count","FormSwitch","canCollapseGroup","renderChildInputs","inputProps","inputHandler","onInputMount","nextIndex","Button","span","uniqueId","validateThoughChildInputs","setErrors","findInputs","foundInputs","collectInputs","validateByChildInput","otherErrors","e","Input","toList","cardinalityErrors","validateCardinality","concat","preparedValues","checkCardinalityAndDuplicates","intermediates","tasks","properties"],"mappings":"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","file":"semantic-form-composite-input-44f9d43c6d26c02e1212.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { createElement, Props, ReactNode } from 'react';\nimport * as Immutable from 'immutable';\nimport * as Kefir from 'kefir';\n\nimport { Cancellation } from 'platform/api/async';\nimport { Rdf } from 'platform/api/rdf';\n\nimport { Spinner } from 'platform/components/ui/spinner';\n\nimport { FieldDefinitionProp, FieldDefinition, normalizeFieldDefinition } from '../FieldDefinition';\nimport {\n  FieldValue,\n  EmptyValue,\n  CompositeValue,\n  FieldError,\n  FieldState,\n  DataState,\n  mergeDataState,\n} from '../FieldValues';\nimport { InputMapping, validateFieldConfiguration, renderFields } from '../FieldMapping';\nimport { fieldInitialState, generateSubjectByTemplate, loadDefaults, tryBeginValidation } from '../FormModel';\n\nimport {\n  SingleValueInput,\n  SingleValueInputProps,\n  SingleValueHandler,\n  SingleValueHandlerProps,\n} from './SingleValueInput';\nimport {\n  MultipleValuesInput,\n  MultipleValuesProps,\n  MultipleValuesHandler,\n  ValuesWithErrors,\n} from './MultipleValuesInput';\n\nimport { InputKind } from './InputCommpons';\n\nexport interface CompositeInputProps extends SingleValueInputProps {\n  fields: ReadonlyArray<FieldDefinitionProp>;\n  newSubjectTemplate?: string;\n  children?: ReactNode;\n}\n\ntype ComponentProps = CompositeInputProps & Props<CompositeInput>;\n\ninterface InputState {\n  readonly dataState: DataState.Ready | DataState.Verifying;\n  readonly validation: Cancellation;\n}\nconst READY_INPUT_STATE: InputState = {\n  dataState: DataState.Ready,\n  validation: Cancellation.cancelled,\n};\n\nconst VALIDATION_DEBOUNCE_DELAY = 500;\n\ntype ChildInput = MultipleValuesInput<MultipleValuesProps, unknown>;\n\nexport class CompositeInput extends SingleValueInput<ComponentProps, {}> {\n  public static readonly inputKind = InputKind.CompositeInput;\n\n  private readonly cancellation = new Cancellation();\n  private compositeOperations = this.cancellation.derive();\n\n  private shouldReload = true;\n  private compositeState: DataState.Loading | DataState.Ready = DataState.Ready;\n  private inputRefs = new Map<string, Array<ChildInput | null>>();\n  private inputStates = new Map<string, InputState>();\n\n  constructor(props: ComponentProps, context: any) {\n    super(props, context);\n  }\n\n  private getHandler(): CompositeHandler {\n    const { handler } = this.props;\n    if (!(handler instanceof CompositeHandler)) {\n      throw new Error('Invalid value handler for CompositeInput');\n    }\n    return handler;\n  }\n\n  componentDidMount() {\n    this.tryLoadComposite(this.props);\n  }\n\n  componentWillReceiveProps(props: ComponentProps) {\n    if (props.value !== this.props.value) {\n      // track reload requests separately to be able to suspend\n      // composite load until `props.dataState` becomes `DataState.Ready`\n      this.shouldReload = true;\n    }\n    this.tryLoadComposite(props);\n  }\n\n  componentWillUnmount() {\n    this.cancellation.cancelAll();\n  }\n\n  private tryLoadComposite(props: ComponentProps) {\n    if (!(this.shouldReload && props.dataState === DataState.Ready)) {\n      return;\n    }\n    const shouldLoad =\n      !FieldValue.isComposite(props.value) ||\n      // composite value requires to load definitions and defaults\n      // (e.g. when value is restored from local storage)\n      (props.value.fields.size > 0 && props.value.definitions.size === 0);\n    if (shouldLoad) {\n      this.shouldReload = false;\n      this.loadComposite(props);\n    }\n  }\n\n  private loadComposite(props: ComponentProps) {\n    this.compositeOperations = this.cancellation.deriveAndCancel(this.compositeOperations);\n    const handler = this.getHandler();\n\n    // filter model from unused field definitions\n    // (the ones without corresponding input)\n    const filterUnusedFields = <T>(items: Immutable.Iterable<string, T>) =>\n      items.filter((item, fieldId) => handler.inputs.has(fieldId)).toMap();\n\n    const definitions = filterUnusedFields(handler.definitions);\n    const rawComposite = createRawComposite(props.value, definitions, handler.configurationErrors);\n\n    this.compositeState = DataState.Loading;\n    this.inputStates.clear();\n\n    props.updateValue(() => rawComposite);\n    this.compositeOperations\n      .map(\n        // add zero delay to force asynchronous observer call\n        loadDefaults(rawComposite, handler.inputs).flatMap((v) => Kefir.later(0, v))\n      )\n      .observe({\n        value: (change) => {\n          let loaded = change(rawComposite);\n          if (FieldValue.isComposite(props.value)) {\n            loaded = mergeInitialValues(loaded, props.value);\n          }\n          this.compositeState = DataState.Ready;\n          this.props.updateValue(() => loaded);\n        },\n      });\n  }\n\n  private onFieldValuesChanged = (def: FieldDefinition, reducer: (previous: ValuesWithErrors) => ValuesWithErrors) => {\n    this.props.updateValue((previous) => this.setFieldValue(def, previous, reducer));\n  };\n\n  private setFieldValue(\n    def: FieldDefinition,\n    oldValue: FieldValue,\n    reducer: (previous: ValuesWithErrors) => ValuesWithErrors\n  ): FieldValue {\n    if (!FieldValue.isComposite(oldValue)) {\n      return;\n    }\n\n    const newValue = reduceFieldValue(def.id, oldValue, reducer);\n    if (this.isInputLoading(def.id)) {\n      this.inputStates.set(def.id, READY_INPUT_STATE);\n    } else {\n      this.startValidatingField(def, oldValue, newValue);\n    }\n\n    return newValue;\n  }\n\n  private isInputLoading(fieldId: string): boolean {\n    const refs = this.inputRefs.get(fieldId);\n    if (!refs) {\n      return true;\n    }\n    for (const ref of refs) {\n      if (!ref || ref.dataState() === DataState.Loading) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private startValidatingField(def: FieldDefinition, oldValue: CompositeValue, newValue: CompositeValue) {\n    let { dataState, validation } = this.inputStates.get(def.id) || READY_INPUT_STATE;\n    // immediately apply user edits in an input component\n    // then update model with validation info when it'll be available\n    const modelChange = tryBeginValidation(def, oldValue, newValue);\n\n    dataState = modelChange ? DataState.Verifying : DataState.Ready;\n    validation = this.compositeOperations.deriveAndCancel(validation);\n\n    this.inputStates.set(def.id, { dataState, validation });\n\n    if (modelChange) {\n      validation.map(Kefir.later(VALIDATION_DEBOUNCE_DELAY, {}).flatMap(() => modelChange)).observe({\n        value: (change) => {\n          const current = this.props.value;\n          if (!FieldValue.isComposite(current)) {\n            return;\n          }\n          const validated = change(current);\n          this.inputStates.set(def.id, READY_INPUT_STATE);\n          this.props.updateValue(() => validated);\n        },\n      });\n    }\n  }\n\n  dataState(): DataState {\n    if (!FieldValue.isComposite(this.props.value)) {\n      return DataState.Loading;\n    } else if (this.compositeState !== DataState.Ready) {\n      return this.compositeState;\n    }\n\n    let result = DataState.Ready;\n\n    const fieldIds = this.props.value.definitions.map((def) => def.id).toArray();\n    for (const fieldId of fieldIds) {\n      const refs = this.inputRefs.get(fieldId);\n      if (!refs) {\n        result = mergeDataState(result, DataState.Loading);\n        continue;\n      }\n      for (const ref of refs) {\n        if (ref) {\n          result = mergeDataState(result, ref.dataState());\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private dataStateForField = (fieldId: string): DataState => {\n    if (this.compositeState !== DataState.Ready) {\n      return this.compositeState;\n    }\n    const state = this.inputStates.get(fieldId) || READY_INPUT_STATE;\n    return state.dataState;\n  };\n\n  render() {\n    const composite = this.props.value;\n    if (!FieldValue.isComposite(composite)) {\n      return createElement(Spinner);\n    }\n\n    const children = renderFields(\n      this.props.children,\n      composite,\n      this.getHandler().handlers,\n      this.dataStateForField,\n      this.onFieldValuesChanged,\n      this.onMountInput\n    );\n\n    return createElement('div', { className: 'composite-input' }, children);\n  }\n\n  private onMountInput = (\n    inputId: string,\n    inputIndex: number,\n    inputRef: MultipleValuesInput<MultipleValuesProps, any> | null\n  ) => {\n    let refs = this.inputRefs.get(inputId);\n    if (!refs) {\n      refs = [];\n      this.inputRefs.set(inputId, refs);\n    }\n    refs[inputIndex] = inputRef;\n  };\n\n  static makeHandler(props: SingleValueHandlerProps<CompositeInputProps>): CompositeHandler {\n    return new CompositeHandler(props);\n  }\n}\n\nclass CompositeHandler implements SingleValueHandler {\n  readonly newSubjectTemplate: string | undefined;\n  readonly definitions: Immutable.Map<string, FieldDefinition>;\n  readonly inputs: Immutable.Map<string, ReadonlyArray<InputMapping>>;\n  readonly configurationErrors: Immutable.List<FieldError>;\n  readonly handlers: Immutable.Map<string, ReadonlyArray<MultipleValuesHandler>>;\n\n  constructor({ baseInputProps }: SingleValueHandlerProps<CompositeInputProps>) {\n    this.newSubjectTemplate = baseInputProps.newSubjectTemplate;\n    this.definitions = normalizeDefinitons(baseInputProps.fields);\n    const { inputs, errors } = validateFieldConfiguration(this.definitions, baseInputProps.children);\n    this.inputs = inputs;\n    this.configurationErrors = errors;\n    this.handlers = inputs\n      .map((mappings) =>\n        mappings.map((mapping) =>\n          MultipleValuesInput.getHandlerOrDefault(mapping.inputType as any, {\n            definition: this.definitions.get(mapping.for),\n            baseInputProps: mapping.element.props,\n          })\n        )\n      )\n      .toMap();\n  }\n\n  validate(value: FieldValue) {\n    if (!FieldValue.isComposite(value)) {\n      return value;\n    }\n    return CompositeValue.set(value, {\n      fields: value.fields\n        .map((state, fieldId) => {\n          const handlers = this.handlers.get(fieldId);\n          if (!handlers || handlers.length === 0) {\n            return state;\n          }\n          let validated = state;\n          for (const handler of handlers) {\n            validated = handler.validate(validated);\n          }\n          return FieldState.set(state, validated);\n        })\n        .toMap(),\n    });\n  }\n\n  finalize(value: FieldValue, owner: EmptyValue | CompositeValue): Kefir.Property<CompositeValue> {\n    const finalizedComposite = this.finalizeSubject(value, owner);\n\n    const fieldProps = finalizedComposite.fields\n      .map((state, fieldId) => {\n        const handlers = this.handlers.get(fieldId);\n        if (!handlers || handlers.length === 0) {\n          return Kefir.constant(state);\n        }\n        let finalizing = Kefir.constant(state.values);\n        for (const handler of handlers) {\n          finalizing = finalizing.flatMap((v) => handler.finalize(v, finalizedComposite)).toProperty();\n        }\n        return finalizing.map((values) => {\n          return FieldState.set(state, { values, errors: FieldError.noErrors });\n        });\n      })\n      .toMap();\n\n    return zipImmutableMap(fieldProps).map((fields) => {\n      return CompositeValue.set(finalizedComposite, { fields });\n    });\n  }\n\n  finalizeSubject(value: FieldValue, owner: EmptyValue | CompositeValue): CompositeValue {\n    const sourceValue: CompositeValue = FieldValue.isComposite(value) ? value : createRawComposite(value);\n\n    const ownerSubject = FieldValue.isComposite(owner) ? owner.subject : undefined;\n    return CompositeValue.set(sourceValue, {\n      subject: generateSubjectByTemplate(this.newSubjectTemplate, ownerSubject, sourceValue),\n    });\n  }\n}\n\nfunction normalizeDefinitons(rawFields: ReadonlyArray<FieldDefinitionProp>) {\n  return Immutable.Map<string, FieldDefinition>().withMutations((result) => {\n    for (const raw of rawFields) {\n      if (result.has(raw.id)) {\n        continue;\n      }\n      const parsed = normalizeFieldDefinition(raw);\n      result.set(parsed.id, parsed);\n    }\n  });\n}\n\nfunction zipImmutableMap<K, V>(map: Immutable.Map<K, Kefir.Property<V>>): Kefir.Property<Immutable.Map<K, V>> {\n  const mapAsArray = map\n    .map((kefirValue, key) => {\n      return kefirValue.map((value) => ({ key, value }));\n    })\n    .toArray();\n\n  if (mapAsArray.length > 0) {\n    return Kefir.zip(mapAsArray)\n      .map((values) =>\n        Immutable.Map<K, V>().withMutations((newMap) => {\n          for (const { key, value } of values) {\n            newMap.set(key, value);\n          }\n        })\n      )\n      .toProperty();\n  } else {\n    return Kefir.constant(Immutable.Map());\n  }\n}\n\nfunction createRawComposite(\n  sourceValue: FieldValue,\n  definitions = Immutable.Map<string, FieldDefinition>(),\n  errors = FieldError.noErrors\n): CompositeValue {\n  return {\n    type: CompositeValue.type,\n    subject: getSubject(sourceValue),\n    definitions,\n    fields: definitions.map(fieldInitialState).toMap(),\n    errors,\n  };\n}\n\nfunction getSubject(value: FieldValue): Rdf.Iri {\n  if (FieldValue.isComposite(value)) {\n    return value.subject;\n  } else if (FieldValue.isAtomic(value)) {\n    const node = FieldValue.asRdfNode(value);\n    if (node.isIri()) {\n      return node;\n    }\n  }\n  return Rdf.iri('');\n}\n\nfunction mergeInitialValues(base: CompositeValue, patch: CompositeValue): CompositeValue {\n  if (patch.fields.size === 0) {\n    return base;\n  }\n  return CompositeValue.set(base, {\n    fields: base.fields\n      .map((state, fieldId) => {\n        return patch.fields.get(fieldId, state);\n      })\n      .toMap(),\n  });\n}\n\nfunction reduceFieldValue(\n  fieldId: string,\n  previous: CompositeValue,\n  reducer: (previous: ValuesWithErrors) => ValuesWithErrors\n) {\n  const fieldState = previous.fields.get(fieldId, FieldState.empty);\n  const updatedState = FieldState.set(\n    fieldState,\n    reducer({\n      values: fieldState.values,\n      errors: fieldState.errors,\n    })\n  );\n  const fields = previous.fields.set(fieldId, updatedState);\n  return CompositeValue.set(previous, { fields });\n}\n\nSingleValueInput.assertStatic(CompositeInput);\n\nexport default CompositeInput;\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as uuid from 'uuid';\nimport * as Immutable from 'immutable';\nimport * as Kefir from 'kefir';\nimport * as URI from 'urijs';\nimport { escapeRegExp, isEmpty } from 'lodash';\n\nimport { Rdf, XsdDataTypeValidation, vocabularies } from 'platform/api/rdf';\nimport { SparqlUtil } from 'platform/api/sparql';\n\nimport { FieldDefinition } from './FieldDefinition';\nimport { FieldValue, FieldError, ErrorKind, CompositeValue, FieldState, AtomicValue } from './FieldValues';\nimport { FieldMapping, InputMapping } from './FieldMapping';\nimport { validate, queryValues, restoreLabel } from './QueryValues';\n\nexport interface CompositeChange {\n  (value: CompositeValue): CompositeValue;\n}\n\nconst DEFALUT_SUBJECT_TEMPLATE = '{{UUID}}';\n\ntype SubjectReplacer = (placeholder: Placeholder, composite?: CompositeValue) => string;\n\nconst FIELD_VALUE_LOCAL_NAME = 'FIELD_VALUE_LOCAL_NAME';\ntype Placeholder =\n  | { type: 'UUID' }\n  | { type: 'FieldValue'; id: string }\n  | { type: typeof FIELD_VALUE_LOCAL_NAME; id: string };\n\nexport function generateSubjectByTemplate(\n  template: string | undefined,\n  ownerSubject: Rdf.Iri | undefined,\n  composite: CompositeValue | undefined,\n  replacer: SubjectReplacer = makeDefaultSubjectReplacer()\n): Rdf.Iri {\n  if (composite && !CompositeValue.isPlaceholder(composite.subject)) {\n    return composite.subject;\n  }\n\n  const iriTemplate = template || DEFALUT_SUBJECT_TEMPLATE;\n  const subject = iriTemplate.replace(/{{([^{}]+)}}/g, (match, placeholder: string) => {\n    let p: Placeholder;\n    if (placeholder === 'UUID') {\n      p = { type: 'UUID' };\n    } else if (placeholder.startsWith(FIELD_VALUE_LOCAL_NAME)) {\n      p = {\n        type: FIELD_VALUE_LOCAL_NAME,\n        id: placeholder.replace(FIELD_VALUE_LOCAL_NAME, '').trim(),\n      };\n    } else {\n      p = { type: 'FieldValue', id: placeholder };\n    }\n    return replacer(p, composite);\n  });\n\n  const isAbsoluteUri = URI(subject).scheme();\n  if (isAbsoluteUri) {\n    return Rdf.iri(subject);\n  }\n\n  const base = ownerSubject ? ownerSubject.value : SparqlUtil.RegisteredPrefixes.Default;\n  const combinedPath = URI.joinPaths(base, subject).toString();\n  return Rdf.iri(URI(base).pathname(combinedPath).toString());\n}\n\nexport function wasIriGeneratedByTemplate(\n  generatedIri: string,\n  template: string,\n  ownerSubject: Rdf.Iri | undefined,\n  composite: CompositeValue | undefined\n): boolean {\n  const replacer = makeDefaultSubjectReplacer();\n  const escapeTable: { [K in Placeholder['type']]: string | undefined } = {\n    UUID: uuid.v4(),\n    FieldValue: undefined,\n    FIELD_VALUE_LOCAL_NAME: undefined,\n  };\n  const newGeneratedIri = generateSubjectByTemplate(template, ownerSubject, composite, (p, comp) => {\n    const escaped = escapeTable[p.type];\n    return escaped ? escaped : replacer(p, comp);\n  });\n  const regexpEscaped = escapeRegExp(newGeneratedIri.value).replace(\n    escapeRegExp(escapeTable.UUID),\n    '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}'\n  );\n  return new RegExp(regexpEscaped).test(generatedIri);\n}\n\nexport function makeDefaultSubjectReplacer(): SubjectReplacer {\n  return (placeholder, composite) => {\n    if (placeholder.type === 'UUID') {\n      return uuid.v4();\n    } else if (\n      composite &&\n      (placeholder.type === 'FieldValue' || placeholder.type === FIELD_VALUE_LOCAL_NAME) &&\n      composite.definitions.has(placeholder.id)\n    ) {\n      const state = composite.fields.get(placeholder.id);\n      const first = (state ? state.values.first() : undefined) || FieldValue.empty;\n      const valueContent = FieldValue.isAtomic(first) ? first.value.value : '';\n      if (placeholder.type === FIELD_VALUE_LOCAL_NAME && valueContent) {\n        return Rdf.getLocalName(valueContent);\n      } else {\n        return encodeIri(valueContent);\n      }\n    } else {\n      return '';\n    }\n  };\n}\n\nexport function readyToSubmit(composite: CompositeValue, isConsideredError: (error: FieldError) => boolean): boolean {\n  const freeOfErrors = (errors: Immutable.List<FieldError>) => errors.every((error) => !isConsideredError(error));\n\n  return (\n    freeOfErrors(composite.errors) &&\n    composite.fields.every(\n      (state) =>\n        freeOfErrors(state.errors) &&\n        state.values.every((value) =>\n          FieldValue.isComposite(value)\n            ? readyToSubmit(value, isConsideredError)\n            : freeOfErrors(FieldValue.getErrors(value))\n        )\n    )\n  );\n}\n\n/**\n * @returns a tuple of new \"loading\" state of form and a promise of\n *  changes with initial field values.\n */\nexport function loadDefaults(\n  composite: CompositeValue,\n  inputs: Immutable.Map<string, ReadonlyArray<InputMapping>>\n): Kefir.Stream<CompositeChange> {\n  interface FetchedValues {\n    def: FieldDefinition;\n    values?: Immutable.List<FieldValue>;\n    error?: string;\n  }\n\n  const initialValues = composite.definitions\n    .map((def) => {\n      const mappings = inputs.get(def.id);\n      const mapping = mappings && mappings.length > 0 ? mappings[0] : undefined;\n      return loadInitialOrDefaultValues(composite.subject, def, mapping)\n        .map<FetchedValues>((values) => ({ def, values: Immutable.List(values) }))\n        .flatMapErrors<FetchedValues>((error) =>\n          Kefir.constant({\n            def,\n            error: `Failed to load initial values: ${formatError(error)}`,\n          })\n        );\n    })\n    .toArray();\n\n  if (initialValues.length === 0) {\n    return noChanges();\n  }\n\n  const mergeFetchedIntoModel = (model: CompositeValue, results: FetchedValues[]) => {\n    return CompositeValue.set(model, {\n      fields: model.fields.withMutations((states) => {\n        for (const { def, values, error } of results) {\n          let state = states.get(def.id);\n          if (values && values.size > 0) {\n            state = FieldState.set(state, { values });\n          } else if (error) {\n            state = FieldState.set(state, {\n              errors: state.errors.push({\n                kind: ErrorKind.Loading,\n                message: error,\n              }),\n            });\n          }\n          states.set(def.id, state);\n        }\n      }),\n    });\n  };\n\n  return Kefir.zip(initialValues).map((results) => {\n    return (model: CompositeValue) => mergeFetchedIntoModel(model, results);\n  });\n}\n\nfunction loadInitialOrDefaultValues(\n  subject: Rdf.Iri,\n  def: FieldDefinition,\n  mapping?: InputMapping\n): Kefir.Property<FieldValue[]> {\n  const isPlaceholderSubject = CompositeValue.isPlaceholder(subject);\n  const shouldLoadInitials = !isPlaceholderSubject && def.selectPattern;\n  const shouldLoadDefaults = isPlaceholderSubject && mapping;\n\n  // TODO load default values for existing subject only if forceDefaults is true\n  const loadingValues = shouldLoadInitials\n    ? fetchInitialValues(def, subject, mapping)\n      .flatMap(\n        initialValues  => {\n          if(isEmpty(initialValues) && mapping.element.props.forceDefaults) {\n            return lookForDefaultValues(def, mapping)\n          } else {\n            return Kefir.constant(initialValues)\n          }\n        }\n      ).toProperty()\n    : shouldLoadDefaults\n    ? lookForDefaultValues(def, mapping)\n    : Kefir.constant([]);\n\n  return loadingValues.map((values) => {\n    let requiredCount = Math.max(values.length, def.minOccurs);\n    if (!FieldMapping.isComposite(mapping)) {\n      // load at least one empty values for non-composites\n      requiredCount = Math.max(requiredCount, 1);\n    }\n    return setSizeAndFill(values, requiredCount, FieldValue.empty);\n  });\n}\n\nfunction fetchInitialValues(\n  def: FieldDefinition,\n  subject: Rdf.Iri,\n  mapping: InputMapping\n): Kefir.Property<FieldValue[]> {\n  return queryValues(def.selectPattern, subject).map((values) => {\n    let fieldValues: FieldValue[] = values.map((v) => FieldValue.fromLabeled(v));\n\n    // fill loaded values with empty values to always show user at least minOccurs\n    const initialValueCount = Math.max(def.minOccurs, fieldValues.length);\n    fieldValues = setSizeAndFill(fieldValues, initialValueCount, FieldValue.empty);\n\n    return fieldValues;\n  });\n}\n\nfunction setSizeAndFill<T>(list: ReadonlyArray<T>, newSize: number, fillValue: T): Array<T> {\n  const clone = [...list];\n  clone.length = newSize;\n  for (let i = list.length; i < newSize; i++) {\n    clone[i] = fillValue;\n  }\n  return clone;\n}\n\nfunction lookForDefaultValues(def: FieldDefinition, mapping: InputMapping): Kefir.Property<FieldValue[]> {\n  const { defaultValue, defaultValues, forceDefaults } = mapping.element.props;\n  if (defaultValue || defaultValues) {\n    const values = defaultValue ? [defaultValue] : defaultValues;\n    const fieldValues = values.map((value) => parseDefaultValue(value, def, forceDefaults));\n    if (fieldValues.length > 0) {\n      return Kefir.zip(fieldValues).toProperty();\n    }\n  } else if (def.defaultValues.length > 0) {\n    const fieldValues = def.defaultValues.map((value) => parseDefaultValue(value, def, forceDefaults));\n    return Kefir.zip(fieldValues).toProperty();\n  }\n  return Kefir.constant([]);\n}\n\nfunction parseDefaultValue(value: string, def: FieldDefinition, isForcedDefault: boolean) {\n  const atomic = createDefaultValue(value, def, isForcedDefault);\n  return restoreLabel(atomic);\n}\n\nfunction createDefaultValue(\n  value: string, def: FieldDefinition, isForcedDefault: boolean\n): AtomicValue {\n  if (!def.xsdDatatype) {\n    return FieldValue.fromLabeled({ value: Rdf.literal(value), isForcedDefault });\n  } else if (XsdDataTypeValidation.sameXsdDatatype(def.xsdDatatype, vocabularies.xsd.anyURI)) {\n    return FieldValue.fromLabeled({ value: Rdf.iri(value), isForcedDefault });\n  }\n  const literal = Rdf.literal(value, def.xsdDatatype);\n  const { success, message } = XsdDataTypeValidation.validate(literal);\n  if (success) {\n    return FieldValue.fromLabeled({ value: literal, isForcedDefault });\n  } else {\n    return AtomicValue.set(FieldValue.fromLabeled({ value: literal }), {\n      errors: FieldError.noErrors.push({\n        kind: ErrorKind.Loading,\n        message: `Default value doesn't match XSD datatype: ${message}`,\n      }),\n    });\n  }\n}\n\n/**\n * Performs validation of individual values with ({@link FieldDefinition.constrains}) queries.\n *\n * @param owner\n * @param field Definition of field to set new value to.\n * @param newValues New values of field to validate.\n *\n * @returns a promise of changes with validation result of this field.\n */\nexport function tryBeginValidation(\n  field: FieldDefinition,\n  previousComposite: CompositeValue,\n  newComposite: CompositeValue\n): Kefir.Stream<CompositeChange> | undefined {\n  if (!field.constraints || field.constraints.length === 0) {\n    return undefined;\n  }\n\n  const oldValues = previousComposite.fields.get(field.id, FieldState.empty).values;\n  const newValues = newComposite.fields.get(field.id, FieldState.empty).values;\n\n  const streams = newValues.map((value, index) => {\n    const oldValue = index < oldValues.size ? oldValues.get(index) : null;\n    return validate(newComposite.subject, field, oldValue, value);\n  });\n  const compositeChange = Kefir.zip<FieldValue>(streams.toArray()).map((validated) => {\n    const change: CompositeChange = (currentComposite) => {\n      const current = currentComposite.fields.get(field.id);\n      if (!Immutable.is(current.values, newValues)) {\n        // field is changed before completion of validation, so discard result\n        return currentComposite;\n      }\n      const fields = currentComposite.fields.update(field.id, (state) =>\n        FieldState.set(state, {\n          values: Immutable.List(validated),\n        })\n      );\n      return CompositeValue.set(currentComposite, { fields });\n    };\n    return change;\n  });\n\n  return compositeChange;\n}\n\nfunction formatError(error: any): string {\n  if (typeof error === 'string') {\n    return error;\n  } else if (error && typeof error.message === 'string') {\n    return error.message;\n  } else if (error && typeof error.status === 'number') {\n    return 'query error';\n  } else {\n    return 'unknown error occured';\n  }\n}\n\nfunction noChanges(): Kefir.Stream<CompositeChange> {\n  return Kefir.later(0, (value) => value);\n}\n\nexport function fieldInitialState(def: FieldDefinition): FieldState {\n  // display N empty fields where (minOccurs <= N <= maxOccurs)\n  const valueCount = Math.min(def.minOccurs, def.maxOccurs);\n  const values = Immutable.List<FieldValue>()\n    .setSize(valueCount)\n    .map(() => FieldValue.empty);\n  return FieldState.set(FieldState.empty, { values });\n}\n\n/**\n * Pattern to find code points to escape when encoding IRI as object ID; it matches:\n * <ul>\n *  <li> ASCII control characters and space {@code 0x00-0x20} </li>\n *  <li> common illegal path characters: &lt; &gt; : ? * \" | </li>\n *  <li> path separators: / \\ </li>\n *  <li> recommended to avoid by AWS S3: &amp; $ @ = ; + , # {@code 0x7f-0xFF}</li>\n *  <li> escape character: % </li>\n * </ul>\n */\nconst DISALLOWED_CHARACTERS = /[\\u0000-\\u0020<>:?*\"|/\\\\&$@=+,#\\u007f-\\u00ff%\\s]/gi;\nconst COLLAPSE_UNDERSCORES = /_+/gi;\n\nexport function encodeIri(fileName: string) {\n  let transformed = fileName;\n  transformed = transformed.replace(DISALLOWED_CHARACTERS, '_');\n  transformed = transformed.replace(COLLAPSE_UNDERSCORES, '_');\n  return transformed;\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as React from 'react';\nimport * as Immutable from 'immutable';\nimport * as SparqlJs from 'sparqljs';\n\nimport { SparqlUtil, SparqlTypeGuards } from 'platform/api/sparql';\nimport {\n  isValidChild,\n  componentDisplayName,\n  universalChildren,\n} from 'platform/components/utils';\n\nimport { FieldDefinition, FieldDefinitionProp } from './FieldDefinition';\nimport { CompositeValue, FieldError, ErrorKind, DataState, FieldState } from './FieldValues';\nimport { StaticFieldProps } from './static';\n\n// explicitely import base input classes from their respective modules instead of\n// importing from './input' to prevent cyclic dependencies when importing from CompositeInput\nimport {\n  MultipleValuesInput,\n  MultipleValuesProps,\n  MultipleValuesHandler,\n  ValuesWithErrors,\n} from './inputs/MultipleValuesInput';\nimport { CardinalitySupport } from './inputs/CardinalitySupport';\nimport { InputKind, InputReactElement, elementHasInputType, componentHasInputType, elementIsSingleValueInput } from './inputs/InputCommpons';\nimport { InputDecorator } from './inputs/Decorations';\n\nexport type FieldMapping = InputMapping | StaticMapping | OtherElementMapping;\nexport namespace FieldMapping {\n  export function isInput(mapping: FieldMapping): mapping is InputMapping {\n    return 'inputType' in mapping;\n  }\n\n  export function isComposite(mapping: FieldMapping): mapping is InputMapping {\n    return (\n      isInput(mapping) && componentHasInputType(mapping.singleValueInputType, InputKind.CompositeInput)\n    );\n  }\n\n  export function isStatic(mapping: FieldMapping): mapping is StaticMapping {\n    return 'staticType' in mapping;\n  }\n\n  export function isOtherElement(mapping: FieldMapping): mapping is OtherElementMapping {\n    return 'child' in mapping && 'children' in mapping;\n  }\n\n  export function assertNever(mapping: never): never {\n    console.error('Invalid mapping', mapping);\n    throw new Error('Invalid mapping');\n  }\n}\n\ntype InputComponentClass = React.ComponentClass<any> & { inputKind: InputKind } ;\n\nexport interface InputMapping {\n  for: string | undefined;\n  inputType: React.ComponentClass<any>;\n  singleValueInputType?: InputComponentClass;\n  element: React.ReactElement<MultipleValuesProps>;\n}\n\nexport interface StaticMapping {\n  for: string | undefined;\n  staticType: React.ComponentClass<any>;\n  element: React.ReactElement<StaticFieldProps>;\n}\n\nexport interface OtherElementMapping {\n  child: React.ReactElement<any>;\n  children: any;\n}\n\n/**\n * Creates mapping description for single field in a form of `FieldMapping`.\n *\n * Inputs derived from `SingleValueInput` are automatically wrapped by `CardinalitySupport`.\n */\nexport function mapChildToComponent(child: React.ReactNode): FieldMapping | undefined {\n  if (!isValidChild(child)) {\n    return undefined;\n  }\n\n  const element = child as InputReactElement;\n\n  if (elementIsSingleValueInput(element)) {\n    const singleValueInputType = element.type as InputComponentClass;\n    return {\n      for: element.props.for,\n      inputType: CardinalitySupport,\n      singleValueInputType,\n      element: React.createElement(CardinalitySupport, {\n        ...element.props,\n        children: element,\n      }),\n    };\n  } else if (elementHasInputType(element, InputKind.MultiValuesInput)) {\n    const inputType = element.type as React.ComponentClass<any>;\n    return { for: element.props.for, inputType, element };\n  } else if (elementHasInputType(element, InputKind.StaticInput)) {\n    const staticType = element.type as React.ComponentClass<any>;\n    return { for: element.props.for, staticType, element };\n  } else if (element.props.children) {\n    return { child, children: element.props.children };\n  } else {\n    return undefined;\n  }\n}\n\nexport interface FieldConfiguration {\n  inputs: Immutable.Map<string, ReadonlyArray<InputMapping>>;\n  errors: Immutable.List<FieldError>;\n}\n\n/**\n * Creates (and checks if it's correct) mapping description for\n * the whole form children producing `FieldConfiguration`.\n *\n * Use `renderFields()` to render this description into actual React elements.\n */\nexport function validateFieldConfiguration(\n  definitions: Immutable.Map<string, FieldDefinition>,\n  children: React.ReactNode\n): FieldConfiguration {\n  const inputs = Immutable.Map<string, ReadonlyArray<InputMapping>>().asMutable();\n  const errors: FieldError[] = [];\n\n  collectFieldConfiguration(definitions, children, inputs, errors);\n  inputs.forEach((mapping, key) => {\n    const definition = definitions.get(key);\n    if (definition) {\n      collectDefinitionErrors(definition, errors);\n    }\n  });\n\n  return { inputs: inputs.asImmutable(), errors: Immutable.List(errors) };\n}\n\nfunction collectFieldConfiguration(\n  definitions: Immutable.Map<string, FieldDefinition>,\n  children: React.ReactNode,\n  collectedInputs: Immutable.Map<string, ReadonlyArray<InputMapping>>,\n  collectedErrors: FieldError[]\n): void {\n  return React.Children.forEach(children, (child) => {\n    const mapping = mapChildToComponent(child);\n    if (!mapping) {\n      return;\n    }\n\n    if (FieldMapping.isInput(mapping)) {\n      if (mapping.for) {\n        const definition = definitions.get(mapping.for);\n        if (!definition) {\n          collectedErrors.push({\n            kind: ErrorKind.Configuration,\n            message: `Field definition '${mapping.for}' not found`,\n          });\n        }\n        const mappings = collectedInputs.get(mapping.for);\n        collectedInputs.set(mapping.for, mappings ? [...mappings, mapping] : [mapping]);\n      } else {\n        collectedErrors.push({\n          kind: ErrorKind.Configuration,\n          message: `Missing 'for' attribute on ${componentDisplayName(child)}`,\n        });\n      }\n    } else if (FieldMapping.isStatic(mapping)) {\n      if (mapping.for) {\n        const definition = definitions.get(mapping.for);\n        if (!definition) {\n          collectedErrors.push({\n            kind: ErrorKind.Configuration,\n            message: `Field definition '${mapping.for}' not found`,\n          });\n        }\n      }\n    } else if (FieldMapping.isOtherElement(mapping)) {\n      collectFieldConfiguration(definitions, mapping.children, collectedInputs, collectedErrors);\n    } else {\n      FieldMapping.assertNever(mapping);\n    }\n  });\n}\n\nexport function renderFields(\n  inputChildren: React.ReactNode,\n  model: CompositeValue,\n  inputHandlers: Immutable.Map<string, ReadonlyArray<MultipleValuesHandler>>,\n  getDataState: (fieldId: string) => DataState,\n  onValuesChanged: (field: FieldDefinition, reducer: (previous: ValuesWithErrors) => ValuesWithErrors) => void,\n  onInputMounted: (inputId: string, index: number, input: MultipleValuesInput<any, any>) => void\n) {\n  const inputIndices = new Map<string, number>();\n\n  function mapChild(child: React.ReactNode) {\n    const mapping = mapChildToComponent(child);\n    if (!mapping) {\n      return child;\n    } else if (FieldMapping.isInput(mapping)) {\n      if (!mapping.for) {\n        return null;\n      }\n      const definition = model.definitions.get(mapping.for);\n\n      if (!definition) {\n        return null;\n      }\n      const state = model.fields.get(mapping.for, FieldState.empty);\n\n      const index = inputIndices.get(mapping.for) || 0;\n      inputIndices.set(mapping.for, index + 1);\n\n      const handlers = inputHandlers.get(mapping.for);\n      if (index >= handlers.length) {\n        throw new Error(`Missing handler for field ${mapping.for} (at index ${index})`);\n      }\n      const handler = handlers[index];\n\n      // save a reference to mapped component for validation\n      // and lazy selectPattern evaluation\n      const onMounted = (input: MultipleValuesInput<any, any>) => {\n        onInputMounted(mapping.for, index, input);\n      };\n\n      const baseProvidedProps: Partial<MultipleValuesProps> = {\n        definition,\n        handler,\n        dataState: getDataState(mapping.for),\n        values: state.values,\n        errors: state.errors,\n        updateValues: (reducer) => onValuesChanged(definition, reducer),\n      };\n      const inputOverride: Partial<MultipleValuesProps> & React.Props<any> = {\n        ...baseProvidedProps,\n        ref: onMounted,\n      };\n      return React.createElement(\n        InputDecorator,\n        { ...mapping.element.props, ...baseProvidedProps },\n        React.cloneElement(mapping.element, inputOverride)\n      );\n    } else if (FieldMapping.isStatic(mapping)) {\n      const { element } = mapping;\n      const override: Partial<StaticFieldProps> = { model };\n      if (element.props.for) {\n        const definition = model.definitions.get(element.props.for);\n        if (!definition) {\n          return null;\n        }\n        override.definition = definition;\n      }\n      return React.cloneElement(mapping.element, override);\n    } else if (FieldMapping.isOtherElement(mapping)) {\n      const mappedChildren = mapChildren(mapping.children);\n      return React.cloneElement(mapping.child, {}, mappedChildren);\n    } else {\n      throw new Error('Invalid mapping');\n    }\n  }\n\n  function mapChildren(children: React.ReactNode) {\n    return universalChildren(React.Children.map(children, mapChild));\n  }\n\n  return mapChildren(inputChildren);\n}\n\n/**\n * @returns list of errors in the field definition.\n */\nexport function collectDefinitionErrors(definition: FieldDefinition, errors: FieldError[]) {\n  const resultErrors: string[] = [];\n  function store(member: keyof FieldDefinitionProp, error: ValidationError | undefined) {\n    if (error instanceof ValidationError) {\n      errors.push({\n        kind: ErrorKind.Configuration,\n        message: `Invalid ${member} of field '${definition.id}': ${error.message}`,\n      });\n    }\n  }\n\n  if (definition.selectPattern) {\n    store('selectPattern', validateQueryPattern(definition.selectPattern, 'SELECT'));\n  }\n  if (definition.valueSetPattern) {\n    store('valueSetPattern', validateQueryPattern(definition.valueSetPattern, 'SELECT'));\n  }\n  if (definition.deletePattern) {\n    store('deletePattern', validateDeletePattern(definition.deletePattern));\n  }\n  if (definition.insertPattern) {\n    store('insertPattern', validateInsertPattern(definition.insertPattern));\n  }\n  if (definition.autosuggestionPattern) {\n    store('autosuggestionPattern', validateQueryPattern(definition.autosuggestionPattern, 'SELECT'));\n  }\n  for (const constraint of definition.constraints) {\n    store('askPattern', validateQueryPattern(constraint.validatePattern, 'ASK'));\n  }\n}\n\nfunction validateInsertPattern(pattern: string): ValidationError | undefined {\n  const query = parseQuery(pattern);\n  if (query instanceof ValidationError) {\n    return query;\n  }\n  if (query.type !== 'update') {\n    return new ValidationError(`should be INSERT query but was: '${query.type}'`);\n  }\n  for (const update of query.updates) {\n    const isInsertWhere =\n      SparqlTypeGuards.isInsertDeleteOperation(update) &&\n      update.updateType === 'insertdelete' &&\n      update.delete.length === 0;\n    if (!isInsertWhere) {\n      return new ValidationError('query should include only INSERT WHERE operations');\n    }\n  }\n  return undefined;\n}\n\nfunction validateDeletePattern(pattern: string): ValidationError | undefined {\n  const query = parseQuery(pattern);\n  if (query instanceof ValidationError) {\n    return query;\n  }\n  if (query.type !== 'update') {\n    return new ValidationError(`should be DELETE query but was: '${query.type}'`);\n  }\n  for (const update of query.updates) {\n    const isDeleteWhere =\n      SparqlTypeGuards.isInsertDeleteOperation(update) &&\n      update.updateType === 'insertdelete' &&\n      update.insert.length === 0;\n    if (!isDeleteWhere) {\n      return new ValidationError('query should include only DELETE WHERE operations');\n    }\n  }\n  return undefined;\n}\n\nfunction validateQueryPattern(pattern: string, queryType: SparqlJs.Query['queryType']): ValidationError | undefined {\n  const query = parseQuery(pattern);\n  if (query instanceof ValidationError) {\n    return query;\n  }\n  if (query.type !== 'query') {\n    return new ValidationError(`should be ${queryType} query but was: '${query.type}'`);\n  }\n  if (query.queryType !== queryType) {\n    return new ValidationError(`should be ${queryType} query but was: '${query.queryType}'`);\n  }\n  return undefined;\n}\n\nfunction parseQuery(query: string): SparqlJs.SparqlQuery | ValidationError {\n  try {\n    return SparqlUtil.parseQuery(query);\n  } catch (err) {\n    return new ValidationError(err.message);\n  }\n}\n\nclass ValidationError {\n  constructor(readonly message: string) {}\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { uniqueId } from 'lodash';\nimport * as Immutable from 'immutable';\nimport * as Kefir from 'kefir';\n\nimport { ReactNode, Children, createElement, cloneElement, ReactElement, ClassAttributes } from 'react';\nimport * as D from 'react-dom-factories';\nimport * as classnames from 'classnames';\nimport { Button } from 'react-bootstrap';\n\nimport {\n  isValidChild,\n  universalChildren,\n} from 'platform/components/utils';\n\nimport { FieldDefinition, getPreferredLabel } from '../FieldDefinition';\nimport {\n  FieldValue,\n  EmptyValue,\n  CompositeValue,\n  DataState,\n  ErrorKind,\n  FieldError,\n  mergeDataState,\n} from '../FieldValues';\n\nimport { SingleValueInput, SingleValueInputProps, SingleValueHandler } from './SingleValueInput';\nimport {\n  MultipleValuesInput,\n  MultipleValuesProps,\n  MultipleValuesHandler,\n  MultipleValuesHandlerProps,\n  ValuesWithErrors,\n  checkCardinalityAndDuplicates,\n} from './MultipleValuesInput';\nimport { InputKind, InputReactElement, elementHasInputType, elementIsSingleValueInput } from './InputCommpons';\n\nexport interface CardinalitySupportProps extends MultipleValuesProps {\n  children?: ReactNode;\n}\n\nconst COMPONENT_NAME = 'cardinality-support';\n\ntype ChildInput = SingleValueInput<SingleValueInputProps, unknown>;\n\n/**\n * Wraps {@link SingleValueInput} and exposes self as {@link MultipleValuesInput}\n * by duplicating input component for each field value.\n *\n * This component validates cardinality of field and produces corresponding errors\n * through {@link Props.onValuesChanged}.\n */\nexport class CardinalitySupport extends MultipleValuesInput<CardinalitySupportProps, {}> {\n  /**\n   * React element keys corresponding to field values, to prevent incorrect\n   * virtual DOM merging when adding or deleting values.\n   */\n  private valueKeys: string[] = [];\n\n  private readonly inputs = new Map<string, ChildInput[]>();\n  private lastRenderedDataState: DataState | undefined;\n\n  private getHandler(): CardinalitySupportHandler {\n    const { handler } = this.props;\n    if (!(handler instanceof CardinalitySupportHandler)) {\n      throw new Error('Invalid value handler for CardinalitySupport');\n    }\n    return handler;\n  }\n\n  shouldComponentUpdate(nextProps: CardinalitySupportProps, nextState: {}) {\n    if (this.state !== nextState) {\n      return true;\n    }\n    const previous = this.props;\n    return !(\n      this.dataState() === this.lastRenderedDataState &&\n      previous.renderHeader === nextProps.renderHeader &&\n      previous.definition === nextProps.definition &&\n      previous.dataState === nextProps.dataState &&\n      previous.errors === nextProps.errors &&\n      (previous.values === nextProps.values ||\n        (previous.values.size === nextProps.values.size &&\n          previous.values.every((item, index) => item === nextProps.values.get(index))))\n    );\n  }\n\n  render(): ReactElement<any> {\n    const definition = this.props.definition;\n    if (definition.maxOccurs === 0) {\n      return D.div({});\n    }\n\n    const dataState = this.props.dataState;\n    this.lastRenderedDataState = this.dataState();\n\n    const size = this.props.values.size;\n    const canEdit = dataState === DataState.Ready || dataState === DataState.Verifying;\n    const canAddValue = canEdit && size < definition.maxOccurs;\n    const canRemoveValue = canEdit && size > definition.minOccurs && size > 0;\n    const fieldLabel = (this.props.label || getPreferredLabel(definition.label) || 'value').toLowerCase();\n\n    return D.div(\n      { className: COMPONENT_NAME },\n\n      this.renderChildren(canRemoveValue),\n\n      canAddValue\n        ? D.a(\n            {\n              className: classnames({\n                [`${COMPONENT_NAME}__add-value`]: true,\n                [`${COMPONENT_NAME}__add-value--first`]: size === 0,\n                [`${COMPONENT_NAME}__add-value--another`]: size > 0,\n              }),\n              onClick: this.addNewValue,\n            },\n            `+ Add ${fieldLabel}`\n          )\n        : null\n    );\n  }\n\n  private renderChildren(canRemoveValue: boolean) {\n    this.ensureValueKeys(this.props.values.size);\n\n    const childIsInputGroup = isInputGroup(this.props.children);\n\n    // if we don't want to render header and cardinality is 1 then there there is no reason to show the group borders and other styles\n    const canCollapseGroup =\n      this.props.renderHeader === false &&\n      this.props.definition.minOccurs === 1 &&\n      this.props.definition.maxOccurs === 1;\n\n    const className = childIsInputGroup && !canCollapseGroup ? `${COMPONENT_NAME}__group-instance` : `${COMPONENT_NAME}__single-instance`;\n\n    return this.props.values.map((value, index) =>\n      D.div(\n        { key: this.valueKeys[index], className },\n        renderChildInputs(\n          this.props,\n          this.getHandler(),\n          value,\n          this.valueKeys[index],\n          (reducer) => {\n            this.onValuesChanged((values) => values.update(index, reducer));\n          },\n          (key, inputIndex, input) => {\n            let refs = this.inputs.get(key);\n            if (!refs) {\n              refs = [];\n              this.inputs.set(key, refs);\n            }\n            refs[inputIndex] = input;\n          }\n        ),\n        canRemoveValue\n          ? createElement(\n              Button,\n              {\n                className: COMPONENT_NAME + '__remove-value',\n                onClick: () => this.removeValue(index),\n              },\n              D.span({ className: 'fa fa-times' })\n            )\n          : undefined\n      )\n    );\n  }\n\n  private ensureValueKeys(valueCount: number) {\n    while (this.valueKeys.length < valueCount) {\n      this.valueKeys.push(uniqueId());\n    }\n  }\n\n  private addNewValue = () => {\n    this.onValuesChanged(() => this.props.values.push(FieldValue.empty));\n  };\n\n  private removeValue = (valueIndex: number) => {\n    this.valueKeys.splice(valueIndex, 1);\n    this.onValuesChanged(() => this.props.values.remove(valueIndex));\n  };\n\n  private onValuesChanged(reducer: (previous: Immutable.List<FieldValue>) => Immutable.List<FieldValue>) {\n    const handler = this.getHandler();\n    this.props.updateValues((previous) => {\n      const newValues = reducer(previous.values);\n      const validated = handler.validate({ values: newValues, errors: previous.errors }, false);\n      return validated;\n    });\n  }\n\n  dataState(): DataState {\n    let result = DataState.Ready;\n    for (const key of this.valueKeys) {\n      const refs = this.inputs.get(key);\n      if (!refs) {\n        result = mergeDataState(result, DataState.Loading);\n        continue;\n      }\n      for (const ref of refs) {\n        if (ref) {\n          result = mergeDataState(result, ref.dataState());\n        }\n      }\n    }\n    return result;\n  }\n\n  static makeHandler(props: MultipleValuesHandlerProps<CardinalitySupportProps>): CardinalitySupportHandler {\n    return new CardinalitySupportHandler(props);\n  }\n}\n\nfunction renderChildInputs(\n  this: void,\n  inputProps: CardinalitySupportProps,\n  inputHandler: CardinalitySupportHandler,\n  value: FieldValue,\n  key: string,\n  updateValue: (reducer: (value: FieldValue) => FieldValue) => void,\n  onInputMount: (key: string, inputIndex: number, input: ChildInput | null) => void\n) {\n  let nextIndex = 0;\n  function mapChildren(this: void, children: ReactNode) {\n    return universalChildren(\n      Children.map(children, (child) => {\n        if (isValidChild(child)) {\n          const element = child as InputReactElement;\n          if (elementIsSingleValueInput(element)) {\n            const inputIndex = nextIndex;\n            nextIndex++;\n\n            if (inputIndex > inputHandler.handlers.length) {\n              throw new Error(`Missing handler for cardinality field ${inputProps.for} at index ${inputIndex}`);\n            }\n            const handler = inputHandler.handlers[inputIndex];\n\n            const props: SingleValueInputProps & ClassAttributes<ChildInput> = {\n              for: inputProps.for,\n              handler,\n              definition: inputProps.definition,\n              dataState: inputProps.dataState,\n              value: value,\n              updateValue,\n              ref: (input) => onInputMount(key, inputIndex, input),\n            };\n            return cloneElement(element, props);\n          } else if (element.props.children) {\n            return cloneElement(element, {}, mapChildren(element.props.children));\n          }\n        }\n        return child;\n      })\n    );\n  }\n  return mapChildren(inputProps.children);\n}\n\nclass CardinalitySupportHandler implements MultipleValuesHandler {\n  readonly definition: FieldDefinition;\n  readonly handlers: ReadonlyArray<SingleValueHandler>;\n\n  constructor(props: MultipleValuesHandlerProps<CardinalitySupportProps>) {\n    this.definition = props.definition;\n    this.handlers = findInputs(props.baseInputProps.children).map((input) => {\n      return SingleValueInput.getHandlerOrDefault(input.type as any, {\n        definition: this.definition,\n        baseInputProps: input.props,\n      });\n    });\n  }\n\n  /**\n   * Performs cardinality validation of field and\n   * validates its values with wrapped {@link SingleValueInput}.\n   */\n  validate({ values, errors }: ValuesWithErrors, validateByChildInput = true) {\n    const otherErrors = errors.filter((e) => e.kind !== ErrorKind.Input).toList();\n    const cardinalityErrors = this.validateCardinality(values);\n    return {\n      values: validateByChildInput ? values.map(this.validateThoughChildInputs) : values,\n      errors: otherErrors.concat(cardinalityErrors),\n    };\n  }\n\n  private validateThoughChildInputs = (value: FieldValue) => {\n    if (FieldValue.isEmpty(value)) {\n      return value;\n    }\n    const cleanValue = FieldValue.setErrors(value, FieldError.noErrors);\n    // combine errors from every child input\n    let validated: FieldValue = cleanValue;\n    for (const handler of this.handlers) {\n      validated = handler.validate(validated);\n    }\n    return validated;\n  };\n\n  private validateCardinality(values: Immutable.List<FieldValue>): Immutable.List<FieldError> {\n    let preparedValues = values;\n    for (const handler of this.handlers) {\n      if (handler.finalizeSubject) {\n        preparedValues = values.map((v) => {\n          // finalize subject to distinguish composites\n          return FieldValue.isComposite(v) ? handler.finalizeSubject(FieldValue.empty, v) : v;\n        });\n      }\n    }\n    return checkCardinalityAndDuplicates(preparedValues, this.definition);\n  }\n\n  finalize(\n    values: Immutable.List<FieldValue>,\n    owner: EmptyValue | CompositeValue\n  ): Kefir.Property<Immutable.List<FieldValue>> {\n    let finalizing = Kefir.constant(values);\n    for (const handler of this.handlers) {\n      finalizing = finalizing\n        .flatMap((intermediates) => {\n          const tasks = intermediates.map((value) => handler.finalize(value, owner)).toArray();\n          if (tasks.length > 0) {\n            return Kefir.zip(tasks)\n              .map((properties) => Immutable.List(properties))\n              .toProperty();\n          } else {\n            return Kefir.constant(Immutable.List<FieldValue>());\n          }\n        })\n        .toProperty();\n    }\n    return finalizing;\n  }\n}\n\nfunction findInputs(inputChildren: ReactNode): ReactElement<SingleValueInputProps>[] {\n  const foundInputs: ReactElement<SingleValueInputProps>[] = [];\n\n  function collectInputs(children: ReactNode) {\n    Children.forEach(children, (child) => {\n      if (isValidChild(child)) {\n        const element = child as InputReactElement;\n        if (elementIsSingleValueInput(element)) {\n          foundInputs.push(element);\n        } else if (element.props.children) {\n          collectInputs(element.props.children);\n        }\n      }\n    });\n  }\n\n  collectInputs(inputChildren);\n  return foundInputs;\n}\n\nfunction isInputGroup(children: ReactNode) {\n  const childCount = Children.count(children);\n  if (childCount !== 1) {\n    return childCount > 1;\n  }\n  const child = Children.toArray(children)[0] as InputReactElement;\n  if (!isValidChild(child)) {\n    return true;\n  }\n  return (\n    elementHasInputType(child, InputKind.CompositeInput) ||\n      elementHasInputType(child, InputKind.FormSwitch) ||\n      !elementIsSingleValueInput(child)\n  );\n}\n\nMultipleValuesInput.assertStatic(CardinalitySupport);\n\nexport default CardinalitySupport;\n"],"sourceRoot":""}