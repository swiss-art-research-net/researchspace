{"version":3,"sources":["webpack:///./src/main/web/components/semantic/radar-plot/RadarPlot.tsx","webpack:///./src/main/web/components/semantic/radar-plot/Geometry.ts","webpack:///./src/main/web/components/semantic/radar-plot/Layout.ts"],"names":["props","context","cancellation","Cancellation","uniquePrefix","uniqueId","showPopover","type","iri","label","target","template","templates","newPopover","Overlay","key","show","rootClose","onHide","setState","popover","undefined","placement","Popover","id","title","style","width","popoverWidth","TemplateItem","source","options","state","layout","items","computeLayout","render","height","className","styles","component","this","renderSvg","Number","componentDidMount","query","reloadItems","componentWillReceiveProps","nextProps","loadedItems","map","loadItems","SparqlClient","select","results","bindings","binding","subsector","ring","cluster","distance","color","itemDistance","value","isFinite","console","warn","push","semanticContext","observe","error","err","itemRadius","Spinner","orderedSubsectors","headerHeight","Math","min","ringLabelHeight","center","x","y","outerRadius","innerSubHeaderRadius","Vector","subtract","directionFromIndex","index","location","length","normed","approximateUniformEllipticAngle","angle","PI","fromAngle","cellPadding","getItemPosition","item","computeItemPosition","outerAreaRadius","subsectorIndex","sectorLayouts","startIndex","ringIndex","ringIndices","rings","radius","scale","sectorLength","approximateEllipsePerimeter","xPadding","paddedX","Scalar","lerp","direction","outerPointer","ellipsePointFromDirection","ringHeight","pointer","normalize","add","parseStyle","ModuleRegistry","parseReactStyleFromCss","sectorLabelStyle","subsectorLabelStyle","ringLabelStyle","itemLabelStyle","Background","Headers","Grid","labelStyle","Clusters","Items","defaultProps","clusters","Component","RadarPlot","sectors","subsectorsBySector","sectorColors","innerHeaderRadius","headers","sector","i","endIndex","SectorHeader","onTriggerPopover","sectorHeader","shortId","startDirection","endDirection","innerRadius","j","subsectorHeader","innerStart","innerMiddle","innerEnd","outerStart","outerEnd","triggerOnHeader","e","parent","currentTarget","Element","querySelector","sectorPopoverTarget","labelPathId","onMouseEnter","onClick","d","fill","cx","cy","r","fontSize","textAnchor","xlinkHref","dominantBaseline","startOffset","ringSize","background","inner","outer","renderRing","ringArea","lineEndFromIndex","grid","ringLine","ringLabel","alignmentBaseline","sectorEnd","subsectors","sectorLine","x1","y1","x2","y2","subsectorEnd","subsectorLine","clusterColors","points","filter","convexHull","convexHullOf","marginRadius","orthogonalClockwise","v","pathGeometry","p","previousIndex","nextIndex","previous","next","previousOrthogonal","nextOrthogonal","previousPivot","nextPivot","midPrevious","midNext","join","stroke","itemsBySubsector","normalizedPositions","position","clustersByIri","renderItem","sqrt","a","b","s","m","inverseLength","cross","cos","sin","sx","nx","sy","ny","k","rx","ry","sign","pow","abs","maxY","maxBy","pivot","minBy","orderedPoints","orderBy","atan2","splice","indexOf","stack","shift","isRightTurn","top","nextToTop","topSegment","suggestedSegement","pop","computeItemsLayout","random","LcgRandom","sectorItems","forEach","cellItems","computeItemsRange","minDistance","Infinity","maxDistance","max","orderedItems","shuffle","groupBy","sub","flatten","nextSubsectorIndex","parentSector","parentColor","hcl","defaultSectorColor","sectorIndex","sectorCount","hue","toString","subColor","defaultSubsectorColor","childIndex","childCount","h","c","l","intensity","clusterIndex","defaultClusterColor","clusterCount","sectorLayout","Error","keyBy","seed","range","nextInteger","excludedMax","normalized","floor","result","left","chosen"],"mappings":"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","file":"mp-radar-plot-f76dab86c7a6355cee3a.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport * as React from 'react';\nimport { ReactElement, CSSProperties } from 'react';\nimport { mapValues, uniqueId } from 'lodash';\nimport { Overlay, Popover } from 'react-bootstrap';\n\nimport { Cancellation } from 'platform/api/async';\nimport { Component } from 'platform/api/components';\nimport { ModuleRegistry } from 'platform/api/module-loader';\nimport { SparqlClient } from 'platform/api/sparql';\n\nimport { Spinner } from 'platform/components/ui/spinner';\nimport { TemplateItem } from 'platform/components/ui/template';\n\nimport {\n  RadarPlotProps,\n  SectorDescription,\n  SubSectorDescription,\n  ItemDescription,\n  RingDescription,\n  RadarTemplates,\n} from './Config';\nimport {\n  Scalar,\n  Vector,\n  ellipsePointFromDirection,\n  approximateUniformEllipticAngle,\n  approximateEllipsePerimeter,\n  convexHullOf,\n} from './Geometry';\nimport { PlotLayout, computeLayout } from './Layout';\n\nimport * as styles from './RadarPlot.scss';\n\ninterface State {\n  readonly loadedItems?: ReadonlyArray<ItemDescription>;\n  readonly layout?: PlotLayout;\n  readonly popover?: ReactElement<any>;\n}\n\ntype TemplateType = keyof RadarTemplates;\n\n/**\n * @example\n  <mp-radar-plot width='1600' height='450'\n    sectors='[\n      {\"iri\": \"test:a\", \"label\": \"Test A\"},\n      {\"iri\": \"test:b\", \"label\": \"Test B\"},\n      {\"iri\": \"test:c\", \"label\": \"Test C\"}\n    ]'\n    subsectors='[\n      {\"sector\": \"test:a\", \"iri\": \"test:a/1\", \"label\": \"Test A1\"},\n      {\"sector\": \"test:b\", \"iri\": \"test:b/1\", \"label\": \"Test B1\"},\n      {\"sector\": \"test:b\", \"iri\": \"test:b/2\", \"label\": \"Test B2\"},\n      {\"sector\": \"test:b\", \"iri\": \"test:b/3\", \"label\": \"Test B3\"},\n      {\"sector\": \"test:c\", \"iri\": \"test:c/1\", \"label\": \"Test C1\"},\n      {\"sector\": \"test:c\", \"iri\": \"test:c/2\", \"label\": \"Test C2\"}\n    ]'\n    rings='[\n      {\"iri\": \"test:ring-1\", \"label\": \"Horizon 1\"},\n      {\"iri\": \"test:ring-2\", \"label\": \"Horizon 2\", \"color\": \"#ebffe5\"},\n      {\"iri\": \"test:ring-3\", \"label\": \"Horizon 3\"}\n    ]'\n    clusters='[\n      {\"iri\": \"test:cluster-1\", \"label\": \"Test Cluster 1\"},\n      {\"iri\": \"test:cluster-2\", \"label\": \"Test Cluster 2\"}\n    ]'\n    templates='{\n      \"subSector\": \"<div>Sub-sector {{label}}:<br>{{iri}}</div>\",\n      \"point\": \"<div>Point {{label}}:<br>{{iri}}</div>\"\n    }'\n    subsector-label-style='fill: red'\n    query='\n      SELECT * WHERE {\n        VALUES (?subsector ?ring ?iri ?label ?distance ?cluster) {\n          (<test:a/1> <test:ring-2> <test:a/1/1> \"A-1-1\" 10 <test:cluster-1>)\n          (<test:a/1> <test:ring-2> <test:a/1/2> \"A-1-2\" 20 <test:cluster-1>)\n          (<test:b/2> <test:ring-1> <test:b/2/1> \"B-2-1\" 0 <test:cluster-1>)\n          (<test:b/2> <test:ring-2> <test:b/2/2> \"B-2-2\" 5 <test:cluster-1>)\n          (<test:b/2> <test:ring-2> <test:b/2/3> \"B-2-3\" 13 UNDEF)\n          (<test:b/3> <test:ring-3> <test:b/3/1> \"B-3-1\" 23 <test:cluster-2>)\n          (<test:b/3> <test:ring-3> <test:b/3/2> \"B-3-2\" 2 <test:cluster-2>)\n          (<test:b/3> <test:ring-3> <test:b/3/3> \"B-3-3\" 25 <test:cluster-2>)\n        }\n      }\n    '\n  >\n  </mp-radar-plot>\n */\nexport class RadarPlot extends Component<RadarPlotProps, State> {\n  static readonly defaultProps: Partial<RadarPlotProps> = {\n    clusters: [],\n    templates: {},\n    itemRadius: 15,\n    popoverWidth: 200,\n  };\n\n  private readonly cancellation = new Cancellation();\n  private readonly uniquePrefix = uniqueId('RadarPlot-');\n\n  constructor(props: RadarPlotProps, context: any) {\n    super(props, context);\n    this.state = {\n      layout: this.props.items ? computeLayout(this.props) : undefined,\n    };\n  }\n\n  render() {\n    const { width, height } = this.props;\n    return <div className={styles.component}>{this.renderSvg(Number(width), Number(height))}</div>;\n  }\n\n  componentDidMount() {\n    if (this.props.query) {\n      this.reloadItems(this.props);\n    }\n  }\n\n  componentWillReceiveProps(nextProps: RadarPlotProps) {\n    if (nextProps.query !== this.props.query) {\n      this.setState({ loadedItems: undefined, layout: undefined });\n      this.reloadItems(nextProps);\n    }\n  }\n\n  private reloadItems(props: RadarPlotProps) {\n    this.cancellation.map(loadItems(props.query, this.context.semanticContext)).observe({\n      value: (loadedItems) => {\n        this.setState(\n          (state, props): State => ({\n            loadedItems,\n            layout: computeLayout({ ...props, items: loadedItems }),\n          })\n        );\n      },\n      error: (err) => console.error(err),\n    });\n  }\n\n  renderSvg(width: number, height: number) {\n    const { itemRadius } = this.props;\n    const { layout, popover } = this.state;\n    if (!layout) {\n      return (\n        <div style={{ width, height }}>\n          <Spinner />\n        </div>\n      );\n    }\n\n    const { orderedSubsectors } = layout;\n\n    const MAX_HEDER_HEIGHT = 50;\n    const headerHeight = Math.min(height / 8, 50);\n    const ringLabelHeight = headerHeight;\n\n    const center: Vector = { x: width / 2, y: height - ringLabelHeight };\n    const outerRadius = { x: width / 2, y: height - ringLabelHeight };\n    const innerSubHeaderRadius = Vector.subtract(outerRadius, { x: headerHeight * 2, y: headerHeight * 2 });\n\n    const directionFromIndex = (index: number) => {\n      const location = index / orderedSubsectors.length;\n      const normed = approximateUniformEllipticAngle(location, outerRadius.x, outerRadius.y);\n      // multiply by -1 to account for inverted Y axis in SVG coordinates\n      const angle = -1 * Math.PI * (1 - normed);\n      return Vector.fromAngle(angle);\n    };\n\n    const cellPadding = itemRadius;\n    const getItemPosition = (item: ItemDescription) => {\n      return computeItemPosition(item, layout, directionFromIndex, center, innerSubHeaderRadius, cellPadding);\n    };\n\n    const parseStyle = (style: string) => ModuleRegistry.parseReactStyleFromCss(style);\n    const sectorLabelStyle = parseStyle(this.props.sectorLabelStyle);\n    const subsectorLabelStyle = parseStyle(this.props.subsectorLabelStyle);\n    const ringLabelStyle = parseStyle(this.props.ringLabelStyle);\n    const itemLabelStyle = parseStyle(this.props.itemLabelStyle);\n\n    return (\n      <svg width={width} height={height}>\n        <Background layout={layout} center={center} outerRadius={innerSubHeaderRadius} />\n        <Headers\n          layout={layout}\n          sectorLabelStyle={sectorLabelStyle}\n          subsectorLabelStyle={subsectorLabelStyle}\n          showPopover={this.showPopover}\n          directionFromIndex={directionFromIndex}\n          uniquePrefix={this.uniquePrefix}\n          center={center}\n          outerRadius={outerRadius}\n          height={headerHeight}\n        />\n        <Grid\n          layout={layout}\n          labelStyle={ringLabelStyle}\n          showPopover={this.showPopover}\n          directionFromIndex={directionFromIndex}\n          center={center}\n          innerSubHeaderRadius={innerSubHeaderRadius}\n          ringLabelHeight={ringLabelHeight}\n        />\n        <Clusters\n          layout={layout}\n          showPopover={this.showPopover}\n          getItemPosition={getItemPosition}\n          itemRadius={itemRadius}\n        />\n        <Items\n          layout={layout}\n          labelStyle={itemLabelStyle}\n          showPopover={this.showPopover}\n          directionFromIndex={directionFromIndex}\n          getItemPosition={getItemPosition}\n          itemRadius={itemRadius}\n        />\n        {popover}\n      </svg>\n    );\n  }\n\n  private showPopover = (type: TemplateType, iri: string, label: string, target: EventTarget) => {\n    const template = this.props.templates[type];\n    const newPopover = (\n      <Overlay\n        key={`${type}:${iri}`}\n        show={true}\n        rootClose={true}\n        onHide={() => {\n          this.setState({ popover: undefined });\n        }}\n        placement=\"bottom\"\n        target={target as Element}\n      >\n        <Popover id=\"radar-plot-popover\" title={`${label}`}>\n          <div style={{ width: this.props.popoverWidth }}>\n            {template ? (\n              <TemplateItem template={{ source: template, options: { iri, label } }} />\n            ) : (\n              <i>No info available</i>\n            )}\n          </div>\n        </Popover>\n      </Overlay>\n    );\n    this.setState({ popover: newPopover });\n  };\n}\n\nfunction loadItems(query: string, context: SparqlClient.QueryContext) {\n  return SparqlClient.select(query, { context }).map(({ results }) => {\n    const items: ItemDescription[] = [];\n    for (const binding of results.bindings) {\n      const { iri, subsector, ring, cluster, label, distance, color } = binding;\n      if (iri && subsector && distance) {\n        const itemDistance = Number(distance.value);\n        if (!Number.isFinite(itemDistance)) {\n          console.warn(`Invalid distance for item '${iri}'`);\n        }\n        items.push({\n          iri: iri.value,\n          subsector: subsector.value,\n          ring: ring.value,\n          cluster: cluster ? cluster.value : undefined,\n          label: label ? label.value : iri.value,\n          distance: Number.isFinite(itemDistance) ? itemDistance : 0,\n          color: color ? color.value : undefined,\n        });\n      }\n    }\n    return items;\n  });\n}\n\nclass Headers extends Component<\n  {\n    layout: PlotLayout;\n    sectorLabelStyle: CSSProperties;\n    subsectorLabelStyle: CSSProperties;\n    showPopover: (type: TemplateType, iri: string, label: string, target: EventTarget) => void;\n    directionFromIndex: (index: number) => Vector;\n    uniquePrefix: string;\n    center: Vector;\n    outerRadius: Vector;\n    height: number;\n  },\n  {}\n> {\n  render() {\n    const {\n      layout,\n      sectorLabelStyle,\n      subsectorLabelStyle,\n      showPopover,\n      directionFromIndex,\n      uniquePrefix,\n      center,\n      outerRadius,\n      height,\n    } = this.props;\n    const { sectors, subsectorsBySector, orderedSubsectors, sectorLayouts, sectorColors } = layout;\n    const innerHeaderRadius = Vector.subtract(outerRadius, { x: height, y: height });\n    const innerSubHeaderRadius = Vector.subtract(innerHeaderRadius, { x: height, y: height });\n    return (\n      <g className={styles.headers}>\n        {sectors.map((sector, i) => {\n          const { startIndex, endIndex } = sectorLayouts[sector.iri];\n          return (\n            <SectorHeader\n              key={sector.iri}\n              onTriggerPopover={(target) => {\n                showPopover('sector', sector.iri, sector.label, target);\n              }}\n              className={styles.sectorHeader}\n              style={sectorLabelStyle}\n              shortId={`${uniquePrefix}-sector-${i}`}\n              startDirection={directionFromIndex(startIndex)}\n              endDirection={directionFromIndex(endIndex)}\n              center={center}\n              innerRadius={innerHeaderRadius}\n              headerHeight={height}\n              label={sector.label}\n              color={sectorColors[sector.iri]}\n            />\n          );\n        })}\n        {orderedSubsectors.map((subsector, j) => {\n          const { startIndex, endIndex } = sectorLayouts[subsector.iri];\n          return (\n            <SectorHeader\n              key={subsector.iri}\n              onTriggerPopover={(target) => {\n                showPopover('subsector', subsector.iri, subsector.label, target);\n              }}\n              className={styles.subsectorHeader}\n              style={subsectorLabelStyle}\n              shortId={`${uniquePrefix}-subsector-${j}`}\n              startDirection={directionFromIndex(startIndex)}\n              endDirection={directionFromIndex(endIndex)}\n              center={center}\n              innerRadius={innerSubHeaderRadius}\n              headerHeight={height}\n              label={subsector.label}\n              color={sectorColors[subsector.iri]}\n            />\n          );\n        })}\n      </g>\n    );\n  }\n}\n\nclass SectorHeader extends Component<\n  {\n    onTriggerPopover: (target: EventTarget) => void;\n    className: string;\n    style: CSSProperties;\n    shortId: string;\n    startDirection: Vector;\n    endDirection: Vector;\n    center: Vector;\n    innerRadius: Vector;\n    headerHeight: number;\n    label: string;\n    color: string;\n  },\n  {}\n> {\n  render() {\n    const {\n      onTriggerPopover,\n      className,\n      style,\n      shortId,\n      startDirection,\n      endDirection,\n      center,\n      innerRadius,\n      headerHeight,\n      label,\n      color,\n    } = this.props;\n\n    const innerStart = Vector.add(center, ellipsePointFromDirection(startDirection, innerRadius));\n    const innerMiddle = Vector.add(\n      center,\n      ellipsePointFromDirection(Vector.lerp(startDirection, endDirection, 0.5), innerRadius)\n    );\n    const innerEnd = Vector.add(center, ellipsePointFromDirection(endDirection, innerRadius));\n\n    const outerRadius = Vector.add(innerRadius, { x: headerHeight, y: headerHeight });\n    const outerStart = Vector.add(center, ellipsePointFromDirection(startDirection, outerRadius));\n    const outerEnd = Vector.add(center, ellipsePointFromDirection(endDirection, outerRadius));\n\n    const triggerOnHeader = (e: React.MouseEvent<EventTarget>) => {\n      const parent = e.currentTarget;\n      if (parent instanceof Element) {\n        const target = parent.querySelector(`.${styles.sectorPopoverTarget}`);\n        if (target) {\n          onTriggerPopover(target);\n        }\n      }\n    };\n\n    const labelPathId = `${shortId}-labelPath`;\n    return (\n      <g className={className} onMouseEnter={triggerOnHeader} onClick={triggerOnHeader}>\n        <defs>\n          <path\n            id={labelPathId}\n            d={`\n              M ${(innerStart.x + outerStart.x) / 2}\n                ${(innerStart.y + outerStart.y) / 2}\n\n              A ${(innerRadius.x + outerRadius.x) / 2}\n                ${(innerRadius.y + outerRadius.y) / 2}\n                0 0 1\n                ${(innerEnd.x + outerEnd.x) / 2}\n                ${(innerEnd.y + outerEnd.y) / 2}\n            `}\n          />\n        </defs>\n        <path\n          fill={color}\n          d={`\n            M ${outerStart.x} ${outerStart.y}\n            A ${outerRadius.x} ${outerRadius.y} 0 0 1 ${outerEnd.x} ${outerEnd.y}\n            L ${innerEnd.x} ${innerEnd.y}\n            A ${innerRadius.x} ${innerRadius.y} 0 0 0 ${innerStart.x} ${innerStart.y}\n            Z\n          `}\n        />\n        <circle className={styles.sectorPopoverTarget} cx={innerMiddle.x} cy={innerMiddle.y} r={1} />\n        <text fontSize={headerHeight * 0.75} textAnchor=\"middle\" style={style}>\n          <textPath xlinkHref={`#${labelPathId}`} dominantBaseline=\"central\" startOffset=\"50%\">\n            {label}\n          </textPath>\n        </text>\n      </g>\n    );\n  }\n}\n\nclass Background extends Component<\n  {\n    layout: PlotLayout;\n    center: Vector;\n    outerRadius: Vector;\n  },\n  {}\n> {\n  render() {\n    const { layout, center, outerRadius } = this.props;\n    const ringSize = Vector.scale(outerRadius, 1 / layout.rings.length);\n    return (\n      <g className={styles.background}>\n        {layout.rings.map((ring, index) => {\n          const inner = Vector.scale(ringSize, index);\n          const outer = Vector.scale(ringSize, index + 1);\n          return this.renderRing(ring, center, inner, outer);\n        })}\n      </g>\n    );\n  }\n\n  renderRing(ring: RingDescription, center: Vector, innerRadius: Vector, outerRadius: Vector) {\n    return (\n      <path\n        key={ring.iri}\n        className={styles.ringArea}\n        style={{ fill: ring.color }}\n        d={`\n          M ${center.x - outerRadius.x} ${center.y}\n          A ${outerRadius.x} ${outerRadius.y} 0 0 1 ${center.x + outerRadius.x} ${center.y}\n          L ${center.x + innerRadius.x} ${center.y}\n          A ${innerRadius.x} ${innerRadius.y} 0 0 0 ${center.x - innerRadius.x} ${center.y}\n          Z\n        `}\n      />\n    );\n  }\n}\n\nclass Grid extends Component<\n  {\n    layout: PlotLayout;\n    labelStyle: CSSProperties;\n    showPopover: (type: TemplateType, iri: string, label: string, target: EventTarget) => void;\n    directionFromIndex: (index: number) => Vector;\n    center: Vector;\n    innerSubHeaderRadius: Vector;\n    ringLabelHeight: number;\n  },\n  {}\n> {\n  render() {\n    const {\n      layout,\n      labelStyle,\n      showPopover,\n      directionFromIndex,\n      center,\n      innerSubHeaderRadius,\n      ringLabelHeight,\n    } = this.props;\n    const { sectors, subsectorsBySector, sectorLayouts, rings } = layout;\n\n    const lineEndFromIndex = (index: number): Vector => {\n      const radius = ellipsePointFromDirection(directionFromIndex(index), innerSubHeaderRadius);\n      return Vector.add(center, radius);\n    };\n\n    const ringSize = Vector.scale(innerSubHeaderRadius, 1 / rings.length);\n\n    return (\n      <g className={styles.grid}>\n        {rings.map((ring, i) => {\n          const radius = Vector.scale(ringSize, i);\n          const onTriggerPopover = (e: React.MouseEvent<EventTarget>) => {\n            showPopover('ring', ring.iri, ring.label, e.currentTarget);\n          };\n          return (\n            <g key={ring.iri}>\n              {i === 0 ? null : (\n                <path\n                  className={styles.ringLine}\n                  d={`\n                    M ${center.x - radius.x} ${center.y}\n                    A ${radius.x} ${radius.y} 0 0 1 ${center.x + radius.x} ${center.y}\n                  `}\n                />\n              )}\n              <text\n                className={styles.ringLabel}\n                x={center.x - radius.x - ringSize.x / 2}\n                y={center.y + ringLabelHeight / 2}\n                style={labelStyle}\n                textAnchor=\"middle\"\n                alignmentBaseline=\"central\"\n                fontSize={ringLabelHeight * 0.3}\n                onMouseEnter={onTriggerPopover}\n                onClick={onTriggerPopover}\n              >\n                {ring.label}\n              </text>\n            </g>\n          );\n        })}\n        {sectors.map((sector, i) => {\n          const sectorEnd = lineEndFromIndex(sectorLayouts[sector.iri].startIndex);\n          const subsectors = subsectorsBySector[sector.iri];\n          return (\n            <g key={sector.iri}>\n              {i === 0 ? null : (\n                <line className={styles.sectorLine} x1={center.x} y1={center.y} x2={sectorEnd.x} y2={sectorEnd.y} />\n              )}\n              {subsectors.map((subsector, j) => {\n                if (j === 0) {\n                  return null;\n                }\n                const subsectorEnd = lineEndFromIndex(sectorLayouts[subsector.iri].startIndex);\n                return (\n                  <line\n                    className={styles.subsectorLine}\n                    key={subsector.iri}\n                    x1={center.x}\n                    y1={center.y}\n                    x2={subsectorEnd.x}\n                    y2={subsectorEnd.y}\n                  />\n                );\n              })}\n            </g>\n          );\n        })}\n        <line\n          className={styles.sectorLine}\n          x1={center.x - innerSubHeaderRadius.x}\n          y1={center.y}\n          x2={center.x + innerSubHeaderRadius.x}\n          y2={center.y}\n        />\n      </g>\n    );\n  }\n}\n\nclass Clusters extends Component<\n  {\n    layout: PlotLayout;\n    showPopover: (type: TemplateType, iri: string, label: string, target: EventTarget) => void;\n    getItemPosition: (item: ItemDescription) => Vector;\n    itemRadius: number;\n  },\n  {}\n> {\n  render() {\n    const { layout, showPopover, getItemPosition, itemRadius } = this.props;\n    const { clusters, clusterColors, items } = layout;\n    return (\n      <g className={styles.clusters}>\n        {clusters.map((cluster) => {\n          const points = items.filter((item) => item.cluster === cluster.iri).map(getItemPosition);\n\n          if (points.length < 2) {\n            return null;\n          }\n          const convexHull = convexHullOf(points);\n          const marginRadius = itemRadius * 1.3;\n\n          const orthogonalClockwise = (v: Vector) => ({ x: -v.y, y: v.x });\n\n          const pathGeometry =\n            'M ' +\n            convexHull\n              .map((p, i) => {\n                const previousIndex = i === 0 ? convexHull.length - 1 : i - 1;\n                const nextIndex = (i + 1) % convexHull.length;\n\n                const previous = convexHull[previousIndex];\n                const next = convexHull[nextIndex];\n\n                const previousOrthogonal = Vector.scale(\n                  orthogonalClockwise(Vector.normalize(Vector.subtract(p, previous))),\n                  marginRadius\n                );\n                const nextOrthogonal = Vector.scale(\n                  orthogonalClockwise(Vector.normalize(Vector.subtract(next, p))),\n                  marginRadius\n                );\n\n                const previousPivot = Vector.add(p, previousOrthogonal);\n                const nextPivot = Vector.add(p, nextOrthogonal);\n\n                const midPrevious = Vector.add(Vector.lerp(p, previous, 1 / 3), previousOrthogonal);\n                const midNext = Vector.add(Vector.lerp(p, next, 1 / 3), nextOrthogonal);\n\n                return (\n                  `${midPrevious.x} ${midPrevious.y}` +\n                  ` L ${previousPivot.x} ${previousPivot.y}` +\n                  ` A ${marginRadius} ${marginRadius} 0 0 0 ${nextPivot.x} ${nextPivot.y}` +\n                  ` L ${midNext.x} ${midNext.y}`\n                );\n              })\n              .join(' L ') +\n            ' Z';\n\n          const color = clusterColors[cluster.iri];\n          return <path key={cluster.iri} className={styles.cluster} d={pathGeometry} fill={color} stroke={color} />;\n        })}\n      </g>\n    );\n  }\n}\n\nclass Items extends Component<\n  {\n    layout: PlotLayout;\n    labelStyle: CSSProperties;\n    showPopover: (type: TemplateType, iri: string, label: string, target: EventTarget) => void;\n    directionFromIndex: (index: number) => Vector;\n    getItemPosition: (item: ItemDescription) => Vector;\n    itemRadius: number;\n  },\n  {}\n> {\n  render() {\n    const { layout, labelStyle, showPopover, directionFromIndex, getItemPosition, itemRadius } = this.props;\n    const { orderedSubsectors, itemsBySubsector, normalizedPositions, sectorColors } = layout;\n    return (\n      <g className={styles.items}>\n        {orderedSubsectors.map((subsector, i) => {\n          const items = itemsBySubsector[subsector.iri] || [];\n          if (items.length === 0) {\n            return null;\n          }\n          return (\n            <g key={subsector.iri}>\n              {items.map((item) => {\n                const position = getItemPosition(item);\n                const cluster = item.cluster ? layout.clustersByIri[item.cluster] : undefined;\n                const color = item.color\n                  ? item.color\n                  : cluster && cluster.color\n                  ? cluster.color\n                  : sectorColors[subsector.iri];\n                const onTriggerPopover = (e: React.MouseEvent<EventTarget>) => {\n                  showPopover('point', item.iri, item.label, e.currentTarget);\n                };\n                return renderItem(item, position, itemRadius, color, labelStyle, onTriggerPopover);\n              })}\n            </g>\n          );\n        })}\n      </g>\n    );\n  }\n}\n\nfunction renderItem(\n  item: ItemDescription,\n  position: Vector,\n  radius: number,\n  color: string,\n  style: CSSProperties,\n  onTriggerPopover: (e: React.MouseEvent<EventTarget>) => void\n) {\n  const { x, y } = position;\n  return (\n    <g className={styles.item} key={item.iri} onMouseEnter={onTriggerPopover} onClick={onTriggerPopover}>\n      <circle cx={x} cy={y} r={radius} fill={color} />\n      <text x={x} y={y} style={style} textAnchor=\"middle\" dominantBaseline=\"central\" fontSize={radius / 2}>\n        {item.label}\n      </text>\n    </g>\n  );\n}\n\nfunction computeItemPosition(\n  item: ItemDescription,\n  layout: PlotLayout,\n  directionFromIndex: (index: number) => Vector,\n  center: Vector,\n  outerAreaRadius: Vector,\n  cellPadding: number\n) {\n  const subsectorIndex = layout.sectorLayouts[item.subsector].startIndex;\n  const ringIndex = layout.ringIndices[item.ring];\n  const { x, y } = layout.normalizedPositions[item.iri];\n\n  const distance = (ringIndex + y) / layout.rings.length;\n\n  const radius = Vector.scale(outerAreaRadius, distance);\n  const halfPerimeter = approximateEllipsePerimeter(radius.x, radius.y) / 2;\n  const sectorLength = halfPerimeter / layout.orderedSubsectors.length;\n  const xPadding = Math.min(1, cellPadding / sectorLength);\n\n  const paddedX = Scalar.lerp(xPadding, 1 - xPadding, x);\n  const direction = directionFromIndex(subsectorIndex + paddedX);\n\n  const outerPointer = ellipsePointFromDirection(direction, outerAreaRadius);\n  const totalHeight = Vector.length(outerPointer);\n  const ringHeight = totalHeight / layout.rings.length;\n  const yPadding = Math.min(cellPadding, ringHeight / 2);\n  const pointer = Vector.scale(\n    Vector.normalize(outerPointer),\n    ringIndex * ringHeight + Scalar.lerp(cellPadding, ringHeight - cellPadding, y)\n  );\n\n  const position = Vector.add(center, pointer);\n  return position;\n}\n\nexport default RadarPlot;\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { minBy, maxBy, orderBy } from 'lodash';\n\nexport interface Vector {\n  x: number;\n  y: number;\n}\nexport namespace Vector {\n  export function add(a: Vector, b: Vector) {\n    return { x: a.x + b.x, y: a.y + b.y };\n  }\n  export function subtract(a: Vector, b: Vector) {\n    return { x: a.x - b.x, y: a.y - b.y };\n  }\n  export function scale(v: Vector, s: number) {\n    return { x: v.x * s, y: v.y * s };\n  }\n  export function lerp(a: Vector, b: Vector, s: number) {\n    const m = 1 - s;\n    return {\n      x: m * a.x + s * b.x,\n      y: m * a.y + s * b.y,\n    };\n  }\n  export function length(v: Vector) {\n    return Math.sqrt(v.x * v.x + v.y * v.y);\n  }\n  export function normalize(v: Vector) {\n    const inverseLength = 1 / length(v);\n    return { x: v.x * inverseLength, y: v.y * inverseLength };\n  }\n  export function cross(a: Vector, b: Vector): number {\n    return a.x * b.y - a.y * b.x;\n  }\n  export function fromAngle(angle: number) {\n    return { x: Math.cos(angle), y: Math.sin(angle) };\n  }\n}\n\nexport namespace Scalar {\n  export function lerp(a: number, b: number, s: number) {\n    return a * (1 - s) + b * s;\n  }\n}\n\nexport function ellipsePointFromDirection(direction: Vector, radius: Vector): Vector {\n  const { x: nx, y: ny } = direction;\n  const { x: rx, y: ry } = radius;\n  const sx = nx / rx;\n  const sy = ny / ry;\n  const scale = Math.sqrt(1 / (sx * sx + sy * sy));\n  return { x: nx * scale, y: ny * scale };\n}\n\n/**\n * A strictly monotonic function [0..1] -> [0..1] mapping plot angles to divide\n * ellipse area into arcs of roughly the same size.\n *\n * This is basically an approximation to an inverse of EllipticE[e, phi]\n * (elliptic integral of the second kind).\n */\nexport function approximateUniformEllipticAngle(k: number, rx: number, ry: number) {\n  if (rx < ry) {\n    return k < 0.5\n      ? approximateUniformEllipticAngle(k + 0.5, ry, rx) - 0.5\n      : approximateUniformEllipticAngle(k - 0.5, ry, rx) + 0.5;\n  }\n  // assert: rx >= ry && k in [0..1]\n  const inner = (k - 0.5) * 2;\n  const exp = Math.sign(inner) * Math.pow(Math.abs(inner), ry / rx);\n  return (1 + exp) * 0.5;\n}\n\n/**\n * Approximates perimeter S[rx, ry] of an ellipse with semi-axes rx, ry\n * using naive approximation (arithmetic mean of the two semi-axes).\n *\n * @see http://www.ebyte.it/library/docs/math05a/EllipsePerimeterApprox05.html\n */\nexport function approximateEllipsePerimeter(rx: number, ry: number) {\n  return Math.PI * (rx + ry);\n}\n\n/**\n * Computes convex null of points using Graham's scan.\n */\nexport function convexHullOf(points: ReadonlyArray<Vector>): Vector[] {\n  const maxY = maxBy(points, (p) => p.y).y;\n  // left-most point from highest by Y\n  const pivot = minBy(\n    points.filter((p) => p.y === maxY),\n    (p) => p.x\n  );\n  const angleFromPivot = (target: Vector) => {\n    const direction = Vector.subtract(target, pivot);\n    return Math.atan2(-direction.y, direction.x);\n  };\n  const orderedPoints = orderBy(points, angleFromPivot);\n  orderedPoints.splice(orderedPoints.indexOf(pivot), 1);\n\n  const stack: Vector[] = [pivot, orderedPoints.shift()];\n  for (const p of orderedPoints) {\n    let isRightTurn: boolean;\n    do {\n      const top = stack[stack.length - 1];\n      const nextToTop = stack[stack.length - 2];\n      const topSegment = Vector.subtract(top, nextToTop);\n      const suggestedSegement = Vector.subtract(p, nextToTop);\n      isRightTurn = Vector.cross(topSegment, suggestedSegement) > 0;\n      if (isRightTurn) {\n        stack.pop();\n      }\n    } while (isRightTurn);\n    stack.push(p);\n  }\n\n  return stack;\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { groupBy, keyBy, flatten, orderBy } from 'lodash';\nimport { hcl, HCLColor } from 'd3-color';\n\nimport {\n  RadarPlotProps,\n  SectorDescription,\n  SubSectorDescription,\n  ItemDescription,\n  RingDescription,\n  ClusterDescription,\n} from './Config';\nimport { Vector } from './Geometry';\n\nexport interface PlotLayout {\n  readonly sectors: ReadonlyArray<SectorDescription>;\n  readonly orderedSubsectors: ReadonlyArray<SubSectorDescription>;\n  readonly subsectorsBySector: {\n    readonly [sector: string]: ReadonlyArray<SubSectorDescription>;\n  };\n  readonly items: ReadonlyArray<ItemDescription>;\n  readonly itemsBySubsector: {\n    readonly [subsector: string]: ReadonlyArray<ItemDescription>;\n  };\n  readonly sectorLayouts: SectorLayouts;\n  readonly sectorColors: { readonly [sector: string]: string };\n  readonly rings: ReadonlyArray<RingDescription>;\n  readonly ringIndices: { readonly [ring: string]: number };\n  readonly clusters: ReadonlyArray<ClusterDescription>;\n  readonly clustersByIri: {\n    readonly [cluser: string]: ClusterDescription;\n  };\n  readonly clusterColors: { readonly [cluster: string]: string };\n  /**\n   * item -> {x, y} where\n   *   x in [0..1] is angle on sector axis within subsector\n   *   y in [0..1] on ring axis\n   */\n  readonly normalizedPositions: { readonly [item: string]: Vector };\n}\n\nexport interface SectorLayouts {\n  readonly [sectorOrSubsector: string]: SectorLayout;\n}\n\nexport interface SectorLayout {\n  parentSector: string | number;\n  startIndex: number;\n  endIndex: number;\n}\n\nexport function computeLayout(props: RadarPlotProps): PlotLayout {\n  const { sectors, subsectors, rings, clusters, items } = props;\n  const subsectorsBySector = groupBy(subsectors, (sub) => sub.sector);\n\n  const orderedSubsectors = flatten(sectors.map((sector) => subsectorsBySector[sector.iri]));\n  const itemsBySubsector = groupBy(items, (item) => item.subsector);\n\n  const sectorLayouts: { [sector: string]: SectorLayout } = {};\n  let nextSubsectorIndex = 0;\n  for (const sector of sectors) {\n    const startIndex = nextSubsectorIndex;\n    const subsectors = subsectorsBySector[sector.iri];\n    for (const subsector of subsectorsBySector[sector.iri]) {\n      sectorLayouts[subsector.iri] = {\n        parentSector: sector.iri,\n        startIndex: nextSubsectorIndex,\n        endIndex: nextSubsectorIndex + 1,\n      };\n      nextSubsectorIndex++;\n    }\n    if (subsectors.length === 0) {\n      nextSubsectorIndex++;\n    }\n    sectorLayouts[sector.iri] = {\n      parentSector: undefined,\n      startIndex,\n      endIndex: nextSubsectorIndex,\n    };\n  }\n\n  const sectorColors: { [sector: string]: string } = {};\n  sectors.forEach((sector, i) => {\n    const parentColor = sector.color ? hcl(sector.color) : defaultSectorColor(i, sectors.length);\n    sectorColors[sector.iri] = parentColor.toString();\n\n    const subsectors = subsectorsBySector[sector.iri] || [];\n    subsectors.forEach((subsector, j) => {\n      const subColor = subsector.color\n        ? subsector.color\n        : defaultSubsectorColor(parentColor, j, subsectors.length).toString();\n      sectorColors[subsector.iri] = subColor;\n    });\n  });\n\n  const ringIndices: { [ring: string]: number } = {};\n  rings.forEach((ring, ringIndex) => (ringIndices[ring.iri] = ringIndex));\n\n  const clusterColors: { [cluster: string]: string } = {};\n  clusters.forEach((cluster, clusterIndex) => {\n    clusterColors[cluster.iri] = cluster.color || defaultClusterColor(clusterIndex, clusters.length).toString();\n  });\n\n  for (const item of items) {\n    const sectorLayout = sectorLayouts[item.subsector];\n    if (!sectorLayout || !sectorLayout.parentSector) {\n      throw new Error(`Unknown subsector <${item.subsector}> for item <${item.iri}>`);\n    }\n    if (!(item.ring in ringIndices)) {\n      throw new Error(`Unknown ring <${item.ring}> for item <${item.iri}>`);\n    }\n  }\n\n  return {\n    sectors,\n    orderedSubsectors,\n    subsectorsBySector,\n    items,\n    itemsBySubsector,\n    sectorLayouts,\n    sectorColors,\n    rings,\n    ringIndices,\n    clusters,\n    clustersByIri: keyBy(clusters, (cluster) => cluster.iri),\n    clusterColors,\n    normalizedPositions: computeItemsLayout(orderedSubsectors, itemsBySubsector, rings),\n  };\n}\n\nfunction defaultSectorColor(sectorIndex: number, sectorCount: number) {\n  // constant offset for tweaking default palette\n  const offset = 0.2;\n  const range = 1;\n  const hue = (offset + (range * (sectorIndex + 0.5)) / sectorCount) % 1;\n  return hcl(360 * hue, 40, 65);\n}\n\nfunction defaultSubsectorColor(parentColor: HCLColor, childIndex: number, childCount: number) {\n  const { h, c, l } = parentColor;\n  const intensity = 1 - (childIndex + 1) / childCount;\n  return hcl(h, c, l * (1 + 0.5 * intensity));\n}\n\nfunction defaultClusterColor(clusterIndex: number, clusterCount: number) {\n  const offset = 0.4;\n  const range = 1;\n  const hue = (offset + (range * (clusterIndex + 0.5)) / clusterCount) % 1;\n  return hcl(360 * hue, 20, 65);\n}\n\nfunction computeItemsLayout(\n  orderedSubsectors: ReadonlyArray<SubSectorDescription>,\n  itemsBySubsector: { [subsector: string]: ItemDescription[] },\n  rings: ReadonlyArray<RingDescription>\n) {\n  const layout: { [item: string]: Vector } = {};\n\n  const random = new LcgRandom(0);\n  for (const subsector of orderedSubsectors) {\n    const sectorItems = itemsBySubsector[subsector.iri] || [];\n    rings.forEach((ring, ringIndex) => {\n      const cellItems = sectorItems.filter((item) => item.ring === ring.iri);\n      const { minDistance, maxDistance } = computeItemsRange(cellItems);\n      const orderedItems = orderBy(cellItems, (item) => item.distance);\n      random.shuffle(orderedItems).forEach((item, index) => {\n        layout[item.iri] = {\n          x: cellItems.length <= 1 ? 0.5 : index / (cellItems.length - 1),\n          y: (item.distance - minDistance) / (maxDistance - minDistance),\n        };\n      });\n    });\n  }\n\n  return layout;\n}\n\nclass LcgRandom {\n  private a = 1664525;\n  private c = 1013904223;\n  readonly range = Math.pow(2, 32);\n  constructor(private seed: number) {}\n  /** Range: [0..2^32) */\n  nextInteger(excludedMax: number) {\n    // seed in [0..range)\n    this.seed = (this.seed * this.a + this.c) % this.range;\n    // normalized in [0..1)\n    const normalized = this.seed / this.range;\n    // result in [0..excludedMax)\n    return Math.floor(normalized * excludedMax);\n  }\n  shuffle<T>(items: ReadonlyArray<T>): T[] {\n    const result: T[] = [...items];\n    for (let i = 0; i < items.length; i++) {\n      const left = items.length - i;\n      const chosen = i + this.nextInteger(left);\n      const [item] = result.splice(chosen, 1);\n      result.splice(i, 0, item);\n    }\n    return result;\n  }\n}\n\nfunction computeItemsRange(items: ReadonlyArray<ItemDescription>): { minDistance: number; maxDistance: number } {\n  let minDistance = Infinity;\n  let maxDistance = -Infinity;\n  for (const item of items) {\n    minDistance = Math.min(minDistance, item.distance);\n    maxDistance = Math.max(maxDistance, item.distance);\n  }\n  if (minDistance === maxDistance) {\n    // account for case when visualizing a single item\n    minDistance -= 1;\n    maxDistance += 1;\n  }\n  return { minDistance, maxDistance };\n}\n"],"sourceRoot":""}