{"version":3,"sources":["webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/LayoutConstants.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/PointD.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/FDLayoutConstants.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/HashSet.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/IGeometry.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/IMath.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/Integer.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/LGraphObject.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/LGraph.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/LGraphManager.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/LNode.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/UniqueIDGeneretor.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/Point.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/RectangleD.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/Transform.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/LEdge.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/Layout.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/index.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/HashMap.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/RandomSeed.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/FDLayout.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/FDLayoutEdge.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/FDLayoutNode.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/CoSEConstants.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/CoSEEdge.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/CoSEGraph.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/CoSEGraphManager.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/CoSENode.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/index.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/DimensionD.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/Emitter.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/CoSELayout.js","webpack:///./node_modules/cytoscape-cose-bilkent/src/Layout/TilingExtension.js"],"names":["LayoutConstants","PROOF_QUALITY","DEFAULT_QUALITY","DRAFT_QUALITY","DEFAULT_CREATE_BENDS_AS_NEEDED","DEFAULT_INCREMENTAL","DEFAULT_ANIMATION_ON_LAYOUT","DEFAULT_ANIMATION_DURING_LAYOUT","DEFAULT_ANIMATION_PERIOD","DEFAULT_UNIFORM_LEAF_NODE_SIZES","DEFAULT_GRAPH_MARGIN","SIMPLE_NODE_SIZE","SIMPLE_NODE_HALF_SIZE","EMPTY_COMPOUND_NODE_SIZE","MIN_EDGE_LENGTH","WORLD_BOUNDARY","INITIAL_WORLD_BOUNDARY","WORLD_CENTER_X","WORLD_CENTER_Y","module","exports","PointD","x","y","this","prototype","getX","getY","setX","setY","getDifference","pt","DimensionD","getCopy","translate","dim","width","height","FDLayoutConstants","prop","MAX_ITERATIONS","DEFAULT_EDGE_LENGTH","DEFAULT_SPRING_STRENGTH","DEFAULT_REPULSION_STRENGTH","DEFAULT_GRAVITY_STRENGTH","DEFAULT_COMPOUND_GRAVITY_STRENGTH","DEFAULT_GRAVITY_RANGE_FACTOR","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION","DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION","MAX_NODE_DISPLACEMENT_INCREMENTAL","MAX_NODE_DISPLACEMENT","MIN_REPULSION_DIST","CONVERGENCE_CHECK_PERIOD","PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR","GRID_CALCULATION_CHECK_PERIOD","UniqueIDGeneretor","HashSet","set","add","obj","theId","createID","contains","remove","clear","isEmpty","size","Object","keys","length","addAllTo","list","i","push","addAll","s","v","IGeometry","calcSeparationAmount","rectA","rectB","overlapAmount","separationBuffer","intersects","directions","Array","decideDirectionsForOverlappingNodes","Math","min","getRight","max","getBottom","slope","abs","getCenterY","getCenterX","moveByY","moveByX","getIntersection2","result","p1x","p1y","p2x","p2y","topLeftAx","topLeftAy","topRightAx","bottomLeftAx","bottomLeftAy","bottomRightAx","halfWidthA","getWidthHalf","halfHeightA","getHeightHalf","topLeftBx","topLeftBy","topRightBx","bottomLeftBx","bottomLeftBy","bottomRightBx","halfWidthB","halfHeightB","clipPointAFound","clipPointBFound","cardinalDirectionA","cardinalDirectionB","tempPointAx","tempPointAy","tempPointBx","tempPointBy","slopeA","slopeB","slopePrime","getCardinalDirection","line","getIntersection","s1","s2","f1","f2","a1","a2","b1","b2","c1","c2","denom","x1","y1","x2","y2","x3","y3","x4","y4","Point","HALF_PI","PI","ONE_AND_HALF_PI","TWO_PI","THREE_PI","IMath","sign","value","floor","ceil","Integer","MAX_VALUE","MIN_VALUE","LGraphObject","vGraphObject","LGraphManager","LNode","RectangleD","LGraph","parent","obj2","vGraph","call","estimatedSize","margin","edges","nodes","isConnected","graphManager","Layout","create","getNodes","getEdges","getGraphManager","getParent","getLeft","left","right","getTop","top","bottom","obj1","sourceNode","targetNode","newNode","indexOf","owner","newEdge","source","target","isInterGraph","node","edgesToBeRemoved","slice","edge","index","splice","LEdge","sourceIndex","targetIndex","updateLeftTop","nodeTop","nodeLeft","lNode","updateBounds","recursive","nodeRight","nodeBottom","child","boundingRect","calculateBounds","getInclusionTreeDepth","getRoot","getEstimatedSize","calcEstimatedSize","sqrt","updateConnected","neighborEdges","currentNeighbor","toBeVisited","visited","currentNode","concat","withChildren","shift","getOtherEndInGraph","noOfVisitedInThisGraph","visitedId","layout","graphs","addRoot","ngraph","newGraph","nnode","root","setRootGraph","rootGraph","parentNode","sourceGraph","getOwner","targetGraph","lObj","graph","nodesToBeRemoved","getGraphs","getAllNodes","allNodes","nodeList","resetAllNodes","resetAllEdges","allEdges","resetAllNodesToApplyGravitation","allNodesToApplyGravitation","getAllEdges","edgeList","getAllNodesToApplyGravitation","setAllNodesToApplyGravitation","getLayout","isOneAncestorOfOther","firstNode","secondNode","ownerGraph","calcLowestCommonAncestors","sourceAncestorGraph","targetAncestorGraph","lca","sourceInLca","targetInLca","calcLowestCommonAncestor","firstOwnerGraph","secondOwnerGraph","calcInclusionTreeDepths","depth","inclusionTreeDepth","includesInvalidEdge","RandomSeed","gm","loc","vNode","rect","getChild","getWidth","setWidth","getHeight","setHeight","getCenter","getLocation","getRect","getDiagonal","setRect","upperLeft","dimension","setCenter","cx","cy","setLocation","moveBy","dx","dy","getEdgeListToNode","to","getEdgesBetween","other","getNeighborsList","neighbors","childNode","withNeighborsList","scatter","randomCenterX","randomCenterY","minX","maxX","nextDouble","minY","maxY","childGraph","transform","trans","leftTop","vLeftTop","inverseTransformPoint","lastID","isPrimitive","uniqueID","getString","id","arg","type","p","constructor","name","parseInt","move","equals","toString","a","getMinX","getMaxX","getMinY","getMaxY","Transform","lworldOrgX","lworldOrgY","ldeviceOrgX","ldeviceOrgY","lworldExtX","lworldExtY","ldeviceExtX","ldeviceExtY","getWorldOrgX","setWorldOrgX","wox","getWorldOrgY","setWorldOrgY","woy","getWorldExtX","setWorldExtX","wex","getWorldExtY","setWorldExtY","wey","getDeviceOrgX","setDeviceOrgX","dox","getDeviceOrgY","setDeviceOrgY","doy","getDeviceExtX","setDeviceExtX","dex","getDeviceExtY","setDeviceExtY","dey","transformX","xDevice","worldExtX","transformY","yDevice","worldExtY","inverseTransformX","xWorld","deviceExtX","inverseTransformY","yWorld","deviceExtY","inPoint","vEdge","isOverlapingSourceAndTarget","bendpoints","getSource","getTarget","getLength","getBendpoints","getLca","getSourceInLca","getTargetInLca","getOtherEnd","otherEnd","updateLength","clipPointCoordinates","lengthX","lengthY","updateLengthSimple","HashMap","Emitter","isRemoteUse","layoutQuality","createBendsAsNeeded","incremental","animationOnLayout","animationDuringLayout","animationPeriod","uniformLeafNodeSizes","edgeToDummyNodes","isLayoutFinished","isSubLayout","RANDOM_SEED","newGraphManager","runLayout","isLayoutSuccessfull","initParameters","startTime","Date","getTime","doPostLayout","update","update2","createBendpointsFromDummyNodes","newLeftTop","undefined","positionNodesRandomly","getFlatForest","flatForest","isForest","isFlat","parents","unProcessedNodes","get","put","temp","createDummyNodesForBendpoints","dummyNodes","prev","dummyNode","Dimension","dummyEdge","keySet","k","lEdge","path","ebp","sliderValue","defaultValue","minDiv","maxMul","b","findCenterOfTree","removedNodes","remainingDegrees","foundCenter","centerNode","degree","tempList","tempList2","neighbours","j","neighbour","newDegree","setGraphManager","register","cytoscape","map","key","seed","sin","FDLayout","useSmartIdealEdgeLengthCalculation","idealEdgeLength","springConstant","repulsionConstant","gravityConstant","compoundGravityConstant","gravityRangeFactor","compoundGravityRangeFactor","displacementThresholdPerNode","coolingFactor","initialCoolingFactor","totalDisplacement","oldTotalDisplacement","maxIterations","arguments","totalIterations","notAnimatedIterations","calcIdealEdgeLengths","lcaDepth","sizeOfSourceInLca","sizeOfTargetInLca","idealLength","initSpringEmbedder","maxNodeDisplacement","totalDisplacementThreshold","repulsionRange","calcRepulsionRange","calcSpringForces","lEdges","calcSpringForce","calcRepulsionForces","nodeA","nodeB","lNodes","calcRepulsionForce","calcGravitationalForces","calcGravitationalForce","moveNodes","springForce","springForceX","springForceY","distanceX","distanceY","distanceSquared","distance","repulsionForce","repulsionForceX","repulsionForceY","clipPoints","ownerCenterX","ownerCenterY","absDistanceX","absDistanceY","gravitationForceX","gravitationForceY","isConverged","converged","oscilating","animate","FDLayoutEdge","FDLayoutNode","displacementX","displacementY","startX","finishX","startY","finishY","surrounding","setGridCoordinates","_startX","_finishX","_startY","_finishY","CoSEConstants","DEFAULT_USE_MULTI_LEVEL_SCALING","DEFAULT_RADIAL_SEPARATION","DEFAULT_COMPONENT_SEPERATION","CoSEEdge","CoSEGraph","graphMgr","CoSEGraphManager","CoSENode","propogateDisplacementToChildren","dX","dY","setPred1","pred1","getPred1","getPred2","pred2","setNext","next","getNext","setProcessed","processed","isProcessed","CoSELayout","TilingExtension","defaults","ready","stop","refresh","fit","padding","paddingCompound","randomize","nodeRepulsion","edgeElasticity","nestingFactor","gravity","numIter","tile","animationDuration","tilingPaddingVertical","tilingPaddingHorizontal","gravityRangeCompound","gravityCompound","gravityRange","_CoSELayout","_options","options","extend","getUserOptions","ANIMATE","run","frameId","idToLNode","self","trigger","eles","preLayout","processChildrenList","getTopMostNodes","data","getPositions","ele","iterateAnimated","isDone","afterReposition","one","ticksPerFrame","tick","postLayout","positions","cancelAnimationFrame","removeScratch","animationData","getPositionsData","scratch","dummy_parent_id","dummyParent","pNode","requestAnimationFrame","addListener","setTimeout","not","layoutPositions","nodesMap","filter","children","theChild","theNode","theNewGraph","children_of_children","position","parseFloat","isNaN","stopped","listeners","event","callback","removeListener","l","emit","createBendpoints","level","classicLayout","calculateNodesToApplyGravitationTo","forest","positionNodesRadially","runSpringEmbedder","initialAnimationPeriod","pData","w","h","layoutEnded","multiEdge","currentStartingPoint","numberOfColumns","currentY","currentX","point","tree","radialLayout","startingPoint","radialSep","maxDiagonalInTree","branchRadialLayout","bounds","bottomRight","parentOfNode","startAngle","endAngle","radialSeparation","halfInterval","teta","x_","cos","y_","childCount","startIndex","branchCount","incEdgesCount","stepAngle","childStartAngle","childEndAngle","maxDiagonal","diagonal","instance","toBeTiled","getToBeTiled","getNodeDegree","getNodeDegreeWithChildren","groupZeroDegreeMembers","tempMemberGroups","memberGroups","parentMap","zeroDegree","pid","p_id","dummyCompoundId","getElementById","empty","group","dummy","union","hide","tempchildren","scratchObj","tempchild","css","performDFSOnCompounds","compoundOrder","roots","fillCompexOrderByDFS","clearCompounds","childGraphMap","lCompoundNode","tileCompoundMembers","clearZeroDegreeMembers","tiledZeroDegreePack","compoundNode","tileNodes","repopulateCompounds","tiledMemberPack","horizontalMargin","verticalMargin","adjustLocations","repopulateZeroDegreeMembers","tiledPack","compound","organization","compoundHorizontalMargin","compoundVerticalMargin","rows","row","maxHeight","lnode","horizontalPadding","verticalPadding","rowWidth","rowHeight","layoutNodes","sort","n1","n2","cyNode","minWidth","insertNodeToRow","canAddHorizontal","getShortestRowIndex","shiftToLastRow","rowIndex","minCompoundSize","extraHeight","r","Number","getLongestRowIndex","extraWidth","sri","add_to_row_ratio","add_new_row_ratio","hDiff","longest","last","diff","prevTotal","finalTotal","tiledZeroDegreeNodes","updateCompoundBounds"],"mappings":"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","file":"npm.cytoscape-cose-bilkent-3f443f16e67a7307d3cc.js","sourcesContent":["function LayoutConstants() {\n}\n\n/**\n * Layout Quality\n */\nLayoutConstants.PROOF_QUALITY = 0;\nLayoutConstants.DEFAULT_QUALITY = 1;\nLayoutConstants.DRAFT_QUALITY = 2;\n\n/**\n * Default parameters\n */\nLayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\n//LayoutConstants.DEFAULT_INCREMENTAL = true;\nLayoutConstants.DEFAULT_INCREMENTAL = false;\nLayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\nLayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\nLayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\nLayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n\n// -----------------------------------------------------------------------------\n// Section: General other constants\n// -----------------------------------------------------------------------------\n/*\n * Margins of a graph to be applied on bouding rectangle of its contents. We\n * assume margins on all four sides to be uniform.\n */\nLayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n\n/*\n * Default dimension of a non-compound node.\n */\nLayoutConstants.SIMPLE_NODE_SIZE = 40;\n\n/*\n * Default dimension of a non-compound node.\n */\nLayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n\n/*\n * Empty compound node size. When a compound node is empty, its both\n * dimensions should be of this value.\n */\nLayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n\n/*\n * Minimum length that an edge should take during layout\n */\nLayoutConstants.MIN_EDGE_LENGTH = 1;\n\n/*\n * World boundaries that layout operates on\n */\nLayoutConstants.WORLD_BOUNDARY = 1000000;\n\n/*\n * World boundaries that random positioning can be performed with\n */\nLayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n\n/*\n * Coordinates of the world center\n */\nLayoutConstants.WORLD_CENTER_X = 1200;\nLayoutConstants.WORLD_CENTER_Y = 900;\n\nmodule.exports = LayoutConstants;\n","function PointD(x, y) {\n  if (x == null && y == null) {\n    this.x = 0;\n    this.y = 0;\n  } else {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nPointD.prototype.getX = function ()\n{\n  return this.x;\n};\n\nPointD.prototype.getY = function ()\n{\n  return this.y;\n};\n\nPointD.prototype.setX = function (x)\n{\n  this.x = x;\n};\n\nPointD.prototype.setY = function (y)\n{\n  this.y = y;\n};\n\nPointD.prototype.getDifference = function (pt)\n{\n  return new DimensionD(this.x - pt.x, this.y - pt.y);\n};\n\nPointD.prototype.getCopy = function ()\n{\n  return new PointD(this.x, this.y);\n};\n\nPointD.prototype.translate = function (dim)\n{\n  this.x += dim.width;\n  this.y += dim.height;\n  return this;\n};\n\nmodule.exports = PointD;\n","var LayoutConstants = require('./LayoutConstants');\n\nfunction FDLayoutConstants() {\n}\n\n//FDLayoutConstants inherits static props in LayoutConstants\nfor (var prop in LayoutConstants) {\n  FDLayoutConstants[prop] = LayoutConstants[prop];\n}\n\nFDLayoutConstants.MAX_ITERATIONS = 2500;\n\nFDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\nFDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\nFDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\nFDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\nFDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\nFDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\nFDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\nFDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\nFDLayoutConstants.MIN_EDGE_LENGTH = 1;\nFDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n\nmodule.exports = FDLayoutConstants;\n","var UniqueIDGeneretor = require('./UniqueIDGeneretor');\n\nfunction HashSet() {\n  this.set = {};\n}\n;\n\nHashSet.prototype.add = function (obj) {\n  var theId = UniqueIDGeneretor.createID(obj);\n  if (!this.contains(theId))\n    this.set[theId] = obj;\n};\n\nHashSet.prototype.remove = function (obj) {\n  delete this.set[UniqueIDGeneretor.createID(obj)];\n};\n\nHashSet.prototype.clear = function () {\n  this.set = {};\n};\n\nHashSet.prototype.contains = function (obj) {\n  return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n};\n\nHashSet.prototype.isEmpty = function () {\n  return this.size() === 0;\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\n//concats this.set to the given list\nHashSet.prototype.addAllTo = function (list) {\n  var keys = Object.keys(this.set);\n  var length = keys.length;\n  for (var i = 0; i < length; i++) {\n    list.push(this.set[keys[i]]);\n  }\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\nHashSet.prototype.addAll = function (list) {\n  var s = list.length;\n  for (var i = 0; i < s; i++) {\n    var v = list[i];\n    this.add(v);\n  }\n};\n\nmodule.exports = HashSet;\n","function IGeometry() {\n}\n\nIGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer)\n{\n  if (!rectA.intersects(rectB)) {\n    throw \"assert failed\";\n  }\n  var directions = new Array(2);\n  IGeometry.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n  overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) -\n          Math.max(rectA.x, rectB.x);\n  overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) -\n          Math.max(rectA.y, rectB.y);\n  // update the overlapping amounts for the following cases:\n  if ((rectA.getX() <= rectB.getX()) && (rectA.getRight() >= rectB.getRight()))\n  {\n    overlapAmount[0] += Math.min((rectB.getX() - rectA.getX()),\n            (rectA.getRight() - rectB.getRight()));\n  }\n  else if ((rectB.getX() <= rectA.getX()) && (rectB.getRight() >= rectA.getRight()))\n  {\n    overlapAmount[0] += Math.min((rectA.getX() - rectB.getX()),\n            (rectB.getRight() - rectA.getRight()));\n  }\n  if ((rectA.getY() <= rectB.getY()) && (rectA.getBottom() >= rectB.getBottom()))\n  {\n    overlapAmount[1] += Math.min((rectB.getY() - rectA.getY()),\n            (rectA.getBottom() - rectB.getBottom()));\n  }\n  else if ((rectB.getY() <= rectA.getY()) && (rectB.getBottom() >= rectA.getBottom()))\n  {\n    overlapAmount[1] += Math.min((rectA.getY() - rectB.getY()),\n            (rectB.getBottom() - rectA.getBottom()));\n  }\n\n  // find slope of the line passes two centers\n  var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) /\n          (rectB.getCenterX() - rectA.getCenterX()));\n  // if centers are overlapped\n  if ((rectB.getCenterY() == rectA.getCenterY()) &&\n          (rectB.getCenterX() == rectA.getCenterX()))\n  {\n    // assume the slope is 1 (45 degree)\n    slope = 1.0;\n  }\n\n  var moveByY = slope * overlapAmount[0];\n  var moveByX = overlapAmount[1] / slope;\n  if (overlapAmount[0] < moveByX)\n  {\n    moveByX = overlapAmount[0];\n  }\n  else\n  {\n    moveByY = overlapAmount[1];\n  }\n  // return half the amount so that if each rectangle is moved by these\n  // amounts in opposite directions, overlap will be resolved\n  overlapAmount[0] = -1 * directions[0] * ((moveByX / 2) + separationBuffer);\n  overlapAmount[1] = -1 * directions[1] * ((moveByY / 2) + separationBuffer);\n}\n\nIGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions)\n{\n  if (rectA.getCenterX() < rectB.getCenterX())\n  {\n    directions[0] = -1;\n  }\n  else\n  {\n    directions[0] = 1;\n  }\n\n  if (rectA.getCenterY() < rectB.getCenterY())\n  {\n    directions[1] = -1;\n  }\n  else\n  {\n    directions[1] = 1;\n  }\n}\n\nIGeometry.getIntersection2 = function (rectA, rectB, result)\n{\n  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n  var p1x = rectA.getCenterX();\n  var p1y = rectA.getCenterY();\n  var p2x = rectB.getCenterX();\n  var p2y = rectB.getCenterY();\n\n  //if two rectangles intersect, then clipping points are centers\n  if (rectA.intersects(rectB))\n  {\n    result[0] = p1x;\n    result[1] = p1y;\n    result[2] = p2x;\n    result[3] = p2y;\n    return true;\n  }\n  //variables for rectA\n  var topLeftAx = rectA.getX();\n  var topLeftAy = rectA.getY();\n  var topRightAx = rectA.getRight();\n  var bottomLeftAx = rectA.getX();\n  var bottomLeftAy = rectA.getBottom();\n  var bottomRightAx = rectA.getRight();\n  var halfWidthA = rectA.getWidthHalf();\n  var halfHeightA = rectA.getHeightHalf();\n  //variables for rectB\n  var topLeftBx = rectB.getX();\n  var topLeftBy = rectB.getY();\n  var topRightBx = rectB.getRight();\n  var bottomLeftBx = rectB.getX();\n  var bottomLeftBy = rectB.getBottom();\n  var bottomRightBx = rectB.getRight();\n  var halfWidthB = rectB.getWidthHalf();\n  var halfHeightB = rectB.getHeightHalf();\n  //flag whether clipping points are found\n  var clipPointAFound = false;\n  var clipPointBFound = false;\n\n  // line is vertical\n  if (p1x == p2x)\n  {\n    if (p1y > p2y)\n    {\n      result[0] = p1x;\n      result[1] = topLeftAy;\n      result[2] = p2x;\n      result[3] = bottomLeftBy;\n      return false;\n    }\n    else if (p1y < p2y)\n    {\n      result[0] = p1x;\n      result[1] = bottomLeftAy;\n      result[2] = p2x;\n      result[3] = topLeftBy;\n      return false;\n    }\n    else\n    {\n      //not line, return null;\n    }\n  }\n  // line is horizontal\n  else if (p1y == p2y)\n  {\n    if (p1x > p2x)\n    {\n      result[0] = topLeftAx;\n      result[1] = p1y;\n      result[2] = topRightBx;\n      result[3] = p2y;\n      return false;\n    }\n    else if (p1x < p2x)\n    {\n      result[0] = topRightAx;\n      result[1] = p1y;\n      result[2] = topLeftBx;\n      result[3] = p2y;\n      return false;\n    }\n    else\n    {\n      //not valid line, return null;\n    }\n  }\n  else\n  {\n    //slopes of rectA's and rectB's diagonals\n    var slopeA = rectA.height / rectA.width;\n    var slopeB = rectB.height / rectB.width;\n\n    //slope of line between center of rectA and center of rectB\n    var slopePrime = (p2y - p1y) / (p2x - p1x);\n    var cardinalDirectionA;\n    var cardinalDirectionB;\n    var tempPointAx;\n    var tempPointAy;\n    var tempPointBx;\n    var tempPointBy;\n\n    //determine whether clipping point is the corner of nodeA\n    if ((-slopeA) == slopePrime)\n    {\n      if (p1x > p2x)\n      {\n        result[0] = bottomLeftAx;\n        result[1] = bottomLeftAy;\n        clipPointAFound = true;\n      }\n      else\n      {\n        result[0] = topRightAx;\n        result[1] = topLeftAy;\n        clipPointAFound = true;\n      }\n    }\n    else if (slopeA == slopePrime)\n    {\n      if (p1x > p2x)\n      {\n        result[0] = topLeftAx;\n        result[1] = topLeftAy;\n        clipPointAFound = true;\n      }\n      else\n      {\n        result[0] = bottomRightAx;\n        result[1] = bottomLeftAy;\n        clipPointAFound = true;\n      }\n    }\n\n    //determine whether clipping point is the corner of nodeB\n    if ((-slopeB) == slopePrime)\n    {\n      if (p2x > p1x)\n      {\n        result[2] = bottomLeftBx;\n        result[3] = bottomLeftBy;\n        clipPointBFound = true;\n      }\n      else\n      {\n        result[2] = topRightBx;\n        result[3] = topLeftBy;\n        clipPointBFound = true;\n      }\n    }\n    else if (slopeB == slopePrime)\n    {\n      if (p2x > p1x)\n      {\n        result[2] = topLeftBx;\n        result[3] = topLeftBy;\n        clipPointBFound = true;\n      }\n      else\n      {\n        result[2] = bottomRightBx;\n        result[3] = bottomLeftBy;\n        clipPointBFound = true;\n      }\n    }\n\n    //if both clipping points are corners\n    if (clipPointAFound && clipPointBFound)\n    {\n      return false;\n    }\n\n    //determine Cardinal Direction of rectangles\n    if (p1x > p2x)\n    {\n      if (p1y > p2y)\n      {\n        cardinalDirectionA = IGeometry.getCardinalDirection(slopeA, slopePrime, 4);\n        cardinalDirectionB = IGeometry.getCardinalDirection(slopeB, slopePrime, 2);\n      }\n      else\n      {\n        cardinalDirectionA = IGeometry.getCardinalDirection(-slopeA, slopePrime, 3);\n        cardinalDirectionB = IGeometry.getCardinalDirection(-slopeB, slopePrime, 1);\n      }\n    }\n    else\n    {\n      if (p1y > p2y)\n      {\n        cardinalDirectionA = IGeometry.getCardinalDirection(-slopeA, slopePrime, 1);\n        cardinalDirectionB = IGeometry.getCardinalDirection(-slopeB, slopePrime, 3);\n      }\n      else\n      {\n        cardinalDirectionA = IGeometry.getCardinalDirection(slopeA, slopePrime, 2);\n        cardinalDirectionB = IGeometry.getCardinalDirection(slopeB, slopePrime, 4);\n      }\n    }\n    //calculate clipping Point if it is not found before\n    if (!clipPointAFound)\n    {\n      switch (cardinalDirectionA)\n      {\n        case 1:\n          tempPointAy = topLeftAy;\n          tempPointAx = p1x + (-halfHeightA) / slopePrime;\n          result[0] = tempPointAx;\n          result[1] = tempPointAy;\n          break;\n        case 2:\n          tempPointAx = bottomRightAx;\n          tempPointAy = p1y + halfWidthA * slopePrime;\n          result[0] = tempPointAx;\n          result[1] = tempPointAy;\n          break;\n        case 3:\n          tempPointAy = bottomLeftAy;\n          tempPointAx = p1x + halfHeightA / slopePrime;\n          result[0] = tempPointAx;\n          result[1] = tempPointAy;\n          break;\n        case 4:\n          tempPointAx = bottomLeftAx;\n          tempPointAy = p1y + (-halfWidthA) * slopePrime;\n          result[0] = tempPointAx;\n          result[1] = tempPointAy;\n          break;\n      }\n    }\n    if (!clipPointBFound)\n    {\n      switch (cardinalDirectionB)\n      {\n        case 1:\n          tempPointBy = topLeftBy;\n          tempPointBx = p2x + (-halfHeightB) / slopePrime;\n          result[2] = tempPointBx;\n          result[3] = tempPointBy;\n          break;\n        case 2:\n          tempPointBx = bottomRightBx;\n          tempPointBy = p2y + halfWidthB * slopePrime;\n          result[2] = tempPointBx;\n          result[3] = tempPointBy;\n          break;\n        case 3:\n          tempPointBy = bottomLeftBy;\n          tempPointBx = p2x + halfHeightB / slopePrime;\n          result[2] = tempPointBx;\n          result[3] = tempPointBy;\n          break;\n        case 4:\n          tempPointBx = bottomLeftBx;\n          tempPointBy = p2y + (-halfWidthB) * slopePrime;\n          result[2] = tempPointBx;\n          result[3] = tempPointBy;\n          break;\n      }\n    }\n  }\n  return false;\n}\n\nIGeometry.getCardinalDirection = function (slope, slopePrime, line)\n{\n  if (slope > slopePrime)\n  {\n    return line;\n  }\n  else\n  {\n    return 1 + line % 4;\n  }\n}\n\nIGeometry.getIntersection = function (s1, s2, f1, f2)\n{\n  if (f2 == null) {\n    return IGeometry.getIntersection2(s1, s2, f1);\n  }\n  var x1 = s1.x;\n  var y1 = s1.y;\n  var x2 = s2.x;\n  var y2 = s2.y;\n  var x3 = f1.x;\n  var y3 = f1.y;\n  var x4 = f2.x;\n  var y4 = f2.y;\n  var x, y; // intersection point\n  var a1, a2, b1, b2, c1, c2; // coefficients of line eqns.\n  var denom;\n\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2;  // { a1*x + b1*y + c1 = 0 is line 1 }\n\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4;  // { a2*x + b2*y + c2 = 0 is line 2 }\n\n  denom = a1 * b2 - a2 * b1;\n\n  if (denom == 0)\n  {\n    return null;\n  }\n\n  x = (b1 * c2 - b2 * c1) / denom;\n  y = (a2 * c1 - a1 * c2) / denom;\n\n  return new Point(x, y);\n}\n\n// -----------------------------------------------------------------------------\n// Section: Class Constants\n// -----------------------------------------------------------------------------\n/**\n * Some useful pre-calculated constants\n */\nIGeometry.HALF_PI = 0.5 * Math.PI;\nIGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\nIGeometry.TWO_PI = 2.0 * Math.PI;\nIGeometry.THREE_PI = 3.0 * Math.PI;\n\nmodule.exports = IGeometry;\n","function IMath() {\n}\n\n/**\n * This method returns the sign of the input value.\n */\nIMath.sign = function (value) {\n  if (value > 0)\n  {\n    return 1;\n  }\n  else if (value < 0)\n  {\n    return -1;\n  }\n  else\n  {\n    return 0;\n  }\n}\n\nIMath.floor = function (value) {\n  return value < 0 ? Math.ceil(value) : Math.floor(value);\n}\n\nIMath.ceil = function (value) {\n  return value < 0 ? Math.floor(value) : Math.ceil(value);\n}\n\nmodule.exports = IMath;\n","function Integer() {\n}\n\nInteger.MAX_VALUE = 2147483647;\nInteger.MIN_VALUE = -2147483648;\n\nmodule.exports = Integer;\n","function LGraphObject(vGraphObject) {\n  this.vGraphObject = vGraphObject;\n}\n\nmodule.exports = LGraphObject;\n","var LGraphObject = require('./LGraphObject');\nvar Integer = require('./Integer');\nvar LayoutConstants = require('./LayoutConstants');\nvar LGraphManager = require('./LGraphManager');\nvar LNode = require('./LNode');\nvar HashSet = require('./HashSet');\nvar RectangleD = require('./RectangleD');\nvar Point = require('./Point');\n\nfunction LGraph(parent, obj2, vGraph) {\n  LGraphObject.call(this, vGraph);\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n  this.edges = [];\n  this.nodes = [];\n  this.isConnected = false;\n  this.parent = parent;\n\n  if (obj2 != null && obj2 instanceof LGraphManager) {\n    this.graphManager = obj2;\n  }\n  else if (obj2 != null && obj2 instanceof Layout) {\n    this.graphManager = obj2.graphManager;\n  }\n}\n\nLGraph.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LGraph[prop] = LGraphObject[prop];\n}\n\nLGraph.prototype.getNodes = function () {\n  return this.nodes;\n};\n\nLGraph.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLGraph.prototype.getGraphManager = function ()\n{\n  return this.graphManager;\n};\n\nLGraph.prototype.getParent = function ()\n{\n  return this.parent;\n};\n\nLGraph.prototype.getLeft = function ()\n{\n  return this.left;\n};\n\nLGraph.prototype.getRight = function ()\n{\n  return this.right;\n};\n\nLGraph.prototype.getTop = function ()\n{\n  return this.top;\n};\n\nLGraph.prototype.getBottom = function ()\n{\n  return this.bottom;\n};\n\nLGraph.prototype.isConnected = function ()\n{\n  return this.isConnected;\n};\n\nLGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n  if (sourceNode == null && targetNode == null) {\n    var newNode = obj1;\n    if (this.graphManager == null) {\n      throw \"Graph has no graph mgr!\";\n    }\n    if (this.getNodes().indexOf(newNode) > -1) {\n      throw \"Node already in graph!\";\n    }\n    newNode.owner = this;\n    this.getNodes().push(newNode);\n\n    return newNode;\n  }\n  else {\n    var newEdge = obj1;\n    if (!(this.getNodes().indexOf(sourceNode) > -1 && (this.getNodes().indexOf(targetNode)) > -1)) {\n      throw \"Source or target not in graph!\";\n    }\n\n    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n      throw \"Both owners must be this graph!\";\n    }\n\n    if (sourceNode.owner != targetNode.owner)\n    {\n      return null;\n    }\n\n    // set source and target\n    newEdge.source = sourceNode;\n    newEdge.target = targetNode;\n\n    // set as intra-graph edge\n    newEdge.isInterGraph = false;\n\n    // add to graph edge list\n    this.getEdges().push(newEdge);\n\n    // add to incidency lists\n    sourceNode.edges.push(newEdge);\n\n    if (targetNode != sourceNode)\n    {\n      targetNode.edges.push(newEdge);\n    }\n\n    return newEdge;\n  }\n};\n\nLGraph.prototype.remove = function (obj) {\n  var node = obj;\n  if (obj instanceof LNode) {\n    if (node == null) {\n      throw \"Node is null!\";\n    }\n    if (!(node.owner != null && node.owner == this)) {\n      throw \"Owner graph is invalid!\";\n    }\n    if (this.graphManager == null) {\n      throw \"Owner graph manager is invalid!\";\n    }\n    // remove incident edges first (make a copy to do it safely)\n    var edgesToBeRemoved = node.edges.slice();\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++)\n    {\n      edge = edgesToBeRemoved[i];\n\n      if (edge.isInterGraph)\n      {\n        this.graphManager.remove(edge);\n      }\n      else\n      {\n        edge.source.owner.remove(edge);\n      }\n    }\n\n    // now the node itself\n    var index = this.nodes.indexOf(node);\n    if (index == -1) {\n      throw \"Node not in owner node list!\";\n    }\n\n    this.nodes.splice(index, 1);\n  }\n  else if (obj instanceof LEdge) {\n    var edge = obj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n    if (!(edge.source.owner != null && edge.target.owner != null &&\n            edge.source.owner == this && edge.target.owner == this)) {\n      throw \"Source and/or target owner is invalid!\";\n    }\n\n    var sourceIndex = edge.source.edges.indexOf(edge);\n    var targetIndex = edge.target.edges.indexOf(edge);\n    if (!(sourceIndex > -1 && targetIndex > -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    edge.source.edges.splice(sourceIndex, 1);\n\n    if (edge.target != edge.source)\n    {\n      edge.target.edges.splice(targetIndex, 1);\n    }\n\n    var index = edge.source.owner.getEdges().indexOf(edge);\n    if (index == -1) {\n      throw \"Not in owner's edge list!\";\n    }\n\n    edge.source.owner.getEdges().splice(index, 1);\n  }\n};\n\nLGraph.prototype.updateLeftTop = function ()\n{\n  var top = Integer.MAX_VALUE;\n  var left = Integer.MAX_VALUE;\n  var nodeTop;\n  var nodeLeft;\n\n  var nodes = this.getNodes();\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++)\n  {\n    var lNode = nodes[i];\n    nodeTop = Math.floor(lNode.getTop());\n    nodeLeft = Math.floor(lNode.getLeft());\n\n    if (top > nodeTop)\n    {\n      top = nodeTop;\n    }\n\n    if (left > nodeLeft)\n    {\n      left = nodeLeft;\n    }\n  }\n\n  // Do we have any nodes in this graph?\n  if (top == Integer.MAX_VALUE)\n  {\n    return null;\n  }\n\n  this.left = left - this.margin;\n  this.top = top - this.margin;\n\n  // Apply the margins and return the result\n  return new Point(this.left, this.top);\n};\n\nLGraph.prototype.updateBounds = function (recursive)\n{\n  // calculate bounds\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n\n  var nodes = this.nodes;\n  var s = nodes.length;\n  for (var i = 0; i < s; i++)\n  {\n    var lNode = nodes[i];\n\n    if (recursive && lNode.child != null)\n    {\n      lNode.updateBounds();\n    }\n    nodeLeft = Math.floor(lNode.getLeft());\n    nodeRight = Math.floor(lNode.getRight());\n    nodeTop = Math.floor(lNode.getTop());\n    nodeBottom = Math.floor(lNode.getBottom());\n\n    if (left > nodeLeft)\n    {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight)\n    {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop)\n    {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom)\n    {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n  if (left == Integer.MAX_VALUE)\n  {\n    this.left = Math.floor(this.parent.getLeft());\n    this.right = Math.floor(this.parent.getRight());\n    this.top = Math.floor(this.parent.getTop());\n    this.bottom = Math.floor(this.parent.getBottom());\n  }\n\n  this.left = boundingRect.x - this.margin;\n  this.right = boundingRect.x + boundingRect.width + this.margin;\n  this.top = boundingRect.y - this.margin;\n  this.bottom = boundingRect.y + boundingRect.height + this.margin;\n};\n\nLGraph.calculateBounds = function (nodes)\n{\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++)\n  {\n    var lNode = nodes[i];\n    nodeLeft = Math.floor(lNode.getLeft());\n    nodeRight = Math.floor(lNode.getRight());\n    nodeTop = Math.floor(lNode.getTop());\n    nodeBottom = Math.floor(lNode.getBottom());\n\n    if (left > nodeLeft)\n    {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight)\n    {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop)\n    {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom)\n    {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n  return boundingRect;\n};\n\nLGraph.prototype.getInclusionTreeDepth = function ()\n{\n  if (this == this.graphManager.getRoot())\n  {\n    return 1;\n  }\n  else\n  {\n    return this.parent.getInclusionTreeDepth();\n  }\n};\n\nLGraph.prototype.getEstimatedSize = function ()\n{\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLGraph.prototype.calcEstimatedSize = function ()\n{\n  var size = 0;\n  var nodes = this.nodes;\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++)\n  {\n    var lNode = nodes[i];\n    size += lNode.calcEstimatedSize();\n  }\n\n  if (size == 0)\n  {\n    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n  }\n  else\n  {\n    this.estimatedSize = Math.floor(size / Math.sqrt(this.nodes.length));\n  }\n\n  return Math.floor(this.estimatedSize);\n};\n\nLGraph.prototype.updateConnected = function ()\n{\n  if (this.nodes.length == 0)\n  {\n    this.isConnected = true;\n    return;\n  }\n\n  var toBeVisited = [];\n  var visited = new HashSet();\n  var currentNode = this.nodes[0];\n  var neighborEdges;\n  var currentNeighbor;\n  toBeVisited = toBeVisited.concat(currentNode.withChildren());\n\n  while (toBeVisited.length > 0)\n  {\n    currentNode = toBeVisited.shift();\n    visited.add(currentNode);\n\n    // Traverse all neighbors of this node\n    neighborEdges = currentNode.getEdges();\n    var s = neighborEdges.length;\n    for (var i = 0; i < s; i++)\n    {\n      var neighborEdge = neighborEdges[i];\n      currentNeighbor =\n              neighborEdge.getOtherEndInGraph(currentNode, this);\n\n      // Add unvisited neighbors to the list to visit\n      if (currentNeighbor != null &&\n              !visited.contains(currentNeighbor))\n      {\n        toBeVisited = toBeVisited.concat(currentNeighbor.withChildren());\n      }\n    }\n  }\n\n  this.isConnected = false;\n\n  if (visited.size() >= this.nodes.length)\n  {\n    var noOfVisitedInThisGraph = 0;\n\n    var s = visited.size();\n    for (var visitedId in visited.set)\n    {\n      var visitedNode = visited.set[visitedId];\n      if (visitedNode.owner == this)\n      {\n        noOfVisitedInThisGraph++;\n      }\n    }\n\n    if (noOfVisitedInThisGraph == this.nodes.length)\n    {\n      this.isConnected = true;\n    }\n  }\n};\n\nmodule.exports = LGraph;\n","function LGraphManager(layout) {\n  this.layout = layout;\n\n  this.graphs = [];\n  this.edges = [];\n}\n\nLGraphManager.prototype.addRoot = function ()\n{\n  var ngraph = this.layout.newGraph();\n  var nnode = this.layout.newNode(null);\n  var root = this.add(ngraph, nnode);\n  this.setRootGraph(root);\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode)\n{\n  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n  if (newEdge == null && sourceNode == null && targetNode == null) {\n    if (newGraph == null) {\n      throw \"Graph is null!\";\n    }\n    if (parentNode == null) {\n      throw \"Parent node is null!\";\n    }\n    if (this.graphs.indexOf(newGraph) > -1) {\n      throw \"Graph already in this graph mgr!\";\n    }\n\n    this.graphs.push(newGraph);\n\n    if (newGraph.parent != null) {\n      throw \"Already has a parent!\";\n    }\n    if (parentNode.child != null) {\n      throw  \"Already has a child!\";\n    }\n\n    newGraph.parent = parentNode;\n    parentNode.child = newGraph;\n\n    return newGraph;\n  }\n  else {\n    //change the order of the parameters\n    targetNode = newEdge;\n    sourceNode = parentNode;\n    newEdge = newGraph;\n    var sourceGraph = sourceNode.getOwner();\n    var targetGraph = targetNode.getOwner();\n\n    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n      throw \"Source not in this graph mgr!\";\n    }\n    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n      throw \"Target not in this graph mgr!\";\n    }\n\n    if (sourceGraph == targetGraph)\n    {\n      newEdge.isInterGraph = false;\n      return sourceGraph.add(newEdge, sourceNode, targetNode);\n    }\n    else\n    {\n      newEdge.isInterGraph = true;\n\n      // set source and target\n      newEdge.source = sourceNode;\n      newEdge.target = targetNode;\n\n      // add edge to inter-graph edge list\n      if (this.edges.indexOf(newEdge) > -1) {\n        throw \"Edge already in inter-graph edge list!\";\n      }\n\n      this.edges.push(newEdge);\n\n      // add edge to source and target incidency lists\n      if (!(newEdge.source != null && newEdge.target != null)) {\n        throw \"Edge source and/or target is null!\";\n      }\n\n      if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n        throw \"Edge already in source and/or target incidency list!\";\n      }\n\n      newEdge.source.edges.push(newEdge);\n      newEdge.target.edges.push(newEdge);\n\n      return newEdge;\n    }\n  }\n};\n\nLGraphManager.prototype.remove = function (lObj) {\n  if (lObj instanceof LGraph) {\n    var graph = lObj;\n    if (graph.getGraphManager() != this) {\n      throw \"Graph not in this graph mgr\";\n    }\n    if (!(graph == this.rootGraph || (graph.parent != null && graph.parent.graphManager == this))) {\n      throw \"Invalid parent node!\";\n    }\n\n    // first the edges (make a copy to do it safely)\n    var edgesToBeRemoved = [];\n\n    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++)\n    {\n      edge = edgesToBeRemoved[i];\n      graph.remove(edge);\n    }\n\n    // then the nodes (make a copy to do it safely)\n    var nodesToBeRemoved = [];\n\n    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n\n    var node;\n    s = nodesToBeRemoved.length;\n    for (var i = 0; i < s; i++)\n    {\n      node = nodesToBeRemoved[i];\n      graph.remove(node);\n    }\n\n    // check if graph is the root\n    if (graph == this.rootGraph)\n    {\n      this.setRootGraph(null);\n    }\n\n    // now remove the graph itself\n    var index = this.graphs.indexOf(graph);\n    this.graphs.splice(index, 1);\n\n    // also reset the parent of the graph\n    graph.parent = null;\n  }\n  else if (lObj instanceof LEdge) {\n    edge = lObj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!edge.isInterGraph) {\n      throw \"Not an inter-graph edge!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n\n    // remove edge from source and target nodes' incidency lists\n\n    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    var index = edge.source.edges.indexOf(edge);\n    edge.source.edges.splice(index, 1);\n    index = edge.target.edges.indexOf(edge);\n    edge.target.edges.splice(index, 1);\n\n    // remove edge from owner graph manager's inter-graph edge list\n\n    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n      throw \"Edge owner graph or owner graph manager is null!\";\n    }\n    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n      throw \"Not in owner graph manager's edge list!\";\n    }\n\n    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n    edge.source.owner.getGraphManager().edges.splice(index, 1);\n  }\n};\n\nLGraphManager.prototype.updateBounds = function ()\n{\n  this.rootGraph.updateBounds(true);\n};\n\nLGraphManager.prototype.getGraphs = function ()\n{\n  return this.graphs;\n};\n\nLGraphManager.prototype.getAllNodes = function ()\n{\n  if (this.allNodes == null)\n  {\n    var nodeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < s; i++)\n    {\n      nodeList = nodeList.concat(graphs[i].getNodes());\n    }\n    this.allNodes = nodeList;\n  }\n  return this.allNodes;\n};\n\nLGraphManager.prototype.resetAllNodes = function ()\n{\n  this.allNodes = null;\n};\n\nLGraphManager.prototype.resetAllEdges = function ()\n{\n  this.allEdges = null;\n};\n\nLGraphManager.prototype.resetAllNodesToApplyGravitation = function ()\n{\n  this.allNodesToApplyGravitation = null;\n};\n\nLGraphManager.prototype.getAllEdges = function ()\n{\n  if (this.allEdges == null)\n  {\n    var edgeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < graphs.length; i++)\n    {\n      edgeList = edgeList.concat(graphs[i].getEdges());\n    }\n\n    edgeList = edgeList.concat(this.edges);\n\n    this.allEdges = edgeList;\n  }\n  return this.allEdges;\n};\n\nLGraphManager.prototype.getAllNodesToApplyGravitation = function ()\n{\n  return this.allNodesToApplyGravitation;\n};\n\nLGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList)\n{\n  if (this.allNodesToApplyGravitation != null) {\n    throw \"assert failed\";\n  }\n\n  this.allNodesToApplyGravitation = nodeList;\n};\n\nLGraphManager.prototype.getRoot = function ()\n{\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.setRootGraph = function (graph)\n{\n  if (graph.getGraphManager() != this) {\n    throw \"Root not in this graph mgr!\";\n  }\n\n  this.rootGraph = graph;\n  // root graph must have a root node associated with it for convenience\n  if (graph.parent == null)\n  {\n    graph.parent = this.layout.newNode(\"Root node\");\n  }\n};\n\nLGraphManager.prototype.getLayout = function ()\n{\n  return this.layout;\n};\n\nLGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode)\n{\n  if (!(firstNode != null && secondNode != null)) {\n    throw \"assert failed\";\n  }\n\n  if (firstNode == secondNode)\n  {\n    return true;\n  }\n  // Is second node an ancestor of the first one?\n  var ownerGraph = firstNode.getOwner();\n  var parentNode;\n\n  do\n  {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null)\n    {\n      break;\n    }\n\n    if (parentNode == secondNode)\n    {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null)\n    {\n      break;\n    }\n  } while (true);\n  // Is first node an ancestor of the second one?\n  ownerGraph = secondNode.getOwner();\n\n  do\n  {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null)\n    {\n      break;\n    }\n\n    if (parentNode == firstNode)\n    {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null)\n    {\n      break;\n    }\n  } while (true);\n\n  return false;\n};\n\nLGraphManager.prototype.calcLowestCommonAncestors = function ()\n{\n  var edge;\n  var sourceNode;\n  var targetNode;\n  var sourceAncestorGraph;\n  var targetAncestorGraph;\n\n  var edges = this.getAllEdges();\n  var s = edges.length;\n  for (var i = 0; i < s; i++)\n  {\n    edge = edges[i];\n\n    sourceNode = edge.source;\n    targetNode = edge.target;\n    edge.lca = null;\n    edge.sourceInLca = sourceNode;\n    edge.targetInLca = targetNode;\n\n    if (sourceNode == targetNode)\n    {\n      edge.lca = sourceNode.getOwner();\n      continue;\n    }\n\n    sourceAncestorGraph = sourceNode.getOwner();\n\n    while (edge.lca == null)\n    {\n      targetAncestorGraph = targetNode.getOwner();\n\n      while (edge.lca == null)\n      {\n        if (targetAncestorGraph == sourceAncestorGraph)\n        {\n          edge.lca = targetAncestorGraph;\n          break;\n        }\n\n        if (targetAncestorGraph == this.rootGraph)\n        {\n          break;\n        }\n\n        if (edge.lca != null) {\n          throw \"assert failed\";\n        }\n        edge.targetInLca = targetAncestorGraph.getParent();\n        targetAncestorGraph = edge.targetInLca.getOwner();\n      }\n\n      if (sourceAncestorGraph == this.rootGraph)\n      {\n        break;\n      }\n\n      if (edge.lca == null)\n      {\n        edge.sourceInLca = sourceAncestorGraph.getParent();\n        sourceAncestorGraph = edge.sourceInLca.getOwner();\n      }\n    }\n\n    if (edge.lca == null) {\n      throw \"assert failed\";\n    }\n  }\n};\n\nLGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode)\n{\n  if (firstNode == secondNode)\n  {\n    return firstNode.getOwner();\n  }\n  var firstOwnerGraph = firstNode.getOwner();\n\n  do\n  {\n    if (firstOwnerGraph == null)\n    {\n      break;\n    }\n    var secondOwnerGraph = secondNode.getOwner();\n\n    do\n    {\n      if (secondOwnerGraph == null)\n      {\n        break;\n      }\n\n      if (secondOwnerGraph == firstOwnerGraph)\n      {\n        return secondOwnerGraph;\n      }\n      secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n    } while (true);\n\n    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n  } while (true);\n\n  return firstOwnerGraph;\n};\n\nLGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n  if (graph == null && depth == null) {\n    graph = this.rootGraph;\n    depth = 1;\n  }\n  var node;\n\n  var nodes = graph.getNodes();\n  var s = nodes.length;\n  for (var i = 0; i < s; i++)\n  {\n    node = nodes[i];\n    node.inclusionTreeDepth = depth;\n\n    if (node.child != null)\n    {\n      this.calcInclusionTreeDepths(node.child, depth + 1);\n    }\n  }\n};\n\nLGraphManager.prototype.includesInvalidEdge = function ()\n{\n  var edge;\n\n  var s = this.edges.length;\n  for (var i = 0; i < s; i++)\n  {\n    edge = this.edges[i];\n\n    if (this.isOneAncestorOfOther(edge.source, edge.target))\n    {\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports = LGraphManager;\n","var LGraphObject = require('./LGraphObject');\nvar Integer = require('./Integer');\nvar RectangleD = require('./RectangleD');\nvar LayoutConstants = require('./LayoutConstants');\nvar RandomSeed = require('./RandomSeed');\nvar PointD = require('./PointD');\nvar HashSet = require('./HashSet');\n\nfunction LNode(gm, loc, size, vNode) {\n  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n  if (size == null && vNode == null) {\n    vNode = loc;\n  }\n\n  LGraphObject.call(this, vNode);\n\n  //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n  if (gm.graphManager != null)\n    gm = gm.graphManager;\n\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.inclusionTreeDepth = Integer.MAX_VALUE;\n  this.vGraphObject = vNode;\n  this.edges = [];\n  this.graphManager = gm;\n\n  if (size != null && loc != null)\n    this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);\n  else\n    this.rect = new RectangleD();\n}\n\nLNode.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LNode[prop] = LGraphObject[prop];\n}\n\nLNode.prototype.getEdges = function ()\n{\n  return this.edges;\n};\n\nLNode.prototype.getChild = function ()\n{\n  return this.child;\n};\n\nLNode.prototype.getOwner = function ()\n{\n  if (this.owner != null) {\n    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n      throw \"assert failed\";\n    }\n  }\n\n  return this.owner;\n};\n\nLNode.prototype.getWidth = function ()\n{\n  return this.rect.width;\n};\n\nLNode.prototype.setWidth = function (width)\n{\n  this.rect.width = width;\n};\n\nLNode.prototype.getHeight = function ()\n{\n  return this.rect.height;\n};\n\nLNode.prototype.setHeight = function (height)\n{\n  this.rect.height = height;\n};\n\nLNode.prototype.getCenterX = function ()\n{\n  return this.rect.x + this.rect.width / 2;\n};\n\nLNode.prototype.getCenterY = function ()\n{\n  return this.rect.y + this.rect.height / 2;\n};\n\nLNode.prototype.getCenter = function ()\n{\n  return new PointD(this.rect.x + this.rect.width / 2,\n          this.rect.y + this.rect.height / 2);\n};\n\nLNode.prototype.getLocation = function ()\n{\n  return new PointD(this.rect.x, this.rect.y);\n};\n\nLNode.prototype.getRect = function ()\n{\n  return this.rect;\n};\n\nLNode.prototype.getDiagonal = function ()\n{\n  return Math.sqrt(this.rect.width * this.rect.width +\n          this.rect.height * this.rect.height);\n};\n\nLNode.prototype.setRect = function (upperLeft, dimension)\n{\n  this.rect.x = upperLeft.x;\n  this.rect.y = upperLeft.y;\n  this.rect.width = dimension.width;\n  this.rect.height = dimension.height;\n};\n\nLNode.prototype.setCenter = function (cx, cy)\n{\n  this.rect.x = cx - this.rect.width / 2;\n  this.rect.y = cy - this.rect.height / 2;\n};\n\nLNode.prototype.setLocation = function (x, y)\n{\n  this.rect.x = x;\n  this.rect.y = y;\n};\n\nLNode.prototype.moveBy = function (dx, dy)\n{\n  this.rect.x += dx;\n  this.rect.y += dy;\n};\n\nLNode.prototype.getEdgeListToNode = function (to)\n{\n  var edgeList = [];\n  var edge;\n\n  for (var obj in this.edges)\n  {\n    edge = obj;\n\n    if (edge.target == to)\n    {\n      if (edge.source != this)\n        throw \"Incorrect edge source!\";\n\n      edgeList.push(edge);\n    }\n  }\n\n  return edgeList;\n};\n\nLNode.prototype.getEdgesBetween = function (other)\n{\n  var edgeList = [];\n  var edge;\n\n  for (var obj in this.edges)\n  {\n    edge = this.edges[obj];\n\n    if (!(edge.source == this || edge.target == this))\n      throw \"Incorrect edge source and/or target\";\n\n    if ((edge.target == other) || (edge.source == other))\n    {\n      edgeList.push(edge);\n    }\n  }\n\n  return edgeList;\n};\n\nLNode.prototype.getNeighborsList = function ()\n{\n  var neighbors = new HashSet();\n  var edge;\n\n  for (var obj in this.edges)\n  {\n    edge = this.edges[obj];\n\n    if (edge.source == this)\n    {\n      neighbors.add(edge.target);\n    }\n    else\n    {\n      if (!edge.target == this)\n        throw \"Incorrect incidency!\";\n      neighbors.add(edge.source);\n    }\n  }\n\n  return neighbors;\n};\n\nLNode.prototype.withChildren = function ()\n{\n  var withNeighborsList = [];\n  var childNode;\n\n  withNeighborsList.push(this);\n\n  if (this.child != null)\n  {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++)\n    {\n      childNode = nodes[i];\n\n      withNeighborsList = withNeighborsList.concat(childNode.withChildren());\n    }\n  }\n\n  return withNeighborsList;\n};\n\nLNode.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLNode.prototype.calcEstimatedSize = function () {\n  if (this.child == null)\n  {\n    return this.estimatedSize = Math.floor((this.rect.width + this.rect.height) / 2);\n  }\n  else\n  {\n    this.estimatedSize = this.child.calcEstimatedSize();\n    this.rect.width = this.estimatedSize;\n    this.rect.height = this.estimatedSize;\n\n    return this.estimatedSize;\n  }\n};\n\nLNode.prototype.scatter = function () {\n  var randomCenterX;\n  var randomCenterY;\n\n  var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterX = LayoutConstants.WORLD_CENTER_X +\n          (RandomSeed.nextDouble() * (maxX - minX)) + minX;\n\n  var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterY = LayoutConstants.WORLD_CENTER_Y +\n          (RandomSeed.nextDouble() * (maxY - minY)) + minY;\n\n  this.rect.x = randomCenterX;\n  this.rect.y = randomCenterY\n};\n\nLNode.prototype.updateBounds = function () {\n  if (this.getChild() == null) {\n    throw \"assert failed\";\n  }\n  if (this.getChild().getNodes().length != 0)\n  {\n    // wrap the children nodes by re-arranging the boundaries\n    var childGraph = this.getChild();\n    childGraph.updateBounds(true);\n\n    this.rect.x = childGraph.getLeft();\n    this.rect.y = childGraph.getTop();\n\n    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n  }\n};\n\nLNode.prototype.getInclusionTreeDepth = function ()\n{\n  if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.inclusionTreeDepth;\n};\n\nLNode.prototype.transform = function (trans)\n{\n  var left = this.rect.x;\n\n  if (left > LayoutConstants.WORLD_BOUNDARY)\n  {\n    left = LayoutConstants.WORLD_BOUNDARY;\n  }\n  else if (left < -LayoutConstants.WORLD_BOUNDARY)\n  {\n    left = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var top = this.rect.y;\n\n  if (top > LayoutConstants.WORLD_BOUNDARY)\n  {\n    top = LayoutConstants.WORLD_BOUNDARY;\n  }\n  else if (top < -LayoutConstants.WORLD_BOUNDARY)\n  {\n    top = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var leftTop = new PointD(left, top);\n  var vLeftTop = trans.inverseTransformPoint(leftTop);\n\n  this.setLocation(vLeftTop.x, vLeftTop.y);\n};\n\nLNode.prototype.getLeft = function ()\n{\n  return this.rect.x;\n};\n\nLNode.prototype.getRight = function ()\n{\n  return this.rect.x + this.rect.width;\n};\n\nLNode.prototype.getTop = function ()\n{\n  return this.rect.y;\n};\n\nLNode.prototype.getBottom = function ()\n{\n  return this.rect.y + this.rect.height;\n};\n\nLNode.prototype.getParent = function ()\n{\n  if (this.owner == null)\n  {\n    return null;\n  }\n\n  return this.owner.getParent();\n};\n\nmodule.exports = LNode;\n","function UniqueIDGeneretor() {\n}\n\nUniqueIDGeneretor.lastID = 0;\n\nUniqueIDGeneretor.createID = function (obj) {\n  if (UniqueIDGeneretor.isPrimitive(obj)) {\n    return obj;\n  }\n  if (obj.uniqueID != null) {\n    return obj.uniqueID;\n  }\n  obj.uniqueID = UniqueIDGeneretor.getString();\n  UniqueIDGeneretor.lastID++;\n  return obj.uniqueID;\n}\n\nUniqueIDGeneretor.getString = function (id) {\n  if (id == null)\n    id = UniqueIDGeneretor.lastID;\n  return \"Object#\" + id + \"\";\n}\n\nUniqueIDGeneretor.isPrimitive = function (arg) {\n  var type = typeof arg;\n  return arg == null || (type != \"object\" && type != \"function\");\n}\n\nmodule.exports = UniqueIDGeneretor;\n","/*\n *This class is the javascript implementation of the Point.java class in jdk\n */\nfunction Point(x, y, p) {\n  this.x = null;\n  this.y = null;\n  if (x == null && y == null && p == null) {\n    this.x = 0;\n    this.y = 0;\n  }\n  else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    this.x = x;\n    this.y = y;\n  }\n  else if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.x = p.x;\n    this.y = p.y;\n  }\n}\n\nPoint.prototype.getX = function () {\n  return this.x;\n}\n\nPoint.prototype.getY = function () {\n  return this.y;\n}\n\nPoint.prototype.getLocation = function () {\n  return new Point(this.x, this.y);\n}\n\nPoint.prototype.setLocation = function (x, y, p) {\n  if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.setLocation(p.x, p.y);\n  }\n  else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    //if both parameters are integer just move (x,y) location\n    if (parseInt(x) == x && parseInt(y) == y) {\n      this.move(x, y);\n    }\n    else {\n      this.x = Math.floor(x + 0.5);\n      this.y = Math.floor(y + 0.5);\n    }\n  }\n}\n\nPoint.prototype.move = function (x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.translate = function (dx, dy) {\n  this.x += dx;\n  this.y += dy;\n}\n\nPoint.prototype.equals = function (obj) {\n  if (obj.constructor.name == \"Point\") {\n    var pt = obj;\n    return (this.x == pt.x) && (this.y == pt.y);\n  }\n  return this == obj;\n}\n\nPoint.prototype.toString = function () {\n  return new Point().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n}\n\nmodule.exports = Point;\n","function RectangleD(x, y, width, height) {\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n\n  if (x != null && y != null && width != null && height != null) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nRectangleD.prototype.getX = function ()\n{\n  return this.x;\n};\n\nRectangleD.prototype.setX = function (x)\n{\n  this.x = x;\n};\n\nRectangleD.prototype.getY = function ()\n{\n  return this.y;\n};\n\nRectangleD.prototype.setY = function (y)\n{\n  this.y = y;\n};\n\nRectangleD.prototype.getWidth = function ()\n{\n  return this.width;\n};\n\nRectangleD.prototype.setWidth = function (width)\n{\n  this.width = width;\n};\n\nRectangleD.prototype.getHeight = function ()\n{\n  return this.height;\n};\n\nRectangleD.prototype.setHeight = function (height)\n{\n  this.height = height;\n};\n\nRectangleD.prototype.getRight = function ()\n{\n  return this.x + this.width;\n};\n\nRectangleD.prototype.getBottom = function ()\n{\n  return this.y + this.height;\n};\n\nRectangleD.prototype.intersects = function (a)\n{\n  if (this.getRight() < a.x)\n  {\n    return false;\n  }\n\n  if (this.getBottom() < a.y)\n  {\n    return false;\n  }\n\n  if (a.getRight() < this.x)\n  {\n    return false;\n  }\n\n  if (a.getBottom() < this.y)\n  {\n    return false;\n  }\n\n  return true;\n};\n\nRectangleD.prototype.getCenterX = function ()\n{\n  return this.x + this.width / 2;\n};\n\nRectangleD.prototype.getMinX = function ()\n{\n  return this.getX();\n};\n\nRectangleD.prototype.getMaxX = function ()\n{\n  return this.getX() + this.width;\n};\n\nRectangleD.prototype.getCenterY = function ()\n{\n  return this.y + this.height / 2;\n};\n\nRectangleD.prototype.getMinY = function ()\n{\n  return this.getY();\n};\n\nRectangleD.prototype.getMaxY = function ()\n{\n  return this.getY() + this.height;\n};\n\nRectangleD.prototype.getWidthHalf = function ()\n{\n  return this.width / 2;\n};\n\nRectangleD.prototype.getHeightHalf = function ()\n{\n  return this.height / 2;\n};\n\nmodule.exports = RectangleD;\n","var PointD = require('./PointD');\n\nfunction Transform(x, y) {\n  this.lworldOrgX = 0.0;\n  this.lworldOrgY = 0.0;\n  this.ldeviceOrgX = 0.0;\n  this.ldeviceOrgY = 0.0;\n  this.lworldExtX = 1.0;\n  this.lworldExtY = 1.0;\n  this.ldeviceExtX = 1.0;\n  this.ldeviceExtY = 1.0;\n}\n\nTransform.prototype.getWorldOrgX = function ()\n{\n  return this.lworldOrgX;\n}\n\nTransform.prototype.setWorldOrgX = function (wox)\n{\n  this.lworldOrgX = wox;\n}\n\nTransform.prototype.getWorldOrgY = function ()\n{\n  return this.lworldOrgY;\n}\n\nTransform.prototype.setWorldOrgY = function (woy)\n{\n  this.lworldOrgY = woy;\n}\n\nTransform.prototype.getWorldExtX = function ()\n{\n  return this.lworldExtX;\n}\n\nTransform.prototype.setWorldExtX = function (wex)\n{\n  this.lworldExtX = wex;\n}\n\nTransform.prototype.getWorldExtY = function ()\n{\n  return this.lworldExtY;\n}\n\nTransform.prototype.setWorldExtY = function (wey)\n{\n  this.lworldExtY = wey;\n}\n\n/* Device related */\n\nTransform.prototype.getDeviceOrgX = function ()\n{\n  return this.ldeviceOrgX;\n}\n\nTransform.prototype.setDeviceOrgX = function (dox)\n{\n  this.ldeviceOrgX = dox;\n}\n\nTransform.prototype.getDeviceOrgY = function ()\n{\n  return this.ldeviceOrgY;\n}\n\nTransform.prototype.setDeviceOrgY = function (doy)\n{\n  this.ldeviceOrgY = doy;\n}\n\nTransform.prototype.getDeviceExtX = function ()\n{\n  return this.ldeviceExtX;\n}\n\nTransform.prototype.setDeviceExtX = function (dex)\n{\n  this.ldeviceExtX = dex;\n}\n\nTransform.prototype.getDeviceExtY = function ()\n{\n  return this.ldeviceExtY;\n}\n\nTransform.prototype.setDeviceExtY = function (dey)\n{\n  this.ldeviceExtY = dey;\n}\n\nTransform.prototype.transformX = function (x)\n{\n  var xDevice = 0.0;\n  var worldExtX = this.lworldExtX;\n  if (worldExtX != 0.0)\n  {\n    xDevice = this.ldeviceOrgX +\n            ((x - this.lworldOrgX) * this.ldeviceExtX / worldExtX);\n  }\n\n  return xDevice;\n}\n\nTransform.prototype.transformY = function (y)\n{\n  var yDevice = 0.0;\n  var worldExtY = this.lworldExtY;\n  if (worldExtY != 0.0)\n  {\n    yDevice = this.ldeviceOrgY +\n            ((y - this.lworldOrgY) * this.ldeviceExtY / worldExtY);\n  }\n\n\n  return yDevice;\n}\n\nTransform.prototype.inverseTransformX = function (x)\n{\n  var xWorld = 0.0;\n  var deviceExtX = this.ldeviceExtX;\n  if (deviceExtX != 0.0)\n  {\n    xWorld = this.lworldOrgX +\n            ((x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX);\n  }\n\n\n  return xWorld;\n}\n\nTransform.prototype.inverseTransformY = function (y)\n{\n  var yWorld = 0.0;\n  var deviceExtY = this.ldeviceExtY;\n  if (deviceExtY != 0.0)\n  {\n    yWorld = this.lworldOrgY +\n            ((y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY);\n  }\n  return yWorld;\n}\n\nTransform.prototype.inverseTransformPoint = function (inPoint)\n{\n  var outPoint =\n          new PointD(this.inverseTransformX(inPoint.x),\n                  this.inverseTransformY(inPoint.y));\n  return outPoint;\n}\n\nmodule.exports = Transform;\n","var LGraphObject = require('./LGraphObject');\nvar IGeometry = require('./IGeometry');\nvar IMath = require('./IMath');\n\nfunction LEdge(source, target, vEdge) {\n  LGraphObject.call(this, vEdge);\n\n  this.isOverlapingSourceAndTarget = false;\n  this.vGraphObject = vEdge;\n  this.bendpoints = [];\n  this.source = source;\n  this.target = target;\n}\n\nLEdge.prototype = Object.create(LGraphObject.prototype);\n\nfor (var prop in LGraphObject) {\n  LEdge[prop] = LGraphObject[prop];\n}\n\nLEdge.prototype.getSource = function ()\n{\n  return this.source;\n};\n\nLEdge.prototype.getTarget = function ()\n{\n  return this.target;\n};\n\nLEdge.prototype.isInterGraph = function ()\n{\n  return this.isInterGraph;\n};\n\nLEdge.prototype.getLength = function ()\n{\n  return this.length;\n};\n\nLEdge.prototype.isOverlapingSourceAndTarget = function ()\n{\n  return this.isOverlapingSourceAndTarget;\n};\n\nLEdge.prototype.getBendpoints = function ()\n{\n  return this.bendpoints;\n};\n\nLEdge.prototype.getLca = function ()\n{\n  return this.lca;\n};\n\nLEdge.prototype.getSourceInLca = function ()\n{\n  return this.sourceInLca;\n};\n\nLEdge.prototype.getTargetInLca = function ()\n{\n  return this.targetInLca;\n};\n\nLEdge.prototype.getOtherEnd = function (node)\n{\n  if (this.source === node)\n  {\n    return this.target;\n  }\n  else if (this.target === node)\n  {\n    return this.source;\n  }\n  else\n  {\n    throw \"Node is not incident with this edge\";\n  }\n}\n\nLEdge.prototype.getOtherEndInGraph = function (node, graph)\n{\n  var otherEnd = this.getOtherEnd(node);\n  var root = graph.getGraphManager().getRoot();\n\n  while (true)\n  {\n    if (otherEnd.getOwner() == graph)\n    {\n      return otherEnd;\n    }\n\n    if (otherEnd.getOwner() == root)\n    {\n      break;\n    }\n\n    otherEnd = otherEnd.getOwner().getParent();\n  }\n\n  return null;\n};\n\nLEdge.prototype.updateLength = function ()\n{\n  var clipPointCoordinates = new Array(4);\n\n  this.isOverlapingSourceAndTarget =\n          IGeometry.getIntersection(this.target.getRect(),\n                  this.source.getRect(),\n                  clipPointCoordinates);\n\n  if (!this.isOverlapingSourceAndTarget)\n  {\n    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n    if (Math.abs(this.lengthX) < 1.0)\n    {\n      this.lengthX = IMath.sign(this.lengthX);\n    }\n\n    if (Math.abs(this.lengthY) < 1.0)\n    {\n      this.lengthY = IMath.sign(this.lengthY);\n    }\n\n    this.length = Math.sqrt(\n            this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n  }\n};\n\nLEdge.prototype.updateLengthSimple = function ()\n{\n  this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n  this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n  if (Math.abs(this.lengthX) < 1.0)\n  {\n    this.lengthX = IMath.sign(this.lengthX);\n  }\n\n  if (Math.abs(this.lengthY) < 1.0)\n  {\n    this.lengthY = IMath.sign(this.lengthY);\n  }\n\n  this.length = Math.sqrt(\n          this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n}\n\nmodule.exports = LEdge;\n","var LayoutConstants = require('./LayoutConstants');\nvar HashMap = require('./HashMap');\nvar LGraphManager = require('./LGraphManager');\nvar LNode = require('./LNode');\nvar LEdge = require('./LEdge');\nvar LGraph = require('./LGraph');\nvar PointD = require('./PointD');\nvar Transform = require('./Transform');\nvar Emitter = require('./Emitter');\nvar HashSet = require('./HashSet');\n\nfunction Layout(isRemoteUse) {\n  Emitter.call( this );\n\n  //Layout Quality: 0:proof, 1:default, 2:draft\n  this.layoutQuality = LayoutConstants.DEFAULT_QUALITY;\n  //Whether layout should create bendpoints as needed or not\n  this.createBendsAsNeeded =\n          LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  //Whether layout should be incremental or not\n  this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n  //Whether we animate from before to after layout node positions\n  this.animationOnLayout =\n          LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n  //Whether we animate the layout process or not\n  this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n  //Number iterations that should be done between two successive animations\n  this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n  /**\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\n   * they are, both spring and repulsion forces between two leaf nodes can be\n   * calculated without the expensive clipping point calculations, resulting\n   * in major speed-up.\n   */\n  this.uniformLeafNodeSizes =\n          LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  /**\n   * This is used for creation of bendpoints by using dummy nodes and edges.\n   * Maps an LEdge to its dummy bendpoint path.\n   */\n  this.edgeToDummyNodes = new HashMap();\n  this.graphManager = new LGraphManager(this);\n  this.isLayoutFinished = false;\n  this.isSubLayout = false;\n  this.isRemoteUse = false;\n\n  if (isRemoteUse != null) {\n    this.isRemoteUse = isRemoteUse;\n  }\n}\n\nLayout.RANDOM_SEED = 1;\n\nLayout.prototype = Object.create( Emitter.prototype );\n\nLayout.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLayout.prototype.getAllNodes = function () {\n  return this.graphManager.getAllNodes();\n};\n\nLayout.prototype.getAllEdges = function () {\n  return this.graphManager.getAllEdges();\n};\n\nLayout.prototype.getAllNodesToApplyGravitation = function () {\n  return this.graphManager.getAllNodesToApplyGravitation();\n};\n\nLayout.prototype.newGraphManager = function () {\n  var gm = new LGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nLayout.prototype.newGraph = function (vGraph)\n{\n  return new LGraph(null, this.graphManager, vGraph);\n};\n\nLayout.prototype.newNode = function (vNode)\n{\n  return new LNode(this.graphManager, vNode);\n};\n\nLayout.prototype.newEdge = function (vEdge)\n{\n  return new LEdge(null, null, vEdge);\n};\n\nLayout.prototype.runLayout = function ()\n{\n  this.isLayoutFinished = false;\n\n  this.initParameters();\n  var isLayoutSuccessfull;\n\n  if ((this.graphManager.getRoot() == null)\n          || this.graphManager.getRoot().getNodes().length == 0\n          || this.graphManager.includesInvalidEdge())\n  {\n    isLayoutSuccessfull = false;\n  }\n  else\n  {\n    // calculate execution time\n    var startTime = 0;\n\n    if (!this.isSubLayout)\n    {\n      startTime = new Date().getTime()\n    }\n\n    isLayoutSuccessfull = this.layout();\n\n    if (!this.isSubLayout)\n    {\n      var endTime = new Date().getTime();\n      var excTime = endTime - startTime;\n    }\n  }\n\n  if (isLayoutSuccessfull)\n  {\n    if (!this.isSubLayout)\n    {\n      this.doPostLayout();\n    }\n  }\n\n  this.isLayoutFinished = true;\n\n  return isLayoutSuccessfull;\n};\n\n/**\n * This method performs the operations required after layout.\n */\nLayout.prototype.doPostLayout = function ()\n{\n  //assert !isSubLayout : \"Should not be called on sub-layout!\";\n  // Propagate geometric changes to v-level objects\n  this.transform();\n  this.update();\n};\n\n/**\n * This method updates the geometry of the target graph according to\n * calculated layout.\n */\nLayout.prototype.update2 = function () {\n  // update bend points\n  if (this.createBendsAsNeeded)\n  {\n    this.createBendpointsFromDummyNodes();\n\n    // reset all edges, since the topology has changed\n    this.graphManager.resetAllEdges();\n  }\n\n  // perform edge, node and root updates if layout is not called\n  // remotely\n  if (!this.isRemoteUse)\n  {\n    // update all edges\n    var edge;\n    var allEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < allEdges.length; i++)\n    {\n      edge = allEdges[i];\n//      this.update(edge);\n    }\n\n    // recursively update nodes\n    var node;\n    var nodes = this.graphManager.getRoot().getNodes();\n    for (var i = 0; i < nodes.length; i++)\n    {\n      node = nodes[i];\n//      this.update(node);\n    }\n\n    // update root graph\n    this.update(this.graphManager.getRoot());\n  }\n};\n\nLayout.prototype.update = function (obj) {\n  if (obj == null) {\n    this.update2();\n  }\n  else if (obj instanceof LNode) {\n    var node = obj;\n    if (node.getChild() != null)\n    {\n      // since node is compound, recursively update child nodes\n      var nodes = node.getChild().getNodes();\n      for (var i = 0; i < nodes.length; i++)\n      {\n        update(nodes[i]);\n      }\n    }\n\n    // if the l-level node is associated with a v-level graph object,\n    // then it is assumed that the v-level node implements the\n    // interface Updatable.\n    if (node.vGraphObject != null)\n    {\n      // cast to Updatable without any type check\n      var vNode = node.vGraphObject;\n\n      // call the update method of the interface\n      vNode.update(node);\n    }\n  }\n  else if (obj instanceof LEdge) {\n    var edge = obj;\n    // if the l-level edge is associated with a v-level graph object,\n    // then it is assumed that the v-level edge implements the\n    // interface Updatable.\n\n    if (edge.vGraphObject != null)\n    {\n      // cast to Updatable without any type check\n      var vEdge = edge.vGraphObject;\n\n      // call the update method of the interface\n      vEdge.update(edge);\n    }\n  }\n  else if (obj instanceof LGraph) {\n    var graph = obj;\n    // if the l-level graph is associated with a v-level graph object,\n    // then it is assumed that the v-level object implements the\n    // interface Updatable.\n\n    if (graph.vGraphObject != null)\n    {\n      // cast to Updatable without any type check\n      var vGraph = graph.vGraphObject;\n\n      // call the update method of the interface\n      vGraph.update(graph);\n    }\n  }\n};\n\n/**\n * This method is used to set all layout parameters to default values\n * determined at compile time.\n */\nLayout.prototype.initParameters = function () {\n  if (!this.isSubLayout)\n  {\n    this.layoutQuality = LayoutConstants.DEFAULT_QUALITY;\n    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  }\n\n  if (this.animationDuringLayout)\n  {\n    animationOnLayout = false;\n  }\n};\n\nLayout.prototype.transform = function (newLeftTop) {\n  if (newLeftTop == undefined) {\n    this.transform(new PointD(0, 0));\n  }\n  else {\n    // create a transformation object (from Eclipse to layout). When an\n    // inverse transform is applied, we get upper-left coordinate of the\n    // drawing or the root graph at given input coordinate (some margins\n    // already included in calculation of left-top).\n\n    var trans = new Transform();\n    var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n    if (leftTop != null)\n    {\n      trans.setWorldOrgX(newLeftTop.x);\n      trans.setWorldOrgY(newLeftTop.y);\n\n      trans.setDeviceOrgX(leftTop.x);\n      trans.setDeviceOrgY(leftTop.y);\n\n      var nodes = this.getAllNodes();\n      var node;\n\n      for (var i = 0; i < nodes.length; i++)\n      {\n        node = nodes[i];\n        node.transform(trans);\n      }\n    }\n  }\n};\n\nLayout.prototype.positionNodesRandomly = function (graph) {\n\n  if (graph == undefined) {\n    //assert !this.incremental;\n    this.positionNodesRandomly(this.getGraphManager().getRoot());\n    this.getGraphManager().getRoot().updateBounds(true);\n  }\n  else {\n    var lNode;\n    var childGraph;\n\n    var nodes = graph.getNodes();\n    for (var i = 0; i < nodes.length; i++)\n    {\n      lNode = nodes[i];\n      childGraph = lNode.getChild();\n\n      if (childGraph == null)\n      {\n        lNode.scatter();\n      }\n      else if (childGraph.getNodes().length == 0)\n      {\n        lNode.scatter();\n      }\n      else\n      {\n        this.positionNodesRandomly(childGraph);\n        lNode.updateBounds();\n      }\n    }\n  }\n};\n\n/**\n * This method returns a list of trees where each tree is represented as a\n * list of l-nodes. The method returns a list of size 0 when:\n * - The graph is not flat or\n * - One of the component(s) of the graph is not a tree.\n */\nLayout.prototype.getFlatForest = function ()\n{\n  var flatForest = [];\n  var isForest = true;\n\n  // Quick reference for all nodes in the graph manager associated with\n  // this layout. The list should not be changed.\n  var allNodes = this.graphManager.getRoot().getNodes();\n\n  // First be sure that the graph is flat\n  var isFlat = true;\n\n  for (var i = 0; i < allNodes.length; i++)\n  {\n    if (allNodes[i].getChild() != null)\n    {\n      isFlat = false;\n    }\n  }\n\n  // Return empty forest if the graph is not flat.\n  if (!isFlat)\n  {\n    return flatForest;\n  }\n\n  // Run BFS for each component of the graph.\n\n  var visited = new HashSet();\n  var toBeVisited = [];\n  var parents = new HashMap();\n  var unProcessedNodes = [];\n\n  unProcessedNodes = unProcessedNodes.concat(allNodes);\n\n  // Each iteration of this loop finds a component of the graph and\n  // decides whether it is a tree or not. If it is a tree, adds it to the\n  // forest and continued with the next component.\n\n  while (unProcessedNodes.length > 0 && isForest)\n  {\n    toBeVisited.push(unProcessedNodes[0]);\n\n    // Start the BFS. Each iteration of this loop visits a node in a\n    // BFS manner.\n    while (toBeVisited.length > 0 && isForest)\n    {\n      //pool operation\n      var currentNode = toBeVisited[0];\n      toBeVisited.splice(0, 1);\n      visited.add(currentNode);\n\n      // Traverse all neighbors of this node\n      var neighborEdges = currentNode.getEdges();\n\n      for (var i = 0; i < neighborEdges.length; i++)\n      {\n        var currentNeighbor =\n                neighborEdges[i].getOtherEnd(currentNode);\n\n        // If BFS is not growing from this neighbor.\n        if (parents.get(currentNode) != currentNeighbor)\n        {\n          // We haven't previously visited this neighbor.\n          if (!visited.contains(currentNeighbor))\n          {\n            toBeVisited.push(currentNeighbor);\n            parents.put(currentNeighbor, currentNode);\n          }\n          // Since we have previously visited this neighbor and\n          // this neighbor is not parent of currentNode, given\n          // graph contains a component that is not tree, hence\n          // it is not a forest.\n          else\n          {\n            isForest = false;\n            break;\n          }\n        }\n      }\n    }\n\n    // The graph contains a component that is not a tree. Empty\n    // previously found trees. The method will end.\n    if (!isForest)\n    {\n      flatForest = [];\n    }\n    // Save currently visited nodes as a tree in our forest. Reset\n    // visited and parents lists. Continue with the next component of\n    // the graph, if any.\n    else\n    {\n      var temp = [];\n      visited.addAllTo(temp);\n      flatForest.push(temp);\n      //flatForest = flatForest.concat(temp);\n      //unProcessedNodes.removeAll(visited);\n      for (var i = 0; i < temp.length; i++) {\n        var value = temp[i];\n        var index = unProcessedNodes.indexOf(value);\n        if (index > -1) {\n          unProcessedNodes.splice(index, 1);\n        }\n      }\n      visited = new HashSet();\n      parents = new HashMap();\n    }\n  }\n\n  return flatForest;\n};\n\n/**\n * This method creates dummy nodes (an l-level node with minimal dimensions)\n * for the given edge (one per bendpoint). The existing l-level structure\n * is updated accordingly.\n */\nLayout.prototype.createDummyNodesForBendpoints = function (edge)\n{\n  var dummyNodes = [];\n  var prev = edge.source;\n\n  var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n  for (var i = 0; i < edge.bendpoints.length; i++)\n  {\n    // create new dummy node\n    var dummyNode = this.newNode(null);\n    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n\n    graph.add(dummyNode);\n\n    // create new dummy edge between prev and dummy node\n    var dummyEdge = this.newEdge(null);\n    this.graphManager.add(dummyEdge, prev, dummyNode);\n\n    dummyNodes.add(dummyNode);\n    prev = dummyNode;\n  }\n\n  var dummyEdge = this.newEdge(null);\n  this.graphManager.add(dummyEdge, prev, edge.target);\n\n  this.edgeToDummyNodes.put(edge, dummyNodes);\n\n  // remove real edge from graph manager if it is inter-graph\n  if (edge.isInterGraph())\n  {\n    this.graphManager.remove(edge);\n  }\n  // else, remove the edge from the current graph\n  else\n  {\n    graph.remove(edge);\n  }\n\n  return dummyNodes;\n};\n\n/**\n * This method creates bendpoints for edges from the dummy nodes\n * at l-level.\n */\nLayout.prototype.createBendpointsFromDummyNodes = function ()\n{\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  edges = this.edgeToDummyNodes.keySet().concat(edges);\n\n  for (var k = 0; k < edges.length; k++)\n  {\n    var lEdge = edges[k];\n\n    if (lEdge.bendpoints.length > 0)\n    {\n      var path = this.edgeToDummyNodes.get(lEdge);\n\n      for (var i = 0; i < path.length; i++)\n      {\n        var dummyNode = path[i];\n        var p = new PointD(dummyNode.getCenterX(),\n                dummyNode.getCenterY());\n\n        // update bendpoint's location according to dummy node\n        var ebp = lEdge.bendpoints.get(i);\n        ebp.x = p.x;\n        ebp.y = p.y;\n\n        // remove the dummy node, dummy edges incident with this\n        // dummy node is also removed (within the remove method)\n        dummyNode.getOwner().remove(dummyNode);\n      }\n\n      // add the real edge to graph\n      this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n    }\n  }\n};\n\nLayout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n  if (minDiv != undefined && maxMul != undefined) {\n    var value = defaultValue;\n\n    if (sliderValue <= 50)\n    {\n      var minValue = defaultValue / minDiv;\n      value -= ((defaultValue - minValue) / 50) * (50 - sliderValue);\n    }\n    else\n    {\n      var maxValue = defaultValue * maxMul;\n      value += ((maxValue - defaultValue) / 50) * (sliderValue - 50);\n    }\n\n    return value;\n  }\n  else {\n    var a, b;\n\n    if (sliderValue <= 50)\n    {\n      a = 9.0 * defaultValue / 500.0;\n      b = defaultValue / 10.0;\n    }\n    else\n    {\n      a = 9.0 * defaultValue / 50.0;\n      b = -8 * defaultValue;\n    }\n\n    return (a * sliderValue + b);\n  }\n};\n\n/**\n * This method finds and returns the center of the given nodes, assuming\n * that the given nodes form a tree in themselves.\n */\nLayout.findCenterOfTree = function (nodes)\n{\n  var list = [];\n  list = list.concat(nodes);\n\n  var removedNodes = [];\n  var remainingDegrees = new HashMap();\n  var foundCenter = false;\n  var centerNode = null;\n\n  if (list.length == 1 || list.length == 2)\n  {\n    foundCenter = true;\n    centerNode = list[0];\n  }\n\n  for (var i = 0; i < list.length; i++)\n  {\n    var node = list[i];\n    var degree = node.getNeighborsList().size();\n    remainingDegrees.put(node, node.getNeighborsList().size());\n\n    if (degree == 1)\n    {\n      removedNodes.push(node);\n    }\n  }\n\n  var tempList = [];\n  tempList = tempList.concat(removedNodes);\n\n  while (!foundCenter)\n  {\n    var tempList2 = [];\n    tempList2 = tempList2.concat(tempList);\n    tempList = [];\n\n    for (var i = 0; i < list.length; i++)\n    {\n      var node = list[i];\n\n      var index = list.indexOf(node);\n      if (index >= 0) {\n        list.splice(index, 1);\n      }\n\n      var neighbours = node.getNeighborsList();\n\n      for (var j in neighbours.set)\n      {\n        var neighbour = neighbours.set[j];\n        if (removedNodes.indexOf(neighbour) < 0)\n        {\n          var otherDegree = remainingDegrees.get(neighbour);\n          var newDegree = otherDegree - 1;\n\n          if (newDegree == 1)\n          {\n            tempList.push(neighbour);\n          }\n\n          remainingDegrees.put(neighbour, newDegree);\n        }\n      }\n    }\n\n    removedNodes = removedNodes.concat(tempList);\n\n    if (list.length == 1 || list.length == 2)\n    {\n      foundCenter = true;\n      centerNode = list[0];\n    }\n  }\n\n  return centerNode;\n};\n\n/**\n * During the coarsening process, this layout may be referenced by two graph managers\n * this setter function grants access to change the currently being used graph manager\n */\nLayout.prototype.setGraphManager = function (gm)\n{\n  this.graphManager = gm;\n};\n\nmodule.exports = Layout;\n","'use strict';\n\n// registers the extension on a cytoscape lib ref\nvar getLayout = require('./Layout');\n\nvar register = function( cytoscape ){\n  var Layout = getLayout( cytoscape );\n\n  cytoscape('layout', 'cose-bilkent', Layout);\n};\n\n// auto reg for globals\nif( typeof cytoscape !== 'undefined' ){\n  register( cytoscape );\n}\n\nmodule.exports = register;\n","var UniqueIDGeneretor = require('./UniqueIDGeneretor');\n\nfunction HashMap() {\n  this.map = {};\n  this.keys = [];\n}\n\nHashMap.prototype.put = function (key, value) {\n  var theId = UniqueIDGeneretor.createID(key);\n  if (!this.contains(theId)) {\n    this.map[theId] = value;\n    this.keys.push(key);\n  }\n};\n\nHashMap.prototype.contains = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[key] != null;\n};\n\nHashMap.prototype.get = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[theId];\n};\n\nHashMap.prototype.keySet = function () {\n  return this.keys;\n};\n\nmodule.exports = HashMap;\n","function RandomSeed() {\n}\nRandomSeed.seed = 1;\nRandomSeed.x = 0;\n\nRandomSeed.nextDouble = function () {\n  RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n  return RandomSeed.x - Math.floor(RandomSeed.x);\n};\n\nmodule.exports = RandomSeed;\n","var Layout = require('./Layout');\nvar FDLayoutConstants = require('./FDLayoutConstants');\nvar LayoutConstants = require('./LayoutConstants');\nvar IGeometry = require('./IGeometry');\nvar IMath = require('./IMath');\n\nfunction FDLayout() {\n  Layout.call(this);\n\n  this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n  this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n  this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n  this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n  this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n  this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n  this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n  this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n  this.displacementThresholdPerNode = (3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH) / 100;\n  this.coolingFactor = 1.0;\n  this.initialCoolingFactor = 1.0;\n  this.totalDisplacement = 0.0;\n  this.oldTotalDisplacement = 0.0;\n  this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n}\n\nFDLayout.prototype = Object.create(Layout.prototype);\n\nfor (var prop in Layout) {\n  FDLayout[prop] = Layout[prop];\n}\n\nFDLayout.prototype.initParameters = function () {\n  Layout.prototype.initParameters.call(this, arguments);\n\n  if (this.layoutQuality == LayoutConstants.DRAFT_QUALITY)\n  {\n    this.displacementThresholdPerNode += 0.30;\n    this.maxIterations *= 0.8;\n  }\n  else if (this.layoutQuality == LayoutConstants.PROOF_QUALITY)\n  {\n    this.displacementThresholdPerNode -= 0.30;\n    this.maxIterations *= 1.2;\n  }\n\n  this.totalIterations = 0;\n  this.notAnimatedIterations = 0;\n\n//    this.useFRGridVariant = layoutOptionsPack.smartRepulsionRangeCalc;\n};\n\nFDLayout.prototype.calcIdealEdgeLengths = function () {\n  var edge;\n  var lcaDepth;\n  var source;\n  var target;\n  var sizeOfSourceInLca;\n  var sizeOfTargetInLca;\n\n  var allEdges = this.getGraphManager().getAllEdges();\n  for (var i = 0; i < allEdges.length; i++)\n  {\n    edge = allEdges[i];\n\n    edge.idealLength = this.idealEdgeLength;\n\n    if (edge.isInterGraph)\n    {\n      source = edge.getSource();\n      target = edge.getTarget();\n\n      sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n      sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n      if (this.useSmartIdealEdgeLengthCalculation)\n      {\n        edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca -\n                2 * LayoutConstants.SIMPLE_NODE_SIZE;\n      }\n\n      lcaDepth = edge.getLca().getInclusionTreeDepth();\n\n      edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH *\n              FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR *\n              (source.getInclusionTreeDepth() +\n                      target.getInclusionTreeDepth() - 2 * lcaDepth);\n    }\n  }\n};\n\nFDLayout.prototype.initSpringEmbedder = function () {\n\n  if (this.incremental)\n  {\n    this.coolingFactor = 0.8;\n    this.initialCoolingFactor = 0.8;\n    this.maxNodeDisplacement =\n            FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n  }\n  else\n  {\n    this.coolingFactor = 1.0;\n    this.initialCoolingFactor = 1.0;\n    this.maxNodeDisplacement =\n            FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n  }\n\n  this.maxIterations =\n          Math.max(this.getAllNodes().length * 5, this.maxIterations);\n\n  this.totalDisplacementThreshold =\n          this.displacementThresholdPerNode * this.getAllNodes().length;\n\n  this.repulsionRange = this.calcRepulsionRange();\n};\n\nFDLayout.prototype.calcSpringForces = function () {\n  var lEdges = this.getAllEdges();\n  var edge;\n\n  for (var i = 0; i < lEdges.length; i++)\n  {\n    edge = lEdges[i];\n\n    this.calcSpringForce(edge, edge.idealLength);\n  }\n};\n\nFDLayout.prototype.calcRepulsionForces = function () {\n  var i, j;\n  var nodeA, nodeB;\n  var lNodes = this.getAllNodes();\n\n  for (i = 0; i < lNodes.length; i++)\n  {\n    nodeA = lNodes[i];\n\n    for (j = i + 1; j < lNodes.length; j++)\n    {\n      nodeB = lNodes[j];\n\n      // If both nodes are not members of the same graph, skip.\n      if (nodeA.getOwner() != nodeB.getOwner())\n      {\n        continue;\n      }\n\n      this.calcRepulsionForce(nodeA, nodeB);\n    }\n  }\n};\n\nFDLayout.prototype.calcGravitationalForces = function () {\n  var node;\n  var lNodes = this.getAllNodesToApplyGravitation();\n\n  for (var i = 0; i < lNodes.length; i++)\n  {\n    node = lNodes[i];\n    this.calcGravitationalForce(node);\n  }\n};\n\nFDLayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  for (var i = 0; i < lNodes.length; i++)\n  {\n    node = lNodes[i];\n    node.move();\n  }\n}\n\nFDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n  var sourceNode = edge.getSource();\n  var targetNode = edge.getTarget();\n\n  var length;\n  var springForce;\n  var springForceX;\n  var springForceY;\n\n  // Update edge length\n  if (this.uniformLeafNodeSizes &&\n          sourceNode.getChild() == null && targetNode.getChild() == null)\n  {\n    edge.updateLengthSimple();\n  }\n  else\n  {\n    edge.updateLength();\n\n    if (edge.isOverlapingSourceAndTarget)\n    {\n      return;\n    }\n  }\n\n  length = edge.getLength();\n\n  // Calculate spring forces\n  springForce = this.springConstant * (length - idealLength);\n\n  // Project force onto x and y axes\n  springForceX = springForce * (edge.lengthX / length);\n  springForceY = springForce * (edge.lengthY / length);\n\n  // Apply forces on the end nodes\n  sourceNode.springForceX += springForceX;\n  sourceNode.springForceY += springForceY;\n  targetNode.springForceX -= springForceX;\n  targetNode.springForceY -= springForceY;\n};\n\nFDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n  var rectA = nodeA.getRect();\n  var rectB = nodeB.getRect();\n  var overlapAmount = new Array(2);\n  var clipPoints = new Array(4);\n  var distanceX;\n  var distanceY;\n  var distanceSquared;\n  var distance;\n  var repulsionForce;\n  var repulsionForceX;\n  var repulsionForceY;\n\n  if (rectA.intersects(rectB))// two nodes overlap\n  {\n    // calculate separation amount in x and y directions\n    IGeometry.calcSeparationAmount(rectA,\n            rectB,\n            overlapAmount,\n            FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n\n    repulsionForceX = overlapAmount[0];\n    repulsionForceY = overlapAmount[1];\n  }\n  else// no overlap\n  {\n    // calculate distance\n\n    if (this.uniformLeafNodeSizes &&\n            nodeA.getChild() == null && nodeB.getChild() == null)// simply base repulsion on distance of node centers\n    {\n      distanceX = rectB.getCenterX() - rectA.getCenterX();\n      distanceY = rectB.getCenterY() - rectA.getCenterY();\n    }\n    else// use clipping points\n    {\n      IGeometry.getIntersection(rectA, rectB, clipPoints);\n\n      distanceX = clipPoints[2] - clipPoints[0];\n      distanceY = clipPoints[3] - clipPoints[1];\n    }\n\n    // No repulsion range. FR grid variant should take care of this.\n    if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST)\n    {\n      distanceX = IMath.sign(distanceX) *\n              FDLayoutConstants.MIN_REPULSION_DIST;\n    }\n\n    if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST)\n    {\n      distanceY = IMath.sign(distanceY) *\n              FDLayoutConstants.MIN_REPULSION_DIST;\n    }\n\n    distanceSquared = distanceX * distanceX + distanceY * distanceY;\n    distance = Math.sqrt(distanceSquared);\n\n    repulsionForce = this.repulsionConstant / distanceSquared;\n\n    // Project force onto x and y axes\n    repulsionForceX = repulsionForce * distanceX / distance;\n    repulsionForceY = repulsionForce * distanceY / distance;\n  }\n\n  // Apply forces on the two nodes\n  nodeA.repulsionForceX -= repulsionForceX;\n  nodeA.repulsionForceY -= repulsionForceY;\n  nodeB.repulsionForceX += repulsionForceX;\n  nodeB.repulsionForceY += repulsionForceY;\n};\n\nFDLayout.prototype.calcGravitationalForce = function (node) {\n  var ownerGraph;\n  var ownerCenterX;\n  var ownerCenterY;\n  var distanceX;\n  var distanceY;\n  var absDistanceX;\n  var absDistanceY;\n  var estimatedSize;\n  ownerGraph = node.getOwner();\n\n  ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n  ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n  distanceX = node.getCenterX() - ownerCenterX;\n  distanceY = node.getCenterY() - ownerCenterY;\n  absDistanceX = Math.abs(distanceX);\n  absDistanceY = Math.abs(distanceY);\n\n  if (node.getOwner() == this.graphManager.getRoot())// in the root graph\n  {\n    Math.floor(80);\n    estimatedSize = Math.floor(ownerGraph.getEstimatedSize() *\n            this.gravityRangeFactor);\n\n    if (absDistanceX > estimatedSize || absDistanceY > estimatedSize)\n    {\n      node.gravitationForceX = -this.gravityConstant * distanceX;\n      node.gravitationForceY = -this.gravityConstant * distanceY;\n    }\n  }\n  else// inside a compound\n  {\n    estimatedSize = Math.floor((ownerGraph.getEstimatedSize() *\n            this.compoundGravityRangeFactor));\n\n    if (absDistanceX > estimatedSize || absDistanceY > estimatedSize)\n    {\n      node.gravitationForceX = -this.gravityConstant * distanceX *\n              this.compoundGravityConstant;\n      node.gravitationForceY = -this.gravityConstant * distanceY *\n              this.compoundGravityConstant;\n    }\n  }\n};\n\nFDLayout.prototype.isConverged = function () {\n  var converged;\n  var oscilating = false;\n\n  if (this.totalIterations > this.maxIterations / 3)\n  {\n    oscilating =\n            Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n  }\n\n  converged = this.totalDisplacement < this.totalDisplacementThreshold;\n\n  this.oldTotalDisplacement = this.totalDisplacement;\n\n  return converged || oscilating;\n};\n\nFDLayout.prototype.animate = function () {\n  if (this.animationDuringLayout && !this.isSubLayout)\n  {\n    if (this.notAnimatedIterations == this.animationPeriod)\n    {\n      this.update();\n      this.notAnimatedIterations = 0;\n    }\n    else\n    {\n      this.notAnimatedIterations++;\n    }\n  }\n};\n\nFDLayout.prototype.calcRepulsionRange = function () {\n  return 0.0;\n};\n\nmodule.exports = FDLayout;\n","var LEdge = require('./LEdge');\nvar FDLayoutConstants = require('./FDLayoutConstants');\n\nfunction FDLayoutEdge(source, target, vEdge) {\n  LEdge.call(this, source, target, vEdge);\n  this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n}\n\nFDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\nfor (var prop in LEdge) {\n  FDLayoutEdge[prop] = LEdge[prop];\n}\n\nmodule.exports = FDLayoutEdge;\n","var LNode = require('./LNode');\n\nfunction FDLayoutNode(gm, loc, size, vNode) {\n  // alternative constructor is handled inside LNode\n  LNode.call(this, gm, loc, size, vNode);\n  //Spring, repulsion and gravitational forces acting on this node\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  //Amount by which this node is to be moved in this iteration\n  this.displacementX = 0;\n  this.displacementY = 0;\n\n  //Start and finish grid coordinates that this node is fallen into\n  this.startX = 0;\n  this.finishX = 0;\n  this.startY = 0;\n  this.finishY = 0;\n\n  //Geometric neighbors of this node\n  this.surrounding = [];\n}\n\nFDLayoutNode.prototype = Object.create(LNode.prototype);\n\nfor (var prop in LNode) {\n  FDLayoutNode[prop] = LNode[prop];\n}\n\nFDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY)\n{\n  this.startX = _startX;\n  this.finishX = _finishX;\n  this.startY = _startY;\n  this.finishY = _finishY;\n\n};\n\nmodule.exports = FDLayoutNode;\n","var FDLayoutConstants = require('./FDLayoutConstants');\n\nfunction CoSEConstants() {\n}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\n\nmodule.exports = CoSEConstants;\n","var FDLayoutEdge = require('./FDLayoutEdge');\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge\n","var LGraph = require('./LGraph');\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n","var LGraphManager = require('./LGraphManager');\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n","var FDLayoutNode = require('./FDLayoutNode');\nvar IMath = require('./IMath');\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.move = function ()\n{\n  var layout = this.graphManager.getLayout();\n  this.displacementX = layout.coolingFactor *\n          (this.springForceX + this.repulsionForceX + this.gravitationForceX);\n  this.displacementY = layout.coolingFactor *\n          (this.springForceY + this.repulsionForceY + this.gravitationForceY);\n\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement)\n  {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement *\n            IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement)\n  {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement *\n            IMath.sign(this.displacementY);\n  }\n\n  // a simple node, just move it\n  if (this.child == null)\n  {\n    this.moveBy(this.displacementX, this.displacementY);\n  }\n  // an empty compound node, again just move it\n  else if (this.child.getNodes().length == 0)\n  {\n    this.moveBy(this.displacementX, this.displacementY);\n  }\n  // non-empty compound node, propogate movement to children as well\n  else\n  {\n    this.propogateDisplacementToChildren(this.displacementX,\n            this.displacementY);\n  }\n\n  layout.totalDisplacement +=\n          Math.abs(this.displacementX) + Math.abs(this.displacementY);\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY)\n{\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++)\n  {\n    node = nodes[i];\n    if (node.getChild() == null)\n    {\n      node.moveBy(dX, dY);\n      node.displacementX += dX;\n      node.displacementY += dY;\n    }\n    else\n    {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.setPred1 = function (pred1)\n{\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function ()\n{\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function ()\n{\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next)\n{\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function ()\n{\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed)\n{\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function ()\n{\n  return processed;\n};\n\nmodule.exports = CoSENode;\n","'use strict';\n\nvar DimensionD = require('./DimensionD');\nvar HashMap = require('./HashMap');\nvar HashSet = require('./HashSet');\nvar IGeometry = require('./IGeometry');\nvar IMath = require('./IMath');\nvar Integer = require('./Integer');\nvar Point = require('./Point');\nvar PointD = require('./PointD');\nvar RandomSeed = require('./RandomSeed');\nvar RectangleD = require('./RectangleD');\nvar Transform = require('./Transform');\nvar UniqueIDGeneretor = require('./UniqueIDGeneretor');\nvar LGraphObject = require('./LGraphObject');\nvar LGraph = require('./LGraph');\nvar LEdge = require('./LEdge');\nvar LGraphManager = require('./LGraphManager');\nvar LNode = require('./LNode');\nvar Layout = require('./Layout');\nvar LayoutConstants = require('./LayoutConstants');\nvar FDLayout = require('./FDLayout');\nvar FDLayoutConstants = require('./FDLayoutConstants');\nvar FDLayoutEdge = require('./FDLayoutEdge');\nvar FDLayoutNode = require('./FDLayoutNode');\nvar CoSEConstants = require('./CoSEConstants');\nvar CoSEEdge = require('./CoSEEdge');\nvar CoSEGraph = require('./CoSEGraph');\nvar CoSEGraphManager = require('./CoSEGraphManager');\nvar CoSELayout = require('./CoSELayout');\nvar CoSENode = require('./CoSENode');\nvar TilingExtension = require('./TilingExtension');\n\nvar defaults = {\n  // Called on `layoutready`\n  ready: function () {\n  },\n  // Called on `layoutstop`\n  stop: function () {\n  },\n  // number of ticks per frame; higher is faster but more jerky\n  refresh: 30,\n  // Whether to fit the network view after when done\n  fit: true,\n  // Padding on fit\n  padding: 10,\n  // Padding for compounds\n  paddingCompound: 15,\n  // Whether to enable incremental mode\n  randomize: true,\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: 4500,\n  // Ideal edge (non nested) length\n  idealEdgeLength: 50,\n  // Divisor to compute edge forces\n  edgeElasticity: 0.45,\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // Type of layout animation. The option set is {'during', 'end', false}\n  animate: 'end',\n  // Duration for animate:end\n  animationDuration: 500,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8\n};\n\nfunction extend(defaults, options) {\n  var obj = {};\n\n  for (var i in defaults) {\n    obj[i] = defaults[i];\n  }\n\n  for (var i in options) {\n    obj[i] = options[i];\n  }\n\n  return obj;\n};\n\nfunction _CoSELayout(_options) {\n  TilingExtension(this); // Extend this instance with tiling functions\n  this.options = extend(defaults, _options);\n  getUserOptions(this.options);\n}\n\nvar getUserOptions = function (options) {\n  if (options.nodeRepulsion != null)\n    CoSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;\n  if (options.idealEdgeLength != null)\n    CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n  if (options.edgeElasticity != null)\n    CoSEConstants.DEFAULT_SPRING_STRENGTH = FDLayoutConstants.DEFAULT_SPRING_STRENGTH = options.edgeElasticity;\n  if (options.nestingFactor != null)\n    CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null)\n    CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null)\n    CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.paddingCompound != null)\n    CoSEConstants.DEFAULT_GRAPH_MARGIN = FDLayoutConstants.DEFAULT_GRAPH_MARGIN = LayoutConstants.DEFAULT_GRAPH_MARGIN = options.paddingCompound;\n  if (options.gravityRange != null)\n    CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if(options.gravityCompound != null)\n    CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if(options.gravityRangeCompound != null)\n    CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL =\n          !(options.randomize);\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = options.animate;\n};\n\n_CoSELayout.prototype.run = function () {\n  var ready;\n  var frameId;\n  var options = this.options;\n  var idToLNode = this.idToLNode = {};\n  var layout = this.layout = new CoSELayout();\n  var self = this;\n  \n  this.cy = this.options.cy;\n\n  this.cy.trigger({ type: 'layoutstart', layout: this });\n\n  var gm = layout.newGraphManager();\n  this.gm = gm;\n\n  var nodes = this.options.eles.nodes();\n  var edges = this.options.eles.edges();\n\n  this.root = gm.addRoot();\n\n  if (!this.options.tile) {\n    this.processChildrenList(this.root, this.getTopMostNodes(nodes), layout);\n  }\n  else {\n    this.preLayout();\n  }\n\n\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    var sourceNode = this.idToLNode[edge.data(\"source\")];\n    var targetNode = this.idToLNode[edge.data(\"target\")];\n    var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n    e1.id = edge.id();\n  }\n  \n   var getPositions = function(ele, i){\n    if(typeof ele === \"number\") {\n      ele = i;\n    }\n    var theId = ele.data('id');\n    var lNode = self.idToLNode[theId];\n\n    return {\n      x: lNode.getRect().getCenterX(),\n      y: lNode.getRect().getCenterY()\n    };\n  };\n  \n  /*\n   * Reposition nodes in iterations animatedly\n   */\n  var iterateAnimated = function () {\n    // Thigs to perform after nodes are repositioned on screen\n    var afterReposition = function() {\n      if (options.fit) {\n        options.cy.fit(options.eles.nodes(), options.padding);\n      }\n\n      if (!ready) {\n        ready = true;\n        self.cy.one('layoutready', options.ready);\n        self.cy.trigger({type: 'layoutready', layout: self});\n      }\n    };\n    \n    var ticksPerFrame = self.options.refresh;\n    var isDone;\n\n    for( var i = 0; i < ticksPerFrame && !isDone; i++ ){\n      isDone = self.layout.tick();\n    }\n    \n    // If layout is done\n    if (isDone) {\n      if (self.options.tile) {\n        self.postLayout();\n      }\n      self.options.eles.nodes().positions(getPositions);\n      \n      afterReposition();\n      \n      // trigger layoutstop when the layout stops (e.g. finishes)\n      self.cy.one('layoutstop', self.options.stop);\n      self.cy.trigger('layoutstop');\n      self.cy.trigger({ type: 'layoutstop', layout: self });\n\n      if (frameId) {\n        cancelAnimationFrame(frameId);\n      }\n      \n      self.options.eles.nodes().removeScratch('coseBilkent');\n      ready = false;\n      return;\n    }\n    \n    var animationData = self.layout.getPositionsData(); // Get positions of layout nodes note that all nodes may not be layout nodes because of tiling\n    // Position nodes, for the nodes who are not passed to layout because of tiling return the position of their dummy compound\n    options.eles.nodes().positions(function (ele, i) {\n      if (typeof ele === \"number\") {\n        ele = i;\n      }\n      if (ele.scratch('coseBilkent') && ele.scratch('coseBilkent').dummy_parent_id) {\n        var dummyParent = ele.scratch('coseBilkent').dummy_parent_id;\n        return {\n          x: dummyParent.x,\n          y: dummyParent.y\n        };\n      }\n      var theId = ele.data('id');\n      var pNode = animationData[theId];\n      var temp = ele;\n      while (pNode == null) {\n        temp = temp.parent()[0];\n        pNode = animationData[temp.id()];\n        animationData[theId] = pNode;\n      }\n      return {\n        x: pNode.x,\n        y: pNode.y\n      };\n    });\n\n    afterReposition();\n\n    frameId = requestAnimationFrame(iterateAnimated);\n  };\n  \n  /*\n  * Listen 'layoutstarted' event and start animated iteration if animate option is 'during'\n  */\n  layout.addListener('layoutstarted', function () {\n    if (self.options.animate === 'during') {\n      frameId = requestAnimationFrame(iterateAnimated);\n    }\n  });\n  \n  layout.runLayout(); // Run cose layout\n  \n  /*\n   * If animate option is not 'during' ('end' or false) perform these here (If it is 'during' similar things are already performed)\n   */\n  if(this.options.animate !== 'during'){\n    setTimeout(function() {\n      if (self.options.tile) {\n        self.postLayout();\n      }\n      self.options.eles.nodes().not(\":parent\").layoutPositions(self, self.options, getPositions); // Use layout positions to reposition the nodes it considers the options parameter\n      self.options.eles.nodes().removeScratch('coseBilkent');\n      ready = false;\n    }, 0);\n    \n  }\n\n  return this; // chaining\n};\n\n//Get the top most ones of a list of nodes\n_CoSELayout.prototype.getTopMostNodes = function(nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n      nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n      if(typeof ele === \"number\") {\n        ele = i;\n      }\n      var parent = ele.parent()[0];\n      while(parent != null){\n        if(nodesMap[parent.id()]){\n          return false;\n        }\n        parent = parent.parent()[0];\n      }\n      return true;\n  });\n\n  return roots;\n};\n\n_CoSELayout.prototype.processChildrenList = function (parent, children, layout) {\n  var size = children.length;\n  for (var i = 0; i < size; i++) {\n    var theChild = children[i];\n    this.options.eles.nodes().length;\n    var children_of_children = theChild.children();\n    var theNode;\n\n    if (theChild.width() != null\n            && theChild.height() != null) {\n      theNode = parent.add(new CoSENode(layout.graphManager,\n              new PointD(theChild.position('x'), theChild.position('y')),\n              new DimensionD(parseFloat(theChild.width()),\n                      parseFloat(theChild.height()))));\n    }\n    else {\n      theNode = parent.add(new CoSENode(this.graphManager));\n    }\n    theNode.id = theChild.data(\"id\");\n    this.idToLNode[theChild.data(\"id\")] = theNode;\n\n    if (isNaN(theNode.rect.x)) {\n      theNode.rect.x = 0;\n    }\n\n    if (isNaN(theNode.rect.y)) {\n      theNode.rect.y = 0;\n    }\n\n    if (children_of_children != null && children_of_children.length > 0) {\n      var theNewGraph;\n      theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n      this.processChildrenList(theNewGraph, children_of_children, layout);\n    }\n  }\n};\n\n/**\n * @brief : called on continuous layouts to stop them before they finish\n */\n_CoSELayout.prototype.stop = function () {\n  this.stopped = true;\n  \n  this.trigger('layoutstop');\n\n  return this; // chaining\n};\n\nmodule.exports = function get(cytoscape) {\n  return _CoSELayout;\n};\n","function DimensionD(width, height) {\n  this.width = 0;\n  this.height = 0;\n  if (width !== null && height !== null) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nDimensionD.prototype.getWidth = function ()\n{\n  return this.width;\n};\n\nDimensionD.prototype.setWidth = function (width)\n{\n  this.width = width;\n};\n\nDimensionD.prototype.getHeight = function ()\n{\n  return this.height;\n};\n\nDimensionD.prototype.setHeight = function (height)\n{\n  this.height = height;\n};\n\nmodule.exports = DimensionD;\n","function Emitter(){\n  this.listeners = [];\n}\n\nvar p = Emitter.prototype;\n\np.addListener = function( event, callback ){\n  this.listeners.push({\n    event: event,\n    callback: callback\n  });\n};\n\np.removeListener = function( event, callback ){\n  for( var i = this.listeners.length; i >= 0; i-- ){\n    var l = this.listeners[i];\n\n    if( l.event === event && l.callback === callback ){\n      this.listeners.splice( i, 1 );\n    }\n  }\n};\n\np.emit = function( event, data ){\n  for( var i = 0; i < this.listeners.length; i++ ){\n    var l = this.listeners[i];\n\n    if( event === l.event ){\n      l.callback( data );\n    }\n  }\n};\n\nmodule.exports = Emitter;\n","var FDLayout = require('./FDLayout');\nvar CoSEGraphManager = require('./CoSEGraphManager');\nvar CoSEGraph = require('./CoSEGraph');\nvar CoSENode = require('./CoSENode');\nvar CoSEEdge = require('./CoSEEdge');\nvar CoSEConstants = require('./CoSEConstants');\nvar FDLayoutConstants = require('./FDLayoutConstants');\nvar LayoutConstants = require('./LayoutConstants');\nvar Point = require('./Point');\nvar PointD = require('./PointD');\nvar Layout = require('./Layout');\nvar Integer = require('./Integer');\nvar IGeometry = require('./IGeometry');\nvar LGraph = require('./LGraph');\nvar Transform = require('./Transform');\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10)\n    {\n      this.idealEdgeLength = 10;\n    }\n    else\n    {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation =\n            CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.springConstant =\n            FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n    this.repulsionConstant =\n            FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n    this.gravityConstant =\n            FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant =\n            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor =\n            FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor =\n            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n  }\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded)\n  {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.calculateNodesToApplyGravitationTo();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n  if (!this.incremental)\n  {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0)\n\n    {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else\n    {\n      this.positionNodesRandomly();\n    }\n  }\n\n  this.initSpringEmbedder();\n  this.runSpringEmbedder();\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function() {\n  this.totalIterations++;\n  \n  if (this.totalIterations === this.maxIterations) {\n    return true; // Layout is not ended return true\n  }\n  \n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0)\n  {\n    if (this.isConverged())\n    {\n      return true; // Layout is not ended return true\n    }\n\n    this.coolingFactor = this.initialCoolingFactor *\n            ((this.maxIterations - this.totalIterations) / this.maxIterations);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n\n  }\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces();\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n  \n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function() {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n  \n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n  \n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if ( FDLayoutConstants.ANIMATE === 'during' ) {\n    this.emit('layoutstarted');\n  }\n  else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++)\n  {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected)\n    {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  this.graphManager.setAllNodesToApplyGravitation(nodeList);\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new HashSet();\n  var i;\n  for (i = 0; i < edges.length; i++)\n  {\n    var edge = edges[i];\n\n    if (!visited.contains(edge))\n    {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target)\n      {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      }\n      else\n      {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.contains(edgeList[0]))\n        {\n          if (edgeList.length > 1)\n          {\n            var k;\n            for (k = 0; k < edgeList.length; k++)\n            {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          visited.addAll(list);\n        }\n      }\n    }\n\n    if (visited.size() == edges.length)\n    {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++)\n  {\n    if (i % numberOfColumns == 0)\n    {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0)\n      {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point =\n            CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height)\n    {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(\n          new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2,\n                  LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree),\n          CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++)\n  {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight =\n          new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = ((endAngle - startAngle) + 1) / 2;\n\n  if (halfInterval < 0)\n  {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = (nodeAngle * IGeometry.TWO_PI) / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null)\n  {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1)\n  {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null)\n  {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  }\n  else\n  {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex;\n          branchCount != childCount;\n          i = (++i) % incEdgesCount)\n  {\n    var currentNeighbor =\n            neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode)\n    {\n      continue;\n    }\n\n    var childStartAngle =\n            (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor,\n            node,\n            childStartAngle, childEndAngle,\n            distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++)\n  {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal)\n    {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return (2 * (this.level + 1) * this.idealEdgeLength);\n};\n\nmodule.exports = CoSELayout;\n","module.exports = function (instance) {\n  instance.toBeTiled = {};\n  \n  instance.getToBeTiled = function (node) {\n    var id = node.data(\"id\");\n    //firstly check the previous results\n    if (instance.toBeTiled[id] != null) {\n      return instance.toBeTiled[id];\n    }\n\n    //only compound nodes are to be tiled\n    var children = node.children();\n    if (children == null || children.length == 0) {\n      instance.toBeTiled[id] = false;\n      return false;\n    }\n\n    //a compound node is not to be tiled if all of its compound children are not to be tiled\n    for (var i = 0; i < children.length; i++) {\n      var theChild = children[i];\n\n      if (instance.getNodeDegree(theChild) > 0) {\n        instance.toBeTiled[id] = false;\n        return false;\n      }\n\n      //pass the children not having the compound structure\n      if (theChild.children() == null || theChild.children().length == 0) {\n        instance.toBeTiled[theChild.data(\"id\")] = false;\n        continue;\n      }\n\n      if (!instance.getToBeTiled(theChild)) {\n        instance.toBeTiled[id] = false;\n        return false;\n      }\n    }\n    instance.toBeTiled[id] = true;\n    return true;\n  };\n\n  instance.getNodeDegree = function (node) {\n    var id = node.id();\n    var edges = instance.options.eles.edges().filter(function (ele, i) {\n      if (typeof ele === \"number\") {\n        ele = i;\n      }\n      var source = ele.data('source');\n      var target = ele.data('target');\n      if (source != target && (source == id || target == id)) {\n        return true;\n      }\n    });\n    return edges.length;\n  };\n\n  instance.getNodeDegreeWithChildren = function (node) {\n    var degree = instance.getNodeDegree(node);\n    var children = node.children();\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      degree += instance.getNodeDegreeWithChildren(child);\n    }\n    return degree;\n  };\n\n  instance.groupZeroDegreeMembers = function () {\n    // array of [parent_id x oneDegreeNode_id]\n    var tempMemberGroups = [];\n    var memberGroups = [];\n    var self = this;\n    var parentMap = {};\n\n    for (var i = 0; i < instance.options.eles.nodes().length; i++) {\n      parentMap[instance.options.eles.nodes()[i].id()] = true;\n    }\n\n    // Find all zero degree nodes which aren't covered by a compound\n    var zeroDegree = instance.options.eles.nodes().filter(function (ele, i) {\n      if (typeof ele === \"number\") {\n        ele = i;\n      }\n      var pid = ele.data('parent');\n      if (pid != undefined && !parentMap[pid]) {\n        pid = undefined;\n      }\n\n      if (self.getNodeDegreeWithChildren(ele) == 0 && (pid == undefined || (pid != undefined && !self.getToBeTiled(ele.parent()[0]))))\n        return true;\n      else\n        return false;\n    });\n\n    // Create a map of parent node and its zero degree members\n    for (var i = 0; i < zeroDegree.length; i++)\n    {\n      var node = zeroDegree[i];\n      var p_id = node.parent().id();\n\n      if (p_id != undefined && !parentMap[p_id]) {\n        p_id = undefined;\n      }\n\n      if (typeof tempMemberGroups[p_id] === \"undefined\")\n        tempMemberGroups[p_id] = [];\n\n      tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node);\n    }\n\n    // If there are at least two nodes at a level, create a dummy compound for them\n    for (var p_id in tempMemberGroups) {\n      if (tempMemberGroups[p_id].length > 1) {\n        var dummyCompoundId = \"DummyCompound_\" + p_id;\n        memberGroups[dummyCompoundId] = tempMemberGroups[p_id];\n\n        // Create a dummy compound\n        if (instance.options.cy.getElementById(dummyCompoundId).empty()) {\n          instance.options.cy.add({\n            group: \"nodes\",\n            data: {id: dummyCompoundId, parent: p_id\n            }\n          });\n\n          var dummy = instance.options.cy.nodes()[instance.options.cy.nodes().length - 1];\n          instance.options.eles = instance.options.eles.union(dummy);\n          dummy.hide();\n\n          for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n            if (i == 0) {\n              dummy.scratch('coseBilkent', {tempchildren: []});\n            }\n            var node = tempMemberGroups[p_id][i];\n            var scratchObj = node.scratch('coseBilkent');\n            if (!scratchObj) {\n              scratchObj = {};\n              node.scratch('coseBilkent', scratchObj);\n            }\n            scratchObj['dummy_parent_id'] = dummyCompoundId;\n            instance.options.cy.add({\n              group: \"nodes\",\n              data: {parent: dummyCompoundId, width: node.width(), height: node.height()\n              }\n            });\n            var tempchild = instance.options.cy.nodes()[instance.options.cy.nodes().length - 1];\n            tempchild.hide();\n            tempchild.css('width', tempchild.data('width'));\n            tempchild.css('height', tempchild.data('height'));\n            tempchild.width();\n            dummy.scratch('coseBilkent').tempchildren.push(tempchild);\n          }\n        }\n      }\n    }\n\n    return memberGroups;\n  };\n\n  instance.performDFSOnCompounds = function (options) {\n    var compoundOrder = [];\n\n    var roots = instance.getTopMostNodes(instance.options.eles.nodes());\n    instance.fillCompexOrderByDFS(compoundOrder, roots);\n\n    return compoundOrder;\n  };\n\n  instance.fillCompexOrderByDFS = function (compoundOrder, children) {\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      instance.fillCompexOrderByDFS(compoundOrder, child.children());\n      if (instance.getToBeTiled(child)) {\n        compoundOrder.push(child);\n      }\n    }\n  };\n\n  instance.clearCompounds = function () {\n    var childGraphMap = [];\n\n    // Get compound ordering by finding the inner one first\n    var compoundOrder = instance.performDFSOnCompounds(instance.options);\n    instance.compoundOrder = compoundOrder;\n    instance.processChildrenList(instance.root, instance.getTopMostNodes(instance.options.eles.nodes()), instance.layout);\n\n    for (var i = 0; i < compoundOrder.length; i++) {\n      // find the corresponding layout node\n      var lCompoundNode = instance.idToLNode[compoundOrder[i].id()];\n\n      childGraphMap[compoundOrder[i].id()] = compoundOrder[i].children();\n\n      // Remove children of compounds\n      lCompoundNode.child = null;\n    }\n\n    // Tile the removed children\n    var tiledMemberPack = instance.tileCompoundMembers(childGraphMap);\n\n    return tiledMemberPack;\n  };\n\n  instance.clearZeroDegreeMembers = function (memberGroups) {\n    var tiledZeroDegreePack = [];\n\n    for (var id in memberGroups) {\n      var compoundNode = instance.idToLNode[id];\n\n      tiledZeroDegreePack[id] = instance.tileNodes(memberGroups[id]);\n\n      // Set the width and height of the dummy compound as calculated\n      compoundNode.rect.width = tiledZeroDegreePack[id].width;\n      compoundNode.rect.height = tiledZeroDegreePack[id].height;\n    }\n    return tiledZeroDegreePack;\n  };\n\n  instance.repopulateCompounds = function (tiledMemberPack) {\n    for (var i = instance.compoundOrder.length - 1; i >= 0; i--) {\n      var id = instance.compoundOrder[i].id();\n      var lCompoundNode = instance.idToLNode[id];\n      var horizontalMargin = parseInt(instance.compoundOrder[i].css('padding-left'));\n      var verticalMargin = parseInt(instance.compoundOrder[i].css('padding-top'));\n\n      instance.adjustLocations(tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n    }\n  };\n\n  instance.repopulateZeroDegreeMembers = function (tiledPack) {\n    for (var i in tiledPack) {\n      var compound = instance.cy.getElementById(i);\n      var compoundNode = instance.idToLNode[i];\n      var horizontalMargin = parseInt(compound.css('padding-left'));\n      var verticalMargin = parseInt(compound.css('padding-top'));\n\n      // Adjust the positions of nodes wrt its compound\n      instance.adjustLocations(tiledPack[i], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n\n      var tempchildren = compound.scratch('coseBilkent').tempchildren;\n      for (var i = 0; i < tempchildren.length; i++) {\n        tempchildren[i].remove();\n      }\n\n      // Remove the dummy compound\n      compound.remove();\n    }\n  };\n\n  /**\n   * This method places each zero degree member wrt given (x,y) coordinates (top left).\n   */\n  instance.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n    x += compoundHorizontalMargin;\n    y += compoundVerticalMargin;\n\n    var left = x;\n\n    for (var i = 0; i < organization.rows.length; i++) {\n      var row = organization.rows[i];\n      x = left;\n      var maxHeight = 0;\n\n      for (var j = 0; j < row.length; j++) {\n        var lnode = row[j];\n        var node = instance.cy.getElementById(lnode.id);\n\n        lnode.rect.x = x;// + lnode.rect.width / 2;\n        lnode.rect.y = y;// + lnode.rect.height / 2;\n\n        x += lnode.rect.width + organization.horizontalPadding;\n\n        if (lnode.rect.height > maxHeight)\n          maxHeight = lnode.rect.height;\n      }\n\n      y += maxHeight + organization.verticalPadding;\n    }\n  };\n\n  instance.tileCompoundMembers = function (childGraphMap) {\n    var tiledMemberPack = [];\n\n    for (var id in childGraphMap) {\n      // Access layoutInfo nodes to set the width and height of compounds\n      var compoundNode = instance.idToLNode[id];\n\n      tiledMemberPack[id] = instance.tileNodes(childGraphMap[id]);\n\n      compoundNode.rect.width = tiledMemberPack[id].width + 20;\n      compoundNode.rect.height = tiledMemberPack[id].height + 20;\n    }\n\n    return tiledMemberPack;\n  };\n\n  instance.tileNodes = function (nodes) {\n    var self = this;\n    var verticalPadding = typeof self.options.tilingPaddingVertical === 'function' ? self.options.tilingPaddingVertical.call() : self.options.tilingPaddingVertical;\n    var horizontalPadding = typeof self.options.tilingPaddingHorizontal === 'function' ? self.options.tilingPaddingHorizontal.call() : self.options.tilingPaddingHorizontal;\n    var organization = {\n      rows: [],\n      rowWidth: [],\n      rowHeight: [],\n      width: 20,\n      height: 20,\n      verticalPadding: verticalPadding,\n      horizontalPadding: horizontalPadding\n    };\n\n    var layoutNodes = [];\n\n    // Get layout nodes\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var lNode = instance.idToLNode[node.id()];\n\n      if (!node.scratch('coseBilkent') || !node.scratch('coseBilkent').dummy_parent_id) {\n        var owner = lNode.owner;\n        owner.remove(lNode);\n\n        instance.gm.resetAllNodes();\n        instance.gm.getAllNodes();\n      }\n\n      layoutNodes.push(lNode);\n    }\n\n    // Sort the nodes in ascending order of their areas\n    layoutNodes.sort(function (n1, n2) {\n      if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height)\n        return -1;\n      if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height)\n        return 1;\n      return 0;\n    });\n\n    // Create the organization -> tile members\n    for (var i = 0; i < layoutNodes.length; i++) {\n      var lNode = layoutNodes[i];\n\n      var cyNode = instance.cy.getElementById(lNode.id).parent()[0];\n      var minWidth = 0;\n      if (cyNode) {\n        minWidth = parseInt(cyNode.css('padding-left')) + parseInt(cyNode.css('padding-right'));\n      }\n\n      if (organization.rows.length == 0) {\n        instance.insertNodeToRow(organization, lNode, 0, minWidth);\n      }\n      else if (instance.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n        instance.insertNodeToRow(organization, lNode, instance.getShortestRowIndex(organization), minWidth);\n      }\n      else {\n        instance.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n      }\n\n      instance.shiftToLastRow(organization);\n    }\n\n    return organization;\n  };\n\n  instance.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n    var minCompoundSize = minWidth;\n\n    // Add new row if needed\n    if (rowIndex == organization.rows.length) {\n      var secondDimension = [];\n\n      organization.rows.push(secondDimension);\n      organization.rowWidth.push(minCompoundSize);\n      organization.rowHeight.push(0);\n    }\n\n    // Update row width\n    var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n    if (organization.rows[rowIndex].length > 0) {\n      w += organization.horizontalPadding;\n    }\n\n    organization.rowWidth[rowIndex] = w;\n    // Update compound width\n    if (organization.width < w) {\n      organization.width = w;\n    }\n\n    // Update height\n    var h = node.rect.height;\n    if (rowIndex > 0)\n      h += organization.verticalPadding;\n\n    var extraHeight = 0;\n    if (h > organization.rowHeight[rowIndex]) {\n      extraHeight = organization.rowHeight[rowIndex];\n      organization.rowHeight[rowIndex] = h;\n      extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n    }\n\n    organization.height += extraHeight;\n\n    // Insert node\n    organization.rows[rowIndex].push(node);\n  };\n\n//Scans the rows of an organization and returns the one with the min width\n  instance.getShortestRowIndex = function (organization) {\n    var r = -1;\n    var min = Number.MAX_VALUE;\n\n    for (var i = 0; i < organization.rows.length; i++) {\n      if (organization.rowWidth[i] < min) {\n        r = i;\n        min = organization.rowWidth[i];\n      }\n    }\n    return r;\n  };\n\n//Scans the rows of an organization and returns the one with the max width\n  instance.getLongestRowIndex = function (organization) {\n    var r = -1;\n    var max = Number.MIN_VALUE;\n\n    for (var i = 0; i < organization.rows.length; i++) {\n\n      if (organization.rowWidth[i] > max) {\n        r = i;\n        max = organization.rowWidth[i];\n      }\n    }\n\n    return r;\n  };\n\n  /**\n   * This method checks whether adding extra width to the organization violates\n   * the aspect ratio(1) or not.\n   */\n  instance.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n    var sri = instance.getShortestRowIndex(organization);\n\n    if (sri < 0) {\n      return true;\n    }\n\n    var min = organization.rowWidth[sri];\n\n    if (min + organization.horizontalPadding + extraWidth <= organization.width)\n      return true;\n\n    var hDiff = 0;\n\n    // Adding to an existing row\n    if (organization.rowHeight[sri] < extraHeight) {\n      if (sri > 0)\n        hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n    }\n\n    var add_to_row_ratio;\n    if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n      add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n    } else {\n      add_to_row_ratio = (organization.height + hDiff) / organization.width;\n    }\n\n    // Adding a new row for this node\n    hDiff = extraHeight + organization.verticalPadding;\n    var add_new_row_ratio;\n    if (organization.width < extraWidth) {\n      add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n    } else {\n      add_new_row_ratio = (organization.height + hDiff) / organization.width;\n    }\n\n    if (add_new_row_ratio < 1)\n      add_new_row_ratio = 1 / add_new_row_ratio;\n\n    if (add_to_row_ratio < 1)\n      add_to_row_ratio = 1 / add_to_row_ratio;\n\n    return add_to_row_ratio < add_new_row_ratio;\n  };\n\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\n  instance.shiftToLastRow = function (organization) {\n    var longest = instance.getLongestRowIndex(organization);\n    var last = organization.rowWidth.length - 1;\n    var row = organization.rows[longest];\n    var node = row[row.length - 1];\n\n    var diff = node.width + organization.horizontalPadding;\n\n    // Check if there is enough space on the last row\n    if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n      // Remove the last element of the longest row\n      row.splice(-1, 1);\n\n      // Push it to the last row\n      organization.rows[last].push(node);\n\n      organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n      organization.rowWidth[last] = organization.rowWidth[last] + diff;\n      organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n      // Update heights of the organization\n      var maxHeight = Number.MIN_VALUE;\n      for (var i = 0; i < row.length; i++) {\n        if (row[i].height > maxHeight)\n          maxHeight = row[i].height;\n      }\n      if (longest > 0)\n        maxHeight += organization.verticalPadding;\n\n      var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n      organization.rowHeight[longest] = maxHeight;\n      if (organization.rowHeight[last] < node.height + organization.verticalPadding)\n        organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n      var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n      organization.height += (finalTotal - prevTotal);\n\n      instance.shiftToLastRow(organization);\n    }\n  };\n  \n  instance.preLayout = function() {\n    // Find zero degree nodes and create a compound for each level\n    var memberGroups = instance.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    instance.tiledMemberPack = instance.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    instance.tiledZeroDegreeNodes = instance.clearZeroDegreeMembers(memberGroups);\n  };\n  \n  instance.postLayout = function() {\n    var nodes = instance.options.eles.nodes();\n    //fill the toBeTiled map\n    for (var i = 0; i < nodes.length; i++) {\n      instance.getToBeTiled(nodes[i]);\n    }\n\n    // Repopulate members\n    instance.repopulateZeroDegreeMembers(instance.tiledZeroDegreeNodes);\n\n    instance.repopulateCompounds(instance.tiledMemberPack);\n\n    instance.options.cy.nodes().updateCompoundBounds();\n  };\n};"],"sourceRoot":""}