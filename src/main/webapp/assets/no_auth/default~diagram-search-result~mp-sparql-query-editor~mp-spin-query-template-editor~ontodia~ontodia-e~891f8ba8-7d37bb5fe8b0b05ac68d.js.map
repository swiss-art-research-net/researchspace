{"version":3,"sources":["webpack:///./src/main/web/components/forms/inputs/MultipleValuesInput.ts"],"names":["dataState","DataState","Ready","assertStatic","constructor","getHandlerOrDefault","componentType","handlerProps","makeHandler","MultipleValuesInput","defaultHandler","inputKind","InputKind","MultiValuesInput","validate","values","finalize","owner","Kefir","constant","Component","props","this","definition","otherErrors","errors","filter","e","kind","ErrorKind","Input","toList","cardinalityErrors","checkCardinalityAndDuplicates","concat","FieldError","noErrors","nonEmpty","reduce","set","v","FieldValue","isComposite","CompositeValue","isPlaceholder","subject","add","Rdf","bnode","rdfNode","asRdfNode","has","push","message","value","Immutable","Set","size","minOccurs","maxOccurs","CardinalityCheckingHandler"],"mappings":"4IAmBA,QACA,QAEA,QACA,QAGA,UACA,UAgEA,6C,+CA0BA,OA1BoF,mCAIlF,8BAAAA,UAAA,WACE,OAAO,EAAAC,UAAUC,OAQZ,oBAAAC,aAAP,SAAoBC,KAIb,oBAAAC,oBAAP,SACEC,EACAC,GAEA,OAAMD,GAAiBA,EAAcE,YAG9BF,EAAcE,YAAYD,GAFxBE,oBAAoBC,gBApBR,oBAAAC,UAAY,EAAAC,UAAUC,iBAM7B,oBAAAH,eAAwC,CACtDI,SAAU,SAACC,GAAW,OAAAA,GACtBC,SAAU,SAACD,EAAQE,GAAU,OAAAC,EAAMC,SAASJ,KAgBhD,oBA1BA,CAAoF,EAAAK,WAA9D,EAAAX,sBA4BtB,iBAGE,oCAAYY,GACVC,KAAKC,WAAaF,EAAME,WAkB5B,OAfE,qCAAAT,SAAA,SAAS,G,IAAEC,EAAA,EAAAA,OACHS,EADW,EAAAC,OACUC,QAAO,SAACC,GAAM,OAAAA,EAAEC,OAAS,EAAAC,UAAUC,SAAOC,SAC/DC,EAAoBC,8BAA8BlB,EAAQO,KAAKC,YACrE,MAAO,CACLR,OAAQA,EACRU,OAAQD,EAAYU,OAAOF,KAI/B,qCAAAhB,SAAA,SACED,EACAE,GAEA,OAAOR,EAAoBC,eAAeM,SAASD,EAAQE,IAE/D,2BAtBA,GAwBA,SAAgBgB,8BACdlB,EACAQ,GAEA,IAAIE,EAAS,EAAAU,WAAWC,SAGlBC,EAAWtB,EAAOuB,QAAO,SAACC,EAAKC,GACnC,GAAI,EAAAC,WAAWC,YAAYF,IAAM,EAAAG,eAAeC,cAAcJ,EAAEK,SAG9D,OAAON,EAAIO,IAAI,EAAAC,IAAIC,SAErB,IAAMC,EAAU,EAAAR,WAAWS,UAAUV,GACrC,OAAKS,EAEMV,EAAIY,IAAIF,IACjBxB,EAASA,EAAO2B,KAAK,CACnBxB,KAAM,EAAAC,UAAUC,MAChBuB,QAAS,UAAUJ,EAAQK,MAAK,gCAE3Bf,GAEAA,EAAIO,IAAIG,GARRV,IAURgB,EAAUC,OAeb,OAbInB,EAASoB,KAAOlC,EAAWmC,YAC7BjC,EAASA,EAAO2B,KAAK,CACnBxB,KAAM,EAAAC,UAAUC,MAChBuB,QAAS,yBAAyB9B,EAAWmC,UAApC,eAAiErB,EAASoB,KAAI,eAGvFpB,EAASoB,KAAOlC,EAAWoC,YAC7BlC,EAASA,EAAO2B,KAAK,CACnBxB,KAAM,EAAAC,UAAUC,MAChBuB,QAAS,yBAAyB9B,EAAWoC,UAApC,eAAiEtB,EAASoB,KAAI,eAIpFhC,EAhEI,EAAAmC,6BAwBb","file":"default~diagram-search-result~mp-sparql-query-editor~mp-spin-query-template-editor~ontodia~ontodia-e~891f8ba8-7d37bb5fe8b0b05ac68d.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Immutable from 'immutable';\nimport * as Kefir from 'kefir';\n\nimport { Component } from 'platform/api/components';\nimport { Rdf } from 'platform/api/rdf';\n\nimport { FieldDefinition } from '../FieldDefinition';\nimport { FieldValue, EmptyValue, CompositeValue, DataState, FieldError, ErrorKind } from '../FieldValues';\nimport { InputKind } from './InputCommpons';\n\nexport interface MultipleValuesProps {\n  /** Key to associate with FieldDefinition by name */\n  for: string;\n  handler?: MultipleValuesHandler;\n  definition?: FieldDefinition;\n  dataState?: DataState;\n  defaultValue?: string;\n  defaultValues?: string[];\n\n  /**\n   * If true then default values should be always added to the object and can't be removed.\n   */\n  forceDefaults?: boolean;\n  values?: Immutable.List<FieldValue>;\n  errors?: Immutable.List<FieldError>;\n  updateValues?: (reducer: (previous: ValuesWithErrors) => ValuesWithErrors) => void;\n  /**\n   * Optional argument to prevent label and description being\n   * rendered above the value input(s) i.e. in most settings (default),\n   * default layout / rendering will be sufficient.\n   *\n   * If and only explicitly set to 'false' the header will not be rendered and\n   * the static field markup components for layouting the title and description\n   * might be used.\n   */\n  renderHeader?: boolean;\n\n  /**\n   * Overrides label from the Field Definition.\n   */\n  label?: string;\n\n  /**\n   * Can set input component into readonly mode.\n   *\n   * @default false\n   */\n  readonly?: boolean;\n}\n\nexport interface MultipleValuesHandler {\n  validate(values: ValuesWithErrors): ValuesWithErrors;\n  finalize(\n    values: Immutable.List<FieldValue>,\n    owner: EmptyValue | CompositeValue\n  ): Kefir.Property<Immutable.List<FieldValue>>;\n}\n\nexport interface MultipleValuesHandlerProps<InputProps> {\n  definition: FieldDefinition;\n  baseInputProps: InputProps;\n}\n\ninterface MultipleValuesInputStatic {\n  makeHandler(props: MultipleValuesHandlerProps<any>): MultipleValuesHandler;\n}\n\nexport type ValuesWithErrors = {\n  values: Immutable.List<FieldValue>;\n  errors: Immutable.List<FieldError>;\n};\n\nexport abstract class MultipleValuesInput<P extends MultipleValuesProps, S> extends Component<P, S> {\n\n  public static readonly inputKind = InputKind.MultiValuesInput;\n\n  dataState(): DataState {\n    return DataState.Ready;\n  }\n\n  static readonly defaultHandler: MultipleValuesHandler = {\n    validate: (values) => values,\n    finalize: (values, owner) => Kefir.constant(values),\n  };\n\n  static assertStatic(constructor: MultipleValuesInputStatic) {\n    /* nothing */\n  }\n\n  static getHandlerOrDefault(\n    componentType: MultipleValuesInputStatic,\n    handlerProps: MultipleValuesHandlerProps<any>\n  ): MultipleValuesHandler {\n    if (!(componentType && componentType.makeHandler)) {\n      return MultipleValuesInput.defaultHandler;\n    }\n    return componentType.makeHandler(handlerProps);\n  }\n}\n\nexport class CardinalityCheckingHandler implements MultipleValuesHandler {\n  private definition: FieldDefinition;\n\n  constructor(props: MultipleValuesHandlerProps<MultipleValuesProps>) {\n    this.definition = props.definition;\n  }\n\n  validate({ values, errors }: ValuesWithErrors): ValuesWithErrors {\n    const otherErrors = errors.filter((e) => e.kind !== ErrorKind.Input).toList();\n    const cardinalityErrors = checkCardinalityAndDuplicates(values, this.definition);\n    return {\n      values: values,\n      errors: otherErrors.concat(cardinalityErrors),\n    };\n  }\n\n  finalize(\n    values: Immutable.List<FieldValue>,\n    owner: EmptyValue | CompositeValue\n  ): Kefir.Property<Immutable.List<FieldValue>> {\n    return MultipleValuesInput.defaultHandler.finalize(values, owner);\n  }\n}\n\nexport function checkCardinalityAndDuplicates(\n  values: Immutable.List<FieldValue>,\n  definition: FieldDefinition\n): Immutable.List<FieldError> {\n  let errors = FieldError.noErrors;\n\n  // filter empty values and duplicates, emit \"duplicate value\" errors\n  const nonEmpty = values.reduce((set, v) => {\n    if (FieldValue.isComposite(v) && CompositeValue.isPlaceholder(v.subject)) {\n      // only happens on initial loading: optimistically assume that\n      // composite subject IRIs will be different after subject generation\n      return set.add(Rdf.bnode());\n    }\n    const rdfNode = FieldValue.asRdfNode(v);\n    if (!rdfNode) {\n      return set;\n    } else if (set.has(rdfNode)) {\n      errors = errors.push({\n        kind: ErrorKind.Input,\n        message: `Value \"${rdfNode.value}\" is appears more than once`,\n      });\n      return set;\n    } else {\n      return set.add(rdfNode);\n    }\n  }, Immutable.Set<Rdf.Node>());\n\n  if (nonEmpty.size < definition.minOccurs) {\n    errors = errors.push({\n      kind: ErrorKind.Input,\n      message: `Required a minimum of ${definition.minOccurs} values` + ` but ${nonEmpty.size} provided`,\n    });\n  }\n  if (nonEmpty.size > definition.maxOccurs) {\n    errors = errors.push({\n      kind: ErrorKind.Input,\n      message: `Required a maximum of ${definition.maxOccurs} values` + ` but ${nonEmpty.size} provided`,\n    });\n  }\n\n  return errors;\n}\n"],"sourceRoot":""}