{"version":3,"sources":["webpack:///./src/main/web/components/3-rd-party/ontodia/authoring/OntodiaEntityMetadata.ts"],"names":["render","getRequiredFields","props","ct","fieldIris","labelIri","push","Rdf","iri","imageIri","fields","otherField","Promise","resolve","configure","context","extractAuthoringMetadata","fieldByIri","typeIri","datatypeFields","entityTypeIri","newSubjectTemplate","Error","labelField","allFieldByIri","get","typeField","imageField","mappedFields","map","fieldIri","field","headFields","entityFields","Immutable","Map","f","metadata","entityType","Set","filter","has","formChildren","children","validateFormFieldsDatatype","React","Children","forEach","child","mapping","mapChildToComponent","FieldMapping","isComposite","isInput","element","for","isObjectProperty","isOtherElement","collectedMetadata","set","Component","OntodiaEntityMetadata","assertFieldConfigurationItem"],"mappings":"6IAmBA,OAEA,QAGA,QACA,UAEA,UAiEA,+C,+CAwBA,OAxB2C,qCACzC,gCAAAA,OAAA,WACE,OAAO,MAGF,sBAAAC,kBAAP,SAAyBC,EAAmCC,GAC1D,IAAMC,EAAuB,GAO7B,GANIF,EAAMG,UACRD,EAAUE,KAAK,EAAAC,IAAIC,IAAIN,EAAMG,WAE3BH,EAAMO,UACRL,EAAUE,KAAK,EAAAC,IAAIC,IAAIN,EAAMO,WAE3BP,EAAMQ,OACR,IAAyB,UAAAR,EAAMQ,OAAN,eAAc,CAAlC,IAAMC,EAAU,KACnBP,EAAUE,KAAK,EAAAC,IAAIC,IAAIG,IAG3B,OAAOC,QAAQC,QAAQT,IAGZ,sBAAAU,UAAb,SAAuBZ,EAAmCa,G,+BAAqCH,SAAO,W,8CAOxG,SAASI,yBAAyBd,EAAmCa,GAC3D,QAAAE,WAA2BC,EAAA,EAAAA,QAASC,EAAA,EAAAA,eAE1CC,EAAA,EAAAA,cACAV,EAAA,EAAAA,OACA,IAAAL,gBAAA,IAAW,EAAX,oBACA,IAAAI,gBAAA,IAAW,EAAX,oBACA,IAAAY,0BAAA,IAAqB,EAArB,2BAGF,GAA6B,iBAAlBD,EACT,MAAM,IAAIE,MAAM,oEAElB,IAAKZ,EACH,MAAM,IAAIY,MAAM,2DAElB,GAAwB,iBAAbjB,EACT,MAAM,IAAIiB,MAAM,8DAGlB,IAAMC,EAAaC,EAAcC,IAAIpB,GAC/BqB,EAAYF,EAAcC,IAAIP,GAC9BS,EAAaH,EAAcC,IAAIhB,GAErC,IAAKiB,EACH,MAAM,IAAIJ,MAAM,kCAAkCF,EAAa,0BAA0BF,EAAO,KAElG,IAAKK,EACH,MAAM,IAAID,MAAM,kCAAkCF,EAAa,2BAA2Bf,EAAQ,KAGpG,IAAMuB,EAAelB,EAAOmB,KAAI,SAACC,GAC/B,IAAMC,EAAQP,EAAcC,IAAIK,GAChC,IAAKC,EACH,MAAM,IAAIT,MAAM,kCAAkCF,EAAa,qBAAqBf,EAAQ,KAE9F,OAAO0B,KAGHC,EAAa,CAACN,EAAWH,GAC3BI,GACFK,EAAW1B,KAAKqB,GAGlB,IAAMM,EAAe,EAAH,eAAOD,EAAeJ,GAClCX,EAAaiB,EAAUC,IAAIF,EAAaJ,KAAI,SAACO,GAAM,OAACA,EAAE5B,IAAK4B,OAE3DC,EAA2B,CAC/BC,WAAYlB,EACZV,OAAQuB,EACRhB,WAAU,EACVE,eAAgBe,EAAUK,IAAYpB,EAAeqB,QAAO,SAACV,GAAa,OAAAb,EAAWwB,IAAIX,OACzFJ,UAAS,EACTH,WAAU,EACVI,WAAU,EACVN,mBAAkB,EAClBqB,aAAcxC,EAAMyC,WAQxB,SAASC,2BAA2BD,EAAiCN,GACnE,IAAKM,EACH,OAEFE,EAAMC,SAASC,QAAQJ,GAAU,SAACK,GAChC,IAAMC,EAAU,EAAAC,oBAAoBF,GACpC,GAAKC,IAAW,EAAAE,aAAaC,YAAYH,GAGzC,GAAI,EAAAE,aAAaE,QAAQJ,GAAU,CACjC,IAAMlB,EAAQM,EAASpB,WAAWQ,IAAIwB,EAAQK,QAAQpD,MAAMqD,KAC5D,GAAI,EAAAC,iBAAiBzB,EAAOM,GAC1B,MAAM,IAAIf,MAAM,8BAA8BS,EAAMvB,IAAG,wBAEhD,EAAA2C,aAAaM,eAAeR,IACrCL,2BAA2BK,EAAQN,SAAUN,OApBjDO,CAA2BP,EAASK,aAAcL,GAElDtB,EAAQ2C,kBAAkBC,IAAItB,EAASC,WAAYD,GAnEjDrB,CAAyBd,EAAOa,G,WAEpC,sBAxBA,CAA2C8B,EAAMe,WAApC,EAAAC,wBA0Bb,EAAAC,6BAA6BD,GAsF7B,UAAeA","file":"ontodia-entity-metadata-c0b44d7051a8577e136c.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as React from 'react';\nimport { ReactNode } from 'react';\nimport * as Immutable from 'immutable';\nimport { ElementTypeIri, CancellationToken } from 'ontodia';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { FieldDefinition, FieldMapping, mapChildToComponent } from 'platform/components/forms';\n\nimport {\n  FieldConfigurationContext,\n  EntityMetadata,\n  assertFieldConfigurationItem,\n  isObjectProperty,\n} from './FieldConfigurationCommon';\n\nexport interface OntodiaEntityMetadataProps {\n  /**\n   * Iri of the type to be configured. For example, 'http://xmlns.com/foaf/0.1/person'\n   */\n  entityTypeIri: string;\n\n  /**\n   * Ordered list of fields to be used for this entity. Automatically generated forms will honor\n   * the order of the fields specified here.\n   */\n  fields: ReadonlyArray<string>;\n\n  /**\n   * Field Iri for entity label override\n   */\n  labelIri?: string;\n\n  /**\n   * Field Iri for entity image override\n   */\n  imageIri?: string;\n\n  /**\n   * Subject template override for generating Iri of new entities\n   */\n  newSubjectTemplate?: string;\n\n  /**\n   * Semantic form override. If developer wants to override auto-generated form,\n   * it should be placed inside <ontodia-entity-metadata>.\n   */\n  children?: JSX.Element;\n}\n\n/**\n * @example\n * <ontodia-entity-metadata\n *   entity-type-iri='http://example.com/Company'\n *   fields='[\"field-iri-1\", \"field-iri-2\", ...]'\n *   label-iri='http://www.example.com/fields/companyName'\n *   image-iri='http://www.example.com/fields/hasType'\n *   new-subject-template='http://www.example.com/company/{{UUID}}'\n *   force-iris='[\"datatype-field-1\", ...]'>\n *\n *   <semantic-form-text-input for='http://www.example.com/fields/companyName'>\n *   </semantic-form-text-input>\n *\n *   <semantic-form-composite-input\n *     for='http://www.example.com/fields/companyAddress'\n *     fields='...'>\n *     <!-- inputs for addressCountry, addressCity, etc) -->\n *   </semantic-form-composite-input>\n *\n *   <semantic-form-errors></semantic-form-errors>\n *   <button name=\"submit\" class=\"btn btn-default\">Save</button>\n *   <button name=\"reset\" class=\"btn btn-default\">Reset</button>\n * </ontodia-entity-metadata>\n */\nexport class OntodiaEntityMetadata extends React.Component<OntodiaEntityMetadataProps, {}> {\n  render(): null {\n    return null;\n  }\n\n  static getRequiredFields(props: OntodiaEntityMetadataProps, ct: CancellationToken): Promise<Rdf.Iri[]> {\n    const fieldIris: Rdf.Iri[] = [];\n    if (props.labelIri) {\n      fieldIris.push(Rdf.iri(props.labelIri));\n    }\n    if (props.imageIri) {\n      fieldIris.push(Rdf.iri(props.imageIri));\n    }\n    if (props.fields) {\n      for (const otherField of props.fields) {\n        fieldIris.push(Rdf.iri(otherField));\n      }\n    }\n    return Promise.resolve(fieldIris);\n  }\n\n  static async configure(props: OntodiaEntityMetadataProps, context: FieldConfigurationContext): Promise<void> {\n    extractAuthoringMetadata(props, context);\n  }\n}\n\nassertFieldConfigurationItem(OntodiaEntityMetadata);\n\nfunction extractAuthoringMetadata(props: OntodiaEntityMetadataProps, context: FieldConfigurationContext) {\n  const { fieldByIri: allFieldByIri, typeIri, datatypeFields } = context;\n  const {\n    entityTypeIri,\n    fields,\n    labelIri = context.defaultLabelIri,\n    imageIri = context.defaultImageIri,\n    newSubjectTemplate = context.defaultSubjectTemplate,\n  } = props;\n\n  if (typeof entityTypeIri !== 'string') {\n    throw new Error(`Missing 'entity-type-iri' property for <ontodia-entity-metadata>`);\n  }\n  if (!fields) {\n    throw new Error(`Missing 'fields' property for <ontodia-entity-metadata>`);\n  }\n  if (typeof labelIri !== 'string') {\n    throw new Error(`Missing 'label-iri' property for <ontodia-entity-metadata>`);\n  }\n\n  const labelField = allFieldByIri.get(labelIri);\n  const typeField = allFieldByIri.get(typeIri);\n  const imageField = allFieldByIri.get(imageIri);\n\n  if (!typeField) {\n    throw new Error(`<ontodia-entity-metadata> for <${entityTypeIri}>: missing type field <${typeIri}>`);\n  }\n  if (!labelField) {\n    throw new Error(`<ontodia-entity-metadata> for <${entityTypeIri}>: missing label field <${labelIri}>`);\n  }\n\n  const mappedFields = fields.map((fieldIri) => {\n    const field = allFieldByIri.get(fieldIri);\n    if (!field) {\n      throw new Error(`<ontodia-entity-metadata> for <${entityTypeIri}>: missing field <${labelIri}>`);\n    }\n    return field;\n  });\n\n  const headFields = [typeField, labelField];\n  if (imageField) {\n    headFields.push(imageField);\n  }\n\n  const entityFields = [...headFields, ...mappedFields];\n  const fieldByIri = Immutable.Map(entityFields.map((f) => [f.iri, f] as [string, FieldDefinition]));\n\n  const metadata: EntityMetadata = {\n    entityType: entityTypeIri as ElementTypeIri,\n    fields: entityFields,\n    fieldByIri,\n    datatypeFields: Immutable.Set<string>(datatypeFields.filter((fieldIri) => fieldByIri.has(fieldIri))),\n    typeField,\n    labelField,\n    imageField,\n    newSubjectTemplate,\n    formChildren: props.children,\n  };\n\n  validateFormFieldsDatatype(metadata.formChildren, metadata);\n\n  context.collectedMetadata.set(metadata.entityType, metadata);\n}\n\nfunction validateFormFieldsDatatype(children: ReactNode | undefined, metadata: EntityMetadata) {\n  if (!children) {\n    return;\n  }\n  React.Children.forEach(children, (child) => {\n    const mapping = mapChildToComponent(child);\n    if (!mapping || FieldMapping.isComposite(mapping)) {\n      return;\n    }\n    if (FieldMapping.isInput(mapping)) {\n      const field = metadata.fieldByIri.get(mapping.element.props.for);\n      if (isObjectProperty(field, metadata)) {\n        throw new Error(`XSD Datatype of the field <${field.iri}> isn't literal`);\n      }\n    } else if (FieldMapping.isOtherElement(mapping)) {\n      validateFormFieldsDatatype(mapping.children, metadata);\n    }\n  });\n}\n\nexport default OntodiaEntityMetadata;\n"],"sourceRoot":""}