{"version":3,"sources":["webpack:///./src/main/web/components/forms/QueryValues.ts"],"names":["canRestoreLabel","value","label","undefined","isIri","restoreLabel","getLabel","map","Kefir","constant","normalizeValueDatatype","node","Rdf","Literal","language","literal","XsdDataTypeValidation","replaceDatatypeAliases","datatype","validate","subject","field","oldValue","newValue","FieldValue","isAtomic","Immutable","is","later","queries","constraints","constraint","SparqlUtil","parseQueryAsync","validatePattern","flatMap","query","SparqlTypeGuards","isQuery","queryType","constantError","Error","SparqlClient","setBindings","ask","success","error","flatMapErrors","zip","results","otherErrors","errors","filter","kind","ErrorKind","Validation","toList","AtomicValue","set","concat","result","message","queryValues","pattern","options","additionalSubjects","isEmpty","parameters","s","push","prepareParsedQuery","select","bindings","binding","v","SparqlBindingValue","values","length","toProperty"],"mappings":"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","file":"default~diagram-search-result~mp-field-visualization~mp-sparql-query-editor~mp-spin-query-template-e~9aa2ad42-18905c0caae686684137.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\nimport * as SparqlJs from 'sparqljs';\nimport * as Immutable from 'immutable';\nimport { isEmpty } from 'lodash';\n\nimport { Rdf, XsdDataTypeValidation } from 'platform/api/rdf';\nimport { SparqlClient, SparqlUtil, SparqlTypeGuards } from 'platform/api/sparql';\n\nimport { getLabel } from 'platform/api/services/resource-label';\n\nimport { FieldDefinition } from './FieldDefinition';\nimport { FieldValue, SparqlBindingValue, FieldError, ErrorKind, AtomicValue, LabeledValue } from './FieldValues';\n\n/**\n * @returns a promise of field validation result.\n */\nexport function validate(\n  subject: Rdf.Iri,\n  field: FieldDefinition,\n  oldValue: FieldValue,\n  newValue: FieldValue\n): Kefir.Stream<FieldValue> {\n  if (!FieldValue.isAtomic(newValue) || Immutable.is(oldValue, newValue)) {\n    return Kefir.later(0, newValue);\n  }\n  const queries = field.constraints.map((constraint) =>\n    SparqlUtil.parseQueryAsync(constraint.validatePattern)\n      .flatMap<SparqlJs.AskQuery>((query) =>\n        SparqlTypeGuards.isQuery(query) && query.queryType === 'ASK'\n          ? Kefir.constant(query)\n          : Kefir.constantError<any>(new Error('validatePattern is not an ASK query'))\n      )\n      .map((query) =>\n        SparqlClient.setBindings(query, {\n          subject: subject,\n          value: newValue.value,\n        })\n      )\n      .flatMap<boolean>((query) => SparqlClient.ask(query))\n      .map((success) => ({ constraint, success, error: undefined }))\n      .flatMapErrors((error) => Kefir.constant({ constraint, success: false, error }))\n  );\n  // merge validation errors from FieldDefinition.constrains queries into FieldValue\n  return Kefir.zip(queries).map((results) => {\n    const otherErrors = newValue.errors.filter((error) => error.kind !== ErrorKind.Validation).toList();\n    return AtomicValue.set(newValue, {\n      errors: otherErrors.concat(\n        results\n          .filter((result) => !result.success)\n          .map<FieldError>((result) => ({\n            kind: ErrorKind.Validation,\n            message: result.error ? `Failed to validate value: ${result.error}` : result.constraint.message,\n          }))\n      ),\n    });\n  });\n}\n\nexport function queryValues(\n  pattern: string,\n  subject?: Rdf.Iri,\n  options?: SparqlClient.SparqlOptions,\n\n  // used when we want to fetch field values for additional IRIs that represent the same subject.\n  // typically owl:sameAs or skos:exactMatch\n  additionalSubjects?: Rdf.Iri[]\n): Kefir.Property<SparqlBindingValue[]> {\n  if (!pattern) {\n    return Kefir.constant([]);\n  }\n  return SparqlUtil.parseQueryAsync(pattern)\n    .map((query) => {\n      if (additionalSubjects && !isEmpty(additionalSubjects)) {\n        const parameters  = additionalSubjects.map(s => ({'subject': s}));\n        parameters.push({'subject': subject});\n        return SparqlClient.prepareParsedQuery(parameters)(query as SparqlJs.SelectQuery);\n      } else {\n        return (subject ? SparqlClient.setBindings(query, { subject: subject }) : query)\n      }\n    })\n    .flatMap<SparqlClient.SparqlSelectResult>((query) => SparqlClient.select(query, options))\n    .map((result) =>\n      result.results.bindings\n        .map<SparqlBindingValue>((binding) => ({\n          value: binding.value,\n          label: binding.label ? binding.label.value : undefined,\n          binding: binding,\n        }))\n        .filter((v) => v.value !== undefined)\n        .map((v) =>\n          SparqlBindingValue.set(v, {\n            value: normalizeValueDatatype(v.value),\n            binding: v.binding,\n          })\n        )\n        .map(restoreLabel)\n    )\n    .flatMap((values) => (values.length > 0 ? Kefir.zip(values) : Kefir.constant([])))\n    .toProperty();\n}\n\nexport function canRestoreLabel(value: LabeledValue): boolean {\n  return (value.label === null || value.label === undefined) && value.value && value.value.isIri();\n}\n\nexport function restoreLabel<T extends LabeledValue>(value: T): Kefir.Property<T> {\n  if (canRestoreLabel(value)) {\n    return getLabel(value.value as Rdf.Iri).map((label) => ({ ...(value as any), label } as T));\n  } else {\n    return Kefir.constant(value);\n  }\n}\n\nfunction normalizeValueDatatype(node: Rdf.Node): Rdf.Node {\n  if (node instanceof Rdf.Literal && !node.language) {\n    return Rdf.literal(node.value, XsdDataTypeValidation.replaceDatatypeAliases(node.datatype));\n  } else {\n    return node;\n  }\n}\n"],"sourceRoot":""}