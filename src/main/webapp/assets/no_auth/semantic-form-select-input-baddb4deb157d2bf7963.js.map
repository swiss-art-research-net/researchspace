{"version":3,"sources":["webpack:///./src/main/web/components/forms/inputs/SelectInput.ts"],"names":["props","context","cancellation","Cancellation","isLoading","onValueChanged","value","setAndValidate","parseValue","optionRenderer","option","undefined","template","createElement","TemplateItem","source","options","binding","D","span","id","label","className","SELECT_TEXT_CLASS","valueRenderer","v","valueSet","state","bindingValue","find","setValue","equals","Immutable","List","dataState","this","DataState","Loading","Ready","componentDidMount","definition","valueSetPattern","map","queryValues","observe","setState","updateValue","error","console","nonEmpty","FieldValue","isEmpty","fromLabeled","Rdf","iri","errors","getErrors","push","kind","ErrorKind","message","setErrors","componentWillUnmount","cancelAll","empty","findCorresponding","corresponding","AtomicValue","set","render","toArray","Array","inputValue","selectedValue","isAtomic","placeholder","createDefaultPlaceholder","div","name","onChange","disabled","canEdit","ValidationMessages","getPreferredLabel","toLocaleLowerCase","makeHandler","AtomicValueInput","makeAtomicHandler","SelectInput","SingleValueInput","assertStatic"],"mappings":"4IAmBA,OACA,QACA,UACA,QAEA,SACA,QAEA,SAEA,UACA,UACA,UACA,UACA,UAcA,cAKE,qBAAYA,EAAyBC,GAArC,MACE,YAAMD,EAAOC,IAAQ,K,OALN,EAAAC,aAAe,IAAI,EAAAC,aAE5B,EAAAC,WAAY,EA+CZ,EAAAC,eAAiB,SAACC,GACxB,EAAKC,eAAe,EAAKC,WAAWF,KAsB9B,EAAAG,eAAiB,SAACC,GACxB,YAA4BC,IAAxB,EAAKX,MAAMY,SACN,EAAAC,cAAc,EAAAC,aAAc,CACjCF,SAAU,CACRG,OAAQ,EAAKf,MAAMY,SACnBI,QAASN,EAAOO,WAKbC,EAAEC,KAAK,CAAEC,GAAIV,EAAOW,MAAOC,UArFnBC,2BAqF8Cb,EAAOW,OAASX,EAAOJ,MAAMA,QAItF,EAAAkB,cAAgB,SAACC,GAEvB,GAAKA,EAAL,CAIA,IAAIC,EAAW,EAAKC,MAAMD,SAC1B,GAAIA,EAAU,CAEZ,IAAME,EAAeF,EAASG,MAAK,SAACC,GAAa,OAAAA,EAASxB,MAAMyB,OAAON,EAAEnB,UAEzE,GAAIsB,EACF,OAAO,EAAKnB,eAAemB,GAM/B,OAAOV,EAAEC,KAAK,CAAEC,GAAIK,EAAEJ,MAAOC,UA3GZC,2BA2GuCE,EAAEJ,OAASI,EAAEnB,MAAMA,SAlG3E,EAAKqB,MAAQ,CACXD,SAAUM,EAAUC,Q,EAwI1B,OAhJiC,2BAY/B,sBAAAC,UAAA,WACE,OAAIC,KAAK/B,UACA,EAAAgC,UAAUC,QAEZ,EAAAD,UAAUE,OAGnB,sBAAAC,kBAAA,sBACUC,EAAA,WAAAA,WACJA,EAAWC,gBACbN,KAAKjC,aAAawC,IAAI,EAAAC,YAAYH,EAAWC,kBAAkBG,QAAQ,CACrEtC,MAAO,SAACoB,GACN,EAAKtB,WAAY,EACjB,EAAKyC,SAAS,CAAEnB,SAAUM,EAAUC,KAAKP,KACzC,EAAK1B,MAAM8C,aAAY,SAACrB,GAAM,OAAAA,MAEhCsB,MAAO,SAACA,GACNC,QAAQD,MAAMA,GACd,EAAK3C,WAAY,EACjB,EAAKJ,MAAM8C,aAAY,SAACrB,GACtB,IAAMwB,EAAW,EAAAC,WAAWC,QAAQ1B,GAAK,EAAAyB,WAAWE,YAAY,CAAE9C,MAAO,EAAA+C,IAAIC,IAAI,MAAS7B,EACpF8B,EAAS,EAAAL,WAAWM,UAAUP,GAAUQ,KAAK,CACjDC,KAAM,EAAAC,UAAUtB,QAChBuB,QAAS,6BAEX,OAAO,EAAAV,WAAWW,UAAUZ,EAAUM,SAK5CpB,KAAK/B,WAAY,GAIrB,sBAAA0D,qBAAA,WACE3B,KAAKjC,aAAa6D,aAOZ,sBAAAvD,WAAR,SAAmBF,GAEjB,IAAKA,EACH,OAAO,EAAA4C,WAAWc,MAGpB,IAAMC,EAAoB9B,KAAKR,MAAMD,SAASG,MAAK,SAACJ,GAAM,OAAAA,EAAEnB,MAAMyB,OAAOzB,EAAMA,UAC/E,IAAK2D,EACH,OAAO,EAAAf,WAAWc,MAIpB,IAAME,EAAsC,CAC1C5D,MAAO2D,EAAkB3D,MACzBe,MAAO4C,EAAkB5C,OAE3B,OAAO,EAAA8C,YAAYC,IAAIjC,KAAKnC,MAAMM,MAAO4D,IAsC3C,sBAAAG,OAAA,WACE,IAAM7B,EAAaL,KAAKnC,MAAMwC,WACxBxB,EAAUmB,KAAKR,MAAMD,SAAWS,KAAKR,MAAMD,SAAS4C,UAAY,IAAIC,MAEpEC,EAAarC,KAAKnC,MAAMM,MACxBmE,EAAgB,EAAAvB,WAAWwB,SAASF,GAAcA,OAAa7D,EAE/DgE,OAC8B,IAA3BxC,KAAKnC,MAAM2E,YACdxC,KAAKyC,yBAAyBpC,GAC9BL,KAAKnC,MAAM2E,YAEjB,OAAOzD,EAAE2D,IACP,CAAEvD,UA5HkB,qBA8HpB,EAAAT,cAAc,UAAa,CACzBiE,KAAMtC,EAAWpB,GACjBuD,YAAaA,EACbI,SAAU5C,KAAK9B,eACf2E,UAAW7C,KAAK8C,QAChBjE,QAASA,EACTV,MAAOmE,EACPhE,eAAgB0B,KAAK1B,eACrBe,cAAeW,KAAKX,gBAGtB,EAAAX,cAAc,EAAAqE,mBAAoB,CAAE3B,OAAQ,EAAAL,WAAWM,UAAUrB,KAAKnC,MAAMM,WAIxE,sBAAAsE,yBAAR,SAAiCpC,GAE/B,MAAO,WADY,EAAA2C,kBAAkB3C,EAAWnB,QAAU,UAAU+D,oBAC1C,YAGrB,YAAAC,YAAc,EAAAC,iBAAiBC,kBACxC,YAhJA,CAAiC,EAAAD,kBAApB,EAAAE,cAkJb,EAAAC,iBAAiBC,aAAaF,GAE9B,UAAeA","file":"semantic-form-select-input-baddb4deb157d2bf7963.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { createElement } from 'react';\nimport * as D from 'react-dom-factories';\nimport ReactSelect from 'react-select';\nimport * as Immutable from 'immutable';\n\nimport { Cancellation } from 'platform/api/async/Cancellation';\nimport { Rdf } from 'platform/api/rdf';\n\nimport { TemplateItem } from 'platform/components/ui/template';\n\nimport { FieldDefinition, getPreferredLabel } from '../FieldDefinition';\nimport { FieldValue, AtomicValue, EmptyValue, SparqlBindingValue, ErrorKind, DataState } from '../FieldValues';\nimport { SingleValueInput, AtomicValueInput, AtomicValueInputProps } from './SingleValueInput';\nimport { ValidationMessages } from './Decorations';\nimport { queryValues } from '../QueryValues';\n\nexport interface SelectInputProps extends AtomicValueInputProps {\n  template?: string;\n  placeholder?: string;\n}\n\ninterface State {\n  valueSet?: Immutable.List<SparqlBindingValue>;\n}\n\nconst SELECT_TEXT_CLASS = 'select-text-field';\nconst OPTION_CLASS = SELECT_TEXT_CLASS + 'option';\n\nexport class SelectInput extends AtomicValueInput<SelectInputProps, State> {\n  private readonly cancellation = new Cancellation();\n\n  private isLoading = true;\n\n  constructor(props: SelectInputProps, context: any) {\n    super(props, context);\n    this.state = {\n      valueSet: Immutable.List<SparqlBindingValue>(),\n    };\n  }\n\n  dataState(): DataState {\n    if (this.isLoading) {\n      return DataState.Loading;\n    }\n    return DataState.Ready;\n  }\n\n  componentDidMount() {\n    const { definition } = this.props;\n    if (definition.valueSetPattern) {\n      this.cancellation.map(queryValues(definition.valueSetPattern)).observe({\n        value: (valueSet) => {\n          this.isLoading = false;\n          this.setState({ valueSet: Immutable.List(valueSet) });\n          this.props.updateValue((v) => v);\n        },\n        error: (error) => {\n          console.error(error);\n          this.isLoading = false;\n          this.props.updateValue((v) => {\n            const nonEmpty = FieldValue.isEmpty(v) ? FieldValue.fromLabeled({ value: Rdf.iri('') }) : v;\n            const errors = FieldValue.getErrors(nonEmpty).push({\n              kind: ErrorKind.Loading,\n              message: `Failed to load value set`,\n            });\n            return FieldValue.setErrors(nonEmpty, errors);\n          });\n        },\n      });\n    } else {\n      this.isLoading = false;\n    }\n  }\n\n  componentWillUnmount() {\n    this.cancellation.cancelAll();\n  }\n\n  private onValueChanged = (value?: SparqlBindingValue) => {\n    this.setAndValidate(this.parseValue(value));\n  };\n\n  private parseValue(value: SparqlBindingValue): AtomicValue | EmptyValue {\n    // this is for testing purpose only i.e. checking whether callback is called\n    if (!value) {\n      return FieldValue.empty;\n    }\n\n    const findCorresponding = this.state.valueSet.find((v) => v.value.equals(value.value));\n    if (!findCorresponding) {\n      return FieldValue.empty;\n    }\n\n    // turn into field value for standard validation calls\n    const corresponding: Partial<AtomicValue> = {\n      value: findCorresponding.value,\n      label: findCorresponding.label,\n    };\n    return AtomicValue.set(this.props.value, corresponding);\n  }\n\n  private optionRenderer = (option: SparqlBindingValue) => {\n    if (this.props.template !== undefined) {\n      return createElement(TemplateItem, {\n        template: {\n          source: this.props.template,\n          options: option.binding,\n        },\n      });\n    } else {\n      // default option template\n      return D.span({ id: option.label, className: OPTION_CLASS }, option.label || option.value.value);\n    }\n  };\n\n  private valueRenderer = (v: AtomicValue | undefined) => {\n    // that is if user adds a new input which get's empty as initial field value\n    if (!v) {\n      return;\n    }\n\n    let valueSet = this.state.valueSet;\n    if (valueSet) {\n      // try to find the selected value in the pre-computed valueSet\n      const bindingValue = valueSet.find((setValue) => setValue.value.equals(v.value));\n      // if existing, then use optionRenderer to exploit the template and additional bindings\n      if (bindingValue) {\n        return this.optionRenderer(bindingValue);\n      }\n    }\n\n    // fallback rendering i.e. if recovering from state or saved value\n    // but value is not any longer in dynamically (on every initialization) computed set\n    return D.span({ id: v.label, className: OPTION_CLASS }, v.label || v.value.value);\n  };\n\n  render() {\n    const definition = this.props.definition;\n    const options = this.state.valueSet ? this.state.valueSet.toArray() : new Array<SparqlBindingValue>();\n\n    const inputValue = this.props.value;\n    const selectedValue = FieldValue.isAtomic(inputValue) ? inputValue : undefined;\n\n    const placeholder =\n      typeof this.props.placeholder === 'undefined'\n        ? this.createDefaultPlaceholder(definition)\n        : this.props.placeholder;\n\n    return D.div(\n      { className: SELECT_TEXT_CLASS },\n\n      createElement(ReactSelect, {\n        name: definition.id,\n        placeholder: placeholder,\n        onChange: this.onValueChanged,\n        disabled: !this.canEdit,\n        options: options,\n        value: selectedValue,\n        optionRenderer: this.optionRenderer,\n        valueRenderer: this.valueRenderer,\n      }),\n\n      createElement(ValidationMessages, { errors: FieldValue.getErrors(this.props.value) })\n    );\n  }\n\n  private createDefaultPlaceholder(definition: FieldDefinition): string {\n    const fieldName = (getPreferredLabel(definition.label) || 'entity').toLocaleLowerCase();\n    return `Select ${fieldName} here...`;\n  }\n\n  static makeHandler = AtomicValueInput.makeAtomicHandler;\n}\n\nSingleValueInput.assertStatic(SelectInput);\n\nexport default SelectInput;\n"],"sourceRoot":""}