{"version":3,"sources":["webpack:///./src/main/web/components/forms/inputs/ChecklistInput.tsx"],"names":["CHECKLIST_CLASS","props","context","cancellation","Cancellation","isLoading","onValueChanged","event","updateValues","handler","valueSet","checked","target","values","errors","newValues","Immutable","List","checkType","filter","value","FieldValue","isAtomic","toList","isEqualValues","previouslyChecked","some","valueToCheck","equals","validate","map","fromLabeled","type","renderCheckItem","key","classItemName","textClass","className","classnames","label","onChange","renderChecklist","options","option","index","toArray","state","dataState","this","DataState","Loading","Ready","componentDidMount","definition","valueSetPattern","queryValues","observe","setState","v","error","console","otherErrors","e","kind","ErrorKind","push","message","componentWillUnmount","cancelAll","render","row","makeHandler","CardinalityCheckingHandler","MultipleValuesInput","ChecklistInput","assertStatic"],"mappings":"4IAkBA,OACA,QACA,OAEA,QAEA,UACA,UAMA,UAEMA,EAAkB,gCA+CxB,cAIE,wBAAYC,EAA4BC,GAAxC,MACE,YAAMD,EAAOC,IAAQ,K,OAJN,EAAAC,aAAe,IAAI,EAAAC,aAC5B,EAAAC,WAAY,EA+CZ,EAAAC,eAAiB,SAACC,GAClB,cAAEC,EAAA,EAAAA,aAAcC,EAAA,EAAAA,QACdC,EAAA,QAAAA,SACFC,EAAUJ,EAAMK,OAAOD,QAC7BH,GAAa,SAAC,G,IAAEK,EAAA,EAAAA,OAAQC,EAAA,EAAAA,OAClBC,EAAgDC,EAAUC,OAC9D,GAAyB,aAArB,EAAKC,YAA4B,CAEnC,IAAM,EAAiBL,EACpBM,QAAO,SAACC,GACP,OAAO,EAAAC,WAAWC,SAASF,IAAUA,EAAMA,MAAMA,QAAUb,EAAMK,OAAOQ,SAEzEG,SACHR,EAAYL,EACTS,QAAO,SAACC,GACP,IAAMI,EAAgBJ,EAAMA,MAAMA,QAAUb,EAAMK,OAAOQ,MAEnDK,EAAoB,EAAeC,MACvC,SAACC,GAAiB,SAAAN,WAAWC,SAASK,IAAiBA,EAAaP,MAAMQ,OAAOR,EAAMA,UAEzF,OAAOT,EAAUc,GAAqBD,EAAgBC,IAAsBD,KAE7ED,SAcL,MAZyB,UAArB,EAAKL,cACPH,EAAYL,EACTS,QAAO,SAACC,GACP,IAAMI,EAAgBJ,EAAMA,MAAMA,QAAUb,EAAMK,OAAOQ,MACzD,OAAOT,GAAWa,KAEnBD,UAEad,EAAQoB,SAAS,CACjChB,OAAQE,EAAUe,KAAI,SAACV,GAAU,SAAAC,WAAWU,YAAYX,MACxDN,OAAQA,QAMN,EAAAI,UAAY,WACV,IAAAc,EAAA,QAAAA,KACR,MAAgB,aAATA,EAAsB,WAAsB,UAATA,EAAmB,QAAU,YAGjE,EAAAC,gBAAkB,SAACb,EAA2BT,EAAkBuB,GAC9D,IAAAC,EAAA,QAAAA,cACFH,EAAO,EAAKd,YAGZkB,EAAqB,UAATJ,EAAsBhC,EAAe,UAAeA,EAAe,aACrF,OACE,uBAAKkC,IAAKA,EAAKG,UAAWC,EAAW,GAAGtC,EAAmBmC,IACzD,yBAAOE,UALWrC,wCAMfoB,EAAMmB,MACP,yBACEP,KAAMA,EACNK,UARcrC,uCASdwC,SAAU,EAAKlC,eACfc,MAAOA,EAAMA,MAAMA,MACnBT,QAASA,IAEX,wBAAM0B,UAAWD,OAMjB,EAAAK,gBAAkB,SAACC,GACjB,IAAA7B,EAAA,QAAAA,OACR,OAAO6B,EAAQZ,KAAI,SAACa,EAAQC,GAC1B,IAAMjC,EAAUE,EAAOgC,UAAUnB,MAAK,SAACN,GACrC,OAAO,EAAAC,WAAWC,SAASF,IAAUA,EAAMA,MAAMQ,OAAOe,EAAOvB,UAEjE,OAAO,EAAKa,gBAAgBU,EAAQhC,EAAYgC,EAAOvB,MAAMA,MAAK,IAAIwB,OArHxE,EAAKE,MAAQ,CACXpC,SAAUM,EAAUC,Q,EAoI1B,OA3IoC,8BAWlC,yBAAA8B,UAAA,WACE,OAAIC,KAAK3C,UACA,EAAA4C,UAAUC,QAEZ,EAAAD,UAAUE,OAGnB,yBAAAC,kBAAA,sBACUC,EAAA,WAAAA,WACJA,EAAWC,gBACbN,KAAK7C,aAAa2B,IAAI,EAAAyB,YAAYF,EAAWC,kBAAkBE,QAAQ,CACrEpC,MAAO,SAACV,GACN,EAAKL,WAAY,EACjB,EAAKoD,SAAS,CAAE/C,SAAUM,EAAUC,KAAKP,KACzC,EAAKT,MAAMO,cAAa,SAACkD,GAAM,OAAAA,MAEjCC,MAAO,SAACA,GACNC,QAAQD,MAAMA,GACd,EAAKtD,WAAY,EACjB,EAAKJ,MAAMO,cAAa,SAAC,G,IAAEK,EAAA,EAAAA,OACnBgD,EAD2B,EAAA/C,OACNK,QAAO,SAAC2C,GAAM,OAAAA,EAAEC,OAAS,EAAAC,UAAUd,WAAS3B,SAKvE,OAJAsC,EAAYI,KAAK,CACfF,KAAM,EAAAC,UAAUd,QAChBgB,QAAS,6BAEJ,CAAErD,OAAM,EAAEC,OAAQ+C,SAK/Bb,KAAK3C,WAAY,GAIrB,yBAAA8D,qBAAA,WACEnB,KAAK7C,aAAaiE,aAiFpB,yBAAAC,OAAA,W,MACQ,aAAEC,EAAA,EAAAA,IAAKjC,EAAA,EAAAA,UACPK,EAAUM,KAAKF,MAAMpC,SAAWsC,KAAKF,MAAMpC,SAASmC,UAAY,GAEtE,OACE,uBAAKR,UAAWC,EAAWD,GAAS,KAAI,EAAIrC,EAAe,QAASsE,EAAG,KAAMtB,KAAKP,gBAAgBC,KAI/F,eAAA6B,YAAP,SAAmBtE,GACjB,OAAO,IAAI,EAAAuE,2BAA2BvE,IAE1C,eA3IA,CAAoC,EAAAwE,qBAAvB,EAAAC,iBA6Ib,EAAAD,oBAAoBE,aAAaD,GAEjC,UAAeA","file":"semantic-form-checklist-input-e37673d777766e427482.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport * as React from 'react';\nimport * as Immutable from 'immutable';\nimport * as classnames from 'classnames';\n\nimport { Cancellation } from 'platform/api/async';\n\nimport { FieldValue, SparqlBindingValue, ErrorKind, DataState } from '../FieldValues';\nimport {\n  MultipleValuesInput,\n  MultipleValuesProps,\n  MultipleValuesHandlerProps,\n  CardinalityCheckingHandler,\n} from './MultipleValuesInput';\nimport { queryValues } from '../QueryValues';\n\nconst CHECKLIST_CLASS = 'semantic-form-checklist-input';\n\nexport type ChecklistType = 'radio' | 'checkbox';\n\nexport interface ChecklistInputProps extends MultipleValuesProps {\n  /**\n   * Allow to add custom css-class of Checklist.\n   */\n  className?: string;\n\n  /**\n   * Allow to add custom css-class of Checklist item .\n   */\n  classItemName?: string;\n\n  /**\n   * Allow to transform items(checkboxes or radio-buttons) in a row.\n   * By default all items arranged vertically.\n   */\n  row?: boolean;\n\n  /**\n   * Allow to select one of two types 'checkbox' | 'radio'.\n   * By default is 'checkbox'.\n   */\n  type?: ChecklistType;\n}\n\ninterface State {\n  readonly valueSet?: Immutable.List<SparqlBindingValue>;\n}\n\n/**\n * Form component to select one or several items from list.\n *\n * @example\n * // default using, set type='checkbox' by default\n * <semantic-form-checklist-input for='field-name'></semantic-form-checklist-input>\n *\n * // using with row=true transforms items(checkboxes or radio-buttons) in a row\n * <semantic-form-checklist-input for='field-name' row=true></semantic-form-checklist-input>\n *\n * // can use one of two types(checkbox, radio) or without type\n * <semantic-form-checklist-input for='field-name' type='checkbox'></semantic-form-checklist-input>\n * <semantic-form-checklist-input for='field-name' type='radio'></semantic-form-checklist-input>\n */\n\nexport class ChecklistInput extends MultipleValuesInput<ChecklistInputProps, State> {\n  private readonly cancellation = new Cancellation();\n  private isLoading = true;\n\n  constructor(props: ChecklistInputProps, context: any) {\n    super(props, context);\n    this.state = {\n      valueSet: Immutable.List<SparqlBindingValue>(),\n    };\n  }\n\n  dataState(): DataState {\n    if (this.isLoading) {\n      return DataState.Loading;\n    }\n    return DataState.Ready;\n  }\n\n  componentDidMount() {\n    const { definition } = this.props;\n    if (definition.valueSetPattern) {\n      this.cancellation.map(queryValues(definition.valueSetPattern)).observe({\n        value: (valueSet) => {\n          this.isLoading = false;\n          this.setState({ valueSet: Immutable.List(valueSet) });\n          this.props.updateValues((v) => v);\n        },\n        error: (error) => {\n          console.error(error);\n          this.isLoading = false;\n          this.props.updateValues(({ values, errors }) => {\n            const otherErrors = errors.filter((e) => e.kind === ErrorKind.Loading).toList();\n            otherErrors.push({\n              kind: ErrorKind.Loading,\n              message: `Failed to load value set`,\n            });\n            return { values, errors: otherErrors };\n          });\n        },\n      });\n    } else {\n      this.isLoading = false;\n    }\n  }\n\n  componentWillUnmount() {\n    this.cancellation.cancelAll();\n  }\n\n  private onValueChanged = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const { updateValues, handler } = this.props;\n    const { valueSet } = this.state;\n    const checked = event.target.checked;\n    updateValues(({ values, errors }) => {\n      let newValues: Immutable.List<SparqlBindingValue> = Immutable.List<SparqlBindingValue>();\n      if (this.checkType() === 'checkbox') {\n        // Look for previous values if they are existing.\n        const previousValues = values\n          .filter((value) => {\n            return FieldValue.isAtomic(value) && value.value.value !== event.target.value;\n          })\n          .toList();\n        newValues = valueSet\n          .filter((value) => {\n            const isEqualValues = value.value.value === event.target.value;\n            // Current value compare with items from previous selection.\n            const previouslyChecked = previousValues.some(\n              (valueToCheck) => FieldValue.isAtomic(valueToCheck) && valueToCheck.value.equals(value.value)\n            );\n            return checked ? previouslyChecked || isEqualValues : previouslyChecked && !isEqualValues;\n          })\n          .toList();\n      }\n      if (this.checkType() === 'radio') {\n        newValues = valueSet\n          .filter((value) => {\n            const isEqualValues = value.value.value === event.target.value;\n            return checked && isEqualValues;\n          })\n          .toList();\n      }\n      const validated = handler.validate({\n        values: newValues.map((value) => FieldValue.fromLabeled(value)),\n        errors: errors,\n      });\n      return validated;\n    });\n  };\n\n  private checkType = () => {\n    const { type } = this.props;\n    return type === 'checkbox' ? 'checkbox' : type === 'radio' ? 'radio' : 'checkbox';\n  };\n\n  private renderCheckItem = (value: SparqlBindingValue, checked: boolean, key: string) => {\n    const { classItemName } = this.props;\n    const type = this.checkType();\n    const labelClass = `${CHECKLIST_CLASS}__label`;\n    const inputClass = `${CHECKLIST_CLASS}__input`;\n    const textClass = type === 'radio' ? `${CHECKLIST_CLASS}__radio` : `${CHECKLIST_CLASS}__checkbox`;\n    return (\n      <div key={key} className={classnames(`${CHECKLIST_CLASS}`, classItemName)}>\n        <label className={labelClass}>\n          {value.label}\n          <input\n            type={type}\n            className={inputClass}\n            onChange={this.onValueChanged}\n            value={value.value.value}\n            checked={checked}\n          />\n          <span className={textClass}></span>\n        </label>\n      </div>\n    );\n  };\n\n  private renderChecklist = (options: SparqlBindingValue[]) => {\n    const { values } = this.props;\n    return options.map((option, index) => {\n      const checked = values.toArray().some((value) => {\n        return FieldValue.isAtomic(value) && value.value.equals(option.value);\n      });\n      return this.renderCheckItem(option, checked, `${option.value.value}-${index}`);\n    });\n  };\n\n  render() {\n    const { row, className } = this.props;\n    const options = this.state.valueSet ? this.state.valueSet.toArray() : [];\n\n    return (\n      <div className={classnames(className, { [`${CHECKLIST_CLASS}_row`]: row })}>{this.renderChecklist(options)}</div>\n    );\n  }\n\n  static makeHandler(props: MultipleValuesHandlerProps<ChecklistInputProps>) {\n    return new CardinalityCheckingHandler(props);\n  }\n}\n\nMultipleValuesInput.assertStatic(ChecklistInput);\n\nexport default ChecklistInput;\n"],"sourceRoot":""}